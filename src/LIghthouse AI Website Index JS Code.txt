(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        i(r);
    new MutationObserver(r => {
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity),
        r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function i(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const s = n(r);
        fetch(r.href, s)
    }
}
)();
var Xn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function RE(t) {
    if (t.__esModule)
        return t;
    var e = t.default;
    if (typeof e == "function") {
        var n = function i() {
            return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else
        n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    Object.keys(t).forEach(function(i) {
        var r = Object.getOwnPropertyDescriptor(t, i);
        Object.defineProperty(n, i, r.get ? r : {
            enumerable: !0,
            get: function() {
                return t[i]
            }
        })
    }),
    n
}
var Ny = {
    exports: {}
}
  , Lu = {}
  , Dy = {
    exports: {}
}
  , Ge = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hl = Symbol.for("react.element")
  , PE = Symbol.for("react.portal")
  , NE = Symbol.for("react.fragment")
  , DE = Symbol.for("react.strict_mode")
  , LE = Symbol.for("react.profiler")
  , IE = Symbol.for("react.provider")
  , kE = Symbol.for("react.context")
  , UE = Symbol.for("react.forward_ref")
  , OE = Symbol.for("react.suspense")
  , FE = Symbol.for("react.memo")
  , BE = Symbol.for("react.lazy")
  , Wg = Symbol.iterator;
function zE(t) {
    return t === null || typeof t != "object" ? null : (t = Wg && t[Wg] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var Ly = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , Iy = Object.assign
  , ky = {};
function zo(t, e, n) {
    this.props = t,
    this.context = e,
    this.refs = ky,
    this.updater = n || Ly
}
zo.prototype.isReactComponent = {};
zo.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState")
}
;
zo.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
}
;
function Uy() {}
Uy.prototype = zo.prototype;
function em(t, e, n) {
    this.props = t,
    this.context = e,
    this.refs = ky,
    this.updater = n || Ly
}
var tm = em.prototype = new Uy;
tm.constructor = em;
Iy(tm, zo.prototype);
tm.isPureReactComponent = !0;
var $g = Array.isArray
  , Oy = Object.prototype.hasOwnProperty
  , nm = {
    current: null
}
  , Fy = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function By(t, e, n) {
    var i, r = {}, s = null, o = null;
    if (e != null)
        for (i in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (s = "" + e.key),
        e)
            Oy.call(e, i) && !Fy.hasOwnProperty(i) && (r[i] = e[i]);
    var a = arguments.length - 2;
    if (a === 1)
        r.children = n;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        r.children = l
    }
    if (t && t.defaultProps)
        for (i in a = t.defaultProps,
        a)
            r[i] === void 0 && (r[i] = a[i]);
    return {
        $$typeof: hl,
        type: t,
        key: s,
        ref: o,
        props: r,
        _owner: nm.current
    }
}
function VE(t, e) {
    return {
        $$typeof: hl,
        type: t.type,
        key: e,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}
function im(t) {
    return typeof t == "object" && t !== null && t.$$typeof === hl
}
function jE(t) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(n) {
        return e[n]
    })
}
var Xg = /\/+/g;
function cd(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? jE("" + t.key) : e.toString(36)
}
function Rc(t, e, n, i, r) {
    var s = typeof t;
    (s === "undefined" || s === "boolean") && (t = null);
    var o = !1;
    if (t === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (t.$$typeof) {
            case hl:
            case PE:
                o = !0
            }
        }
    if (o)
        return o = t,
        r = r(o),
        t = i === "" ? "." + cd(o, 0) : i,
        $g(r) ? (n = "",
        t != null && (n = t.replace(Xg, "$&/") + "/"),
        Rc(r, e, n, "", function(c) {
            return c
        })) : r != null && (im(r) && (r = VE(r, n + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(Xg, "$&/") + "/") + t)),
        e.push(r)),
        1;
    if (o = 0,
    i = i === "" ? "." : i + ":",
    $g(t))
        for (var a = 0; a < t.length; a++) {
            s = t[a];
            var l = i + cd(s, a);
            o += Rc(s, e, n, l, r)
        }
    else if (l = zE(t),
    typeof l == "function")
        for (t = l.call(t),
        a = 0; !(s = t.next()).done; )
            s = s.value,
            l = i + cd(s, a++),
            o += Rc(s, e, n, l, r);
    else if (s === "object")
        throw e = String(t),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function Ll(t, e, n) {
    if (t == null)
        return t;
    var i = []
      , r = 0;
    return Rc(t, i, "", "", function(s) {
        return e.call(n, s, r++)
    }),
    i
}
function HE(t) {
    if (t._status === -1) {
        var e = t._result;
        e = e(),
        e.then(function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 1,
            t._result = n)
        }, function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 2,
            t._result = n)
        }),
        t._status === -1 && (t._status = 0,
        t._result = e)
    }
    if (t._status === 1)
        return t._result.default;
    throw t._result
}
var un = {
    current: null
}
  , Pc = {
    transition: null
}
  , GE = {
    ReactCurrentDispatcher: un,
    ReactCurrentBatchConfig: Pc,
    ReactCurrentOwner: nm
};
function zy() {
    throw Error("act(...) is not supported in production builds of React.")
}
Ge.Children = {
    map: Ll,
    forEach: function(t, e, n) {
        Ll(t, function() {
            e.apply(this, arguments)
        }, n)
    },
    count: function(t) {
        var e = 0;
        return Ll(t, function() {
            e++
        }),
        e
    },
    toArray: function(t) {
        return Ll(t, function(e) {
            return e
        }) || []
    },
    only: function(t) {
        if (!im(t))
            throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
Ge.Component = zo;
Ge.Fragment = NE;
Ge.Profiler = LE;
Ge.PureComponent = em;
Ge.StrictMode = DE;
Ge.Suspense = OE;
Ge.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = GE;
Ge.act = zy;
Ge.cloneElement = function(t, e, n) {
    if (t == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var i = Iy({}, t.props)
      , r = t.key
      , s = t.ref
      , o = t._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref,
        o = nm.current),
        e.key !== void 0 && (r = "" + e.key),
        t.type && t.type.defaultProps)
            var a = t.type.defaultProps;
        for (l in e)
            Oy.call(e, l) && !Fy.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        i.children = n;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        i.children = a
    }
    return {
        $$typeof: hl,
        type: t.type,
        key: r,
        ref: s,
        props: i,
        _owner: o
    }
}
;
Ge.createContext = function(t) {
    return t = {
        $$typeof: kE,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    t.Provider = {
        $$typeof: IE,
        _context: t
    },
    t.Consumer = t
}
;
Ge.createElement = By;
Ge.createFactory = function(t) {
    var e = By.bind(null, t);
    return e.type = t,
    e
}
;
Ge.createRef = function() {
    return {
        current: null
    }
}
;
Ge.forwardRef = function(t) {
    return {
        $$typeof: UE,
        render: t
    }
}
;
Ge.isValidElement = im;
Ge.lazy = function(t) {
    return {
        $$typeof: BE,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: HE
    }
}
;
Ge.memo = function(t, e) {
    return {
        $$typeof: FE,
        type: t,
        compare: e === void 0 ? null : e
    }
}
;
Ge.startTransition = function(t) {
    var e = Pc.transition;
    Pc.transition = {};
    try {
        t()
    } finally {
        Pc.transition = e
    }
}
;
Ge.unstable_act = zy;
Ge.useCallback = function(t, e) {
    return un.current.useCallback(t, e)
}
;
Ge.useContext = function(t) {
    return un.current.useContext(t)
}
;
Ge.useDebugValue = function() {}
;
Ge.useDeferredValue = function(t) {
    return un.current.useDeferredValue(t)
}
;
Ge.useEffect = function(t, e) {
    return un.current.useEffect(t, e)
}
;
Ge.useId = function() {
    return un.current.useId()
}
;
Ge.useImperativeHandle = function(t, e, n) {
    return un.current.useImperativeHandle(t, e, n)
}
;
Ge.useInsertionEffect = function(t, e) {
    return un.current.useInsertionEffect(t, e)
}
;
Ge.useLayoutEffect = function(t, e) {
    return un.current.useLayoutEffect(t, e)
}
;
Ge.useMemo = function(t, e) {
    return un.current.useMemo(t, e)
}
;
Ge.useReducer = function(t, e, n) {
    return un.current.useReducer(t, e, n)
}
;
Ge.useRef = function(t) {
    return un.current.useRef(t)
}
;
Ge.useState = function(t) {
    return un.current.useState(t)
}
;
Ge.useSyncExternalStore = function(t, e, n) {
    return un.current.useSyncExternalStore(t, e, n)
}
;
Ge.useTransition = function() {
    return un.current.useTransition()
}
;
Ge.version = "18.3.1";
Dy.exports = Ge;
var oe = Dy.exports;
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WE = oe
  , $E = Symbol.for("react.element")
  , XE = Symbol.for("react.fragment")
  , qE = Object.prototype.hasOwnProperty
  , KE = WE.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , YE = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Vy(t, e, n) {
    var i, r = {}, s = null, o = null;
    n !== void 0 && (s = "" + n),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (i in e)
        qE.call(e, i) && !YE.hasOwnProperty(i) && (r[i] = e[i]);
    if (t && t.defaultProps)
        for (i in e = t.defaultProps,
        e)
            r[i] === void 0 && (r[i] = e[i]);
    return {
        $$typeof: $E,
        type: t,
        key: s,
        ref: o,
        props: r,
        _owner: KE.current
    }
}
Lu.Fragment = XE;
Lu.jsx = Vy;
Lu.jsxs = Vy;
Ny.exports = Lu;
var m = Ny.exports
  , jy = {
    exports: {}
}
  , Dn = {}
  , Hy = {
    exports: {}
}
  , Gy = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(D, G) {
        var Y = D.length;
        D.push(G);
        e: for (; 0 < Y; ) {
            var le = Y - 1 >>> 1
              , xe = D[le];
            if (0 < r(xe, G))
                D[le] = G,
                D[Y] = xe,
                Y = le;
            else
                break e
        }
    }
    function n(D) {
        return D.length === 0 ? null : D[0]
    }
    function i(D) {
        if (D.length === 0)
            return null;
        var G = D[0]
          , Y = D.pop();
        if (Y !== G) {
            D[0] = Y;
            e: for (var le = 0, xe = D.length, qe = xe >>> 1; le < qe; ) {
                var Ke = 2 * (le + 1) - 1
                  , We = D[Ke]
                  , X = Ke + 1
                  , Q = D[X];
                if (0 > r(We, Y))
                    X < xe && 0 > r(Q, We) ? (D[le] = Q,
                    D[X] = Y,
                    le = X) : (D[le] = We,
                    D[Ke] = Y,
                    le = Ke);
                else if (X < xe && 0 > r(Q, Y))
                    D[le] = Q,
                    D[X] = Y,
                    le = X;
                else
                    break e
            }
        }
        return G
    }
    function r(D, G) {
        var Y = D.sortIndex - G.sortIndex;
        return Y !== 0 ? Y : D.id - G.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        t.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , u = 1
      , d = null
      , h = 3
      , p = !1
      , v = !1
      , x = !1
      , g = typeof setTimeout == "function" ? setTimeout : null
      , f = typeof clearTimeout == "function" ? clearTimeout : null
      , y = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function _(D) {
        for (var G = n(c); G !== null; ) {
            if (G.callback === null)
                i(c);
            else if (G.startTime <= D)
                i(c),
                G.sortIndex = G.expirationTime,
                e(l, G);
            else
                break;
            G = n(c)
        }
    }
    function S(D) {
        if (x = !1,
        _(D),
        !v)
            if (n(l) !== null)
                v = !0,
                q(T);
            else {
                var G = n(c);
                G !== null && B(S, G.startTime - D)
            }
    }
    function T(D, G) {
        v = !1,
        x && (x = !1,
        f(P),
        P = -1),
        p = !0;
        var Y = h;
        try {
            for (_(G),
            d = n(l); d !== null && (!(d.expirationTime > G) || D && !L()); ) {
                var le = d.callback;
                if (typeof le == "function") {
                    d.callback = null,
                    h = d.priorityLevel;
                    var xe = le(d.expirationTime <= G);
                    G = t.unstable_now(),
                    typeof xe == "function" ? d.callback = xe : d === n(l) && i(l),
                    _(G)
                } else
                    i(l);
                d = n(l)
            }
            if (d !== null)
                var qe = !0;
            else {
                var Ke = n(c);
                Ke !== null && B(S, Ke.startTime - G),
                qe = !1
            }
            return qe
        } finally {
            d = null,
            h = Y,
            p = !1
        }
    }
    var A = !1
      , C = null
      , P = -1
      , M = 5
      , b = -1;
    function L() {
        return !(t.unstable_now() - b < M)
    }
    function F() {
        if (C !== null) {
            var D = t.unstable_now();
            b = D;
            var G = !0;
            try {
                G = C(!0, D)
            } finally {
                G ? H() : (A = !1,
                C = null)
            }
        } else
            A = !1
    }
    var H;
    if (typeof y == "function")
        H = function() {
            y(F)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Z = new MessageChannel
          , $ = Z.port2;
        Z.port1.onmessage = F,
        H = function() {
            $.postMessage(null)
        }
    } else
        H = function() {
            g(F, 0)
        }
        ;
    function q(D) {
        C = D,
        A || (A = !0,
        H())
    }
    function B(D, G) {
        P = g(function() {
            D(t.unstable_now())
        }, G)
    }
    t.unstable_IdlePriority = 5,
    t.unstable_ImmediatePriority = 1,
    t.unstable_LowPriority = 4,
    t.unstable_NormalPriority = 3,
    t.unstable_Profiling = null,
    t.unstable_UserBlockingPriority = 2,
    t.unstable_cancelCallback = function(D) {
        D.callback = null
    }
    ,
    t.unstable_continueExecution = function() {
        v || p || (v = !0,
        q(T))
    }
    ,
    t.unstable_forceFrameRate = function(D) {
        0 > D || 125 < D ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : M = 0 < D ? Math.floor(1e3 / D) : 5
    }
    ,
    t.unstable_getCurrentPriorityLevel = function() {
        return h
    }
    ,
    t.unstable_getFirstCallbackNode = function() {
        return n(l)
    }
    ,
    t.unstable_next = function(D) {
        switch (h) {
        case 1:
        case 2:
        case 3:
            var G = 3;
            break;
        default:
            G = h
        }
        var Y = h;
        h = G;
        try {
            return D()
        } finally {
            h = Y
        }
    }
    ,
    t.unstable_pauseExecution = function() {}
    ,
    t.unstable_requestPaint = function() {}
    ,
    t.unstable_runWithPriority = function(D, G) {
        switch (D) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            D = 3
        }
        var Y = h;
        h = D;
        try {
            return G()
        } finally {
            h = Y
        }
    }
    ,
    t.unstable_scheduleCallback = function(D, G, Y) {
        var le = t.unstable_now();
        switch (typeof Y == "object" && Y !== null ? (Y = Y.delay,
        Y = typeof Y == "number" && 0 < Y ? le + Y : le) : Y = le,
        D) {
        case 1:
            var xe = -1;
            break;
        case 2:
            xe = 250;
            break;
        case 5:
            xe = 1073741823;
            break;
        case 4:
            xe = 1e4;
            break;
        default:
            xe = 5e3
        }
        return xe = Y + xe,
        D = {
            id: u++,
            callback: G,
            priorityLevel: D,
            startTime: Y,
            expirationTime: xe,
            sortIndex: -1
        },
        Y > le ? (D.sortIndex = Y,
        e(c, D),
        n(l) === null && D === n(c) && (x ? (f(P),
        P = -1) : x = !0,
        B(S, Y - le))) : (D.sortIndex = xe,
        e(l, D),
        v || p || (v = !0,
        q(T))),
        D
    }
    ,
    t.unstable_shouldYield = L,
    t.unstable_wrapCallback = function(D) {
        var G = h;
        return function() {
            var Y = h;
            h = G;
            try {
                return D.apply(this, arguments)
            } finally {
                h = Y
            }
        }
    }
}
)(Gy);
Hy.exports = Gy;
var ZE = Hy.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JE = oe
  , Nn = ZE;
function te(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)
        e += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var Wy = new Set
  , Oa = {};
function Es(t, e) {
    To(t, e),
    To(t + "Capture", e)
}
function To(t, e) {
    for (Oa[t] = e,
    t = 0; t < e.length; t++)
        Wy.add(e[t])
}
var Gi = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Fh = Object.prototype.hasOwnProperty
  , QE = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , qg = {}
  , Kg = {};
function eT(t) {
    return Fh.call(Kg, t) ? !0 : Fh.call(qg, t) ? !1 : QE.test(t) ? Kg[t] = !0 : (qg[t] = !0,
    !1)
}
function tT(t, e, n, i) {
    if (n !== null && n.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return i ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5),
        t !== "data-" && t !== "aria-");
    default:
        return !1
    }
}
function nT(t, e, n, i) {
    if (e === null || typeof e > "u" || tT(t, e, n, i))
        return !0;
    if (i)
        return !1;
    if (n !== null)
        switch (n.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function dn(t, e, n, i, r, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = i,
    this.attributeNamespace = r,
    this.mustUseProperty = n,
    this.propertyName = t,
    this.type = e,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var qt = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    qt[t] = new dn(t,0,!1,t,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(t) {
    var e = t[0];
    qt[e] = new dn(e,1,!1,t[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    qt[t] = new dn(t,2,!1,t.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    qt[t] = new dn(t,2,!1,t,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    qt[t] = new dn(t,3,!1,t.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    qt[t] = new dn(t,3,!0,t,null,!1,!1)
});
["capture", "download"].forEach(function(t) {
    qt[t] = new dn(t,4,!1,t,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    qt[t] = new dn(t,6,!1,t,null,!1,!1)
});
["rowSpan", "start"].forEach(function(t) {
    qt[t] = new dn(t,5,!1,t.toLowerCase(),null,!1,!1)
});
var rm = /[\-:]([a-z])/g;
function sm(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(rm, sm);
    qt[e] = new dn(e,1,!1,t,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(rm, sm);
    qt[e] = new dn(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var e = t.replace(rm, sm);
    qt[e] = new dn(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    qt[t] = new dn(t,1,!1,t.toLowerCase(),null,!1,!1)
});
qt.xlinkHref = new dn("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(t) {
    qt[t] = new dn(t,1,!1,t.toLowerCase(),null,!0,!0)
});
function om(t, e, n, i) {
    var r = qt.hasOwnProperty(e) ? qt[e] : null;
    (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (nT(e, n, r, i) && (n = null),
    i || r === null ? eT(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : r.mustUseProperty ? t[r.propertyName] = n === null ? r.type === 3 ? !1 : "" : n : (e = r.attributeName,
    i = r.attributeNamespace,
    n === null ? t.removeAttribute(e) : (r = r.type,
    n = r === 3 || r === 4 && n === !0 ? "" : "" + n,
    i ? t.setAttributeNS(i, e, n) : t.setAttribute(e, n))))
}
var Ji = JE.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Il = Symbol.for("react.element")
  , Zs = Symbol.for("react.portal")
  , Js = Symbol.for("react.fragment")
  , am = Symbol.for("react.strict_mode")
  , Bh = Symbol.for("react.profiler")
  , $y = Symbol.for("react.provider")
  , Xy = Symbol.for("react.context")
  , lm = Symbol.for("react.forward_ref")
  , zh = Symbol.for("react.suspense")
  , Vh = Symbol.for("react.suspense_list")
  , cm = Symbol.for("react.memo")
  , dr = Symbol.for("react.lazy")
  , qy = Symbol.for("react.offscreen")
  , Yg = Symbol.iterator;
function Zo(t) {
    return t === null || typeof t != "object" ? null : (t = Yg && t[Yg] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var wt = Object.assign, ud;
function fa(t) {
    if (ud === void 0)
        try {
            throw Error()
        } catch (n) {
            var e = n.stack.trim().match(/\n( *(at )?)/);
            ud = e && e[1] || ""
        }
    return `
` + ud + t
}
var dd = !1;
function hd(t, e) {
    if (!t || dd)
        return "";
    dd = !0;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var i = c
                }
                Reflect.construct(t, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    i = c
                }
                t.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                i = c
            }
            t()
        }
    } catch (c) {
        if (c && i && typeof c.stack == "string") {
            for (var r = c.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (r[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || r[o] !== s[a]) {
                                var l = `
` + r[o].replace(" at new ", " at ");
                                return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        dd = !1,
        Error.prepareStackTrace = n
    }
    return (t = t ? t.displayName || t.name : "") ? fa(t) : ""
}
function iT(t) {
    switch (t.tag) {
    case 5:
        return fa(t.type);
    case 16:
        return fa("Lazy");
    case 13:
        return fa("Suspense");
    case 19:
        return fa("SuspenseList");
    case 0:
    case 2:
    case 15:
        return t = hd(t.type, !1),
        t;
    case 11:
        return t = hd(t.type.render, !1),
        t;
    case 1:
        return t = hd(t.type, !0),
        t;
    default:
        return ""
    }
}
function jh(t) {
    if (t == null)
        return null;
    if (typeof t == "function")
        return t.displayName || t.name || null;
    if (typeof t == "string")
        return t;
    switch (t) {
    case Js:
        return "Fragment";
    case Zs:
        return "Portal";
    case Bh:
        return "Profiler";
    case am:
        return "StrictMode";
    case zh:
        return "Suspense";
    case Vh:
        return "SuspenseList"
    }
    if (typeof t == "object")
        switch (t.$$typeof) {
        case Xy:
            return (t.displayName || "Context") + ".Consumer";
        case $y:
            return (t._context.displayName || "Context") + ".Provider";
        case lm:
            var e = t.render;
            return t = t.displayName,
            t || (t = e.displayName || e.name || "",
            t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"),
            t;
        case cm:
            return e = t.displayName || null,
            e !== null ? e : jh(t.type) || "Memo";
        case dr:
            e = t._payload,
            t = t._init;
            try {
                return jh(t(e))
            } catch {}
        }
    return null
}
function rT(t) {
    var e = t.type;
    switch (t.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return t = e.render,
        t = t.displayName || t.name || "",
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return jh(e);
    case 8:
        return e === am ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function Rr(t) {
    switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return t;
    case "object":
        return t;
    default:
        return ""
    }
}
function Ky(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function sT(t) {
    var e = Ky(t) ? "checked" : "value"
      , n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e)
      , i = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
        var r = n.get
          , s = n.set;
        return Object.defineProperty(t, e, {
            configurable: !0,
            get: function() {
                return r.call(this)
            },
            set: function(o) {
                i = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(t, e, {
            enumerable: n.enumerable
        }),
        {
            getValue: function() {
                return i
            },
            setValue: function(o) {
                i = "" + o
            },
            stopTracking: function() {
                t._valueTracker = null,
                delete t[e]
            }
        }
    }
}
function kl(t) {
    t._valueTracker || (t._valueTracker = sT(t))
}
function Yy(t) {
    if (!t)
        return !1;
    var e = t._valueTracker;
    if (!e)
        return !0;
    var n = e.getValue()
      , i = "";
    return t && (i = Ky(t) ? t.checked ? "true" : "false" : t.value),
    t = i,
    t !== n ? (e.setValue(t),
    !0) : !1
}
function Zc(t) {
    if (t = t || (typeof document < "u" ? document : void 0),
    typeof t > "u")
        return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}
function Hh(t, e) {
    var n = e.checked;
    return wt({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: n ?? t._wrapperState.initialChecked
    })
}
function Zg(t, e) {
    var n = e.defaultValue == null ? "" : e.defaultValue
      , i = e.checked != null ? e.checked : e.defaultChecked;
    n = Rr(e.value != null ? e.value : n),
    t._wrapperState = {
        initialChecked: i,
        initialValue: n,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function Zy(t, e) {
    e = e.checked,
    e != null && om(t, "checked", e, !1)
}
function Gh(t, e) {
    Zy(t, e);
    var n = Rr(e.value)
      , i = e.type;
    if (n != null)
        i === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
    else if (i === "submit" || i === "reset") {
        t.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? Wh(t, e.type, n) : e.hasOwnProperty("defaultValue") && Wh(t, e.type, Rr(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}
function Jg(t, e, n) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var i = e.type;
        if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + t._wrapperState.initialValue,
        n || e === t.value || (t.value = e),
        t.defaultValue = e
    }
    n = t.name,
    n !== "" && (t.name = ""),
    t.defaultChecked = !!t._wrapperState.initialChecked,
    n !== "" && (t.name = n)
}
function Wh(t, e, n) {
    (e !== "number" || Zc(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n))
}
var pa = Array.isArray;
function go(t, e, n, i) {
    if (t = t.options,
    e) {
        e = {};
        for (var r = 0; r < n.length; r++)
            e["$" + n[r]] = !0;
        for (n = 0; n < t.length; n++)
            r = e.hasOwnProperty("$" + t[n].value),
            t[n].selected !== r && (t[n].selected = r),
            r && i && (t[n].defaultSelected = !0)
    } else {
        for (n = "" + Rr(n),
        e = null,
        r = 0; r < t.length; r++) {
            if (t[r].value === n) {
                t[r].selected = !0,
                i && (t[r].defaultSelected = !0);
                return
            }
            e !== null || t[r].disabled || (e = t[r])
        }
        e !== null && (e.selected = !0)
    }
}
function $h(t, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(te(91));
    return wt({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}
function Qg(t, e) {
    var n = e.value;
    if (n == null) {
        if (n = e.children,
        e = e.defaultValue,
        n != null) {
            if (e != null)
                throw Error(te(92));
            if (pa(n)) {
                if (1 < n.length)
                    throw Error(te(93));
                n = n[0]
            }
            e = n
        }
        e == null && (e = ""),
        n = e
    }
    t._wrapperState = {
        initialValue: Rr(n)
    }
}
function Jy(t, e) {
    var n = Rr(e.value)
      , i = Rr(e.defaultValue);
    n != null && (n = "" + n,
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    i != null && (t.defaultValue = "" + i)
}
function e0(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}
function Qy(t) {
    switch (t) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function Xh(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? Qy(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var Ul, ex = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, n, i, r) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(e, n, i, r)
        })
    }
    : t
}(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in t)
        t.innerHTML = e;
    else {
        for (Ul = Ul || document.createElement("div"),
        Ul.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Ul.firstChild; t.firstChild; )
            t.removeChild(t.firstChild);
        for (; e.firstChild; )
            t.appendChild(e.firstChild)
    }
});
function Fa(t, e) {
    if (e) {
        var n = t.firstChild;
        if (n && n === t.lastChild && n.nodeType === 3) {
            n.nodeValue = e;
            return
        }
    }
    t.textContent = e
}
var xa = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , oT = ["Webkit", "ms", "Moz", "O"];
Object.keys(xa).forEach(function(t) {
    oT.forEach(function(e) {
        e = e + t.charAt(0).toUpperCase() + t.substring(1),
        xa[e] = xa[t]
    })
});
function tx(t, e, n) {
    return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || xa.hasOwnProperty(t) && xa[t] ? ("" + e).trim() : e + "px"
}
function nx(t, e) {
    t = t.style;
    for (var n in e)
        if (e.hasOwnProperty(n)) {
            var i = n.indexOf("--") === 0
              , r = tx(n, e[n], i);
            n === "float" && (n = "cssFloat"),
            i ? t.setProperty(n, r) : t[n] = r
        }
}
var aT = wt({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function qh(t, e) {
    if (e) {
        if (aT[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(te(137, t));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(te(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(te(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(te(62))
    }
}
function Kh(t, e) {
    if (t.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var Yh = null;
function um(t) {
    return t = t.target || t.srcElement || window,
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
}
var Zh = null
  , vo = null
  , _o = null;
function t0(t) {
    if (t = ml(t)) {
        if (typeof Zh != "function")
            throw Error(te(280));
        var e = t.stateNode;
        e && (e = Fu(e),
        Zh(t.stateNode, t.type, e))
    }
}
function ix(t) {
    vo ? _o ? _o.push(t) : _o = [t] : vo = t
}
function rx() {
    if (vo) {
        var t = vo
          , e = _o;
        if (_o = vo = null,
        t0(t),
        e)
            for (t = 0; t < e.length; t++)
                t0(e[t])
    }
}
function sx(t, e) {
    return t(e)
}
function ox() {}
var fd = !1;
function ax(t, e, n) {
    if (fd)
        return t(e, n);
    fd = !0;
    try {
        return sx(t, e, n)
    } finally {
        fd = !1,
        (vo !== null || _o !== null) && (ox(),
        rx())
    }
}
function Ba(t, e) {
    var n = t.stateNode;
    if (n === null)
        return null;
    var i = Fu(n);
    if (i === null)
        return null;
    n = i[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (i = !i.disabled) || (t = t.type,
        i = !(t === "button" || t === "input" || t === "select" || t === "textarea")),
        t = !i;
        break e;
    default:
        t = !1
    }
    if (t)
        return null;
    if (n && typeof n != "function")
        throw Error(te(231, e, typeof n));
    return n
}
var Jh = !1;
if (Gi)
    try {
        var Jo = {};
        Object.defineProperty(Jo, "passive", {
            get: function() {
                Jh = !0
            }
        }),
        window.addEventListener("test", Jo, Jo),
        window.removeEventListener("test", Jo, Jo)
    } catch {
        Jh = !1
    }
function lT(t, e, n, i, r, s, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(n, c)
    } catch (u) {
        this.onError(u)
    }
}
var Sa = !1
  , Jc = null
  , Qc = !1
  , Qh = null
  , cT = {
    onError: function(t) {
        Sa = !0,
        Jc = t
    }
};
function uT(t, e, n, i, r, s, o, a, l) {
    Sa = !1,
    Jc = null,
    lT.apply(cT, arguments)
}
function dT(t, e, n, i, r, s, o, a, l) {
    if (uT.apply(this, arguments),
    Sa) {
        if (Sa) {
            var c = Jc;
            Sa = !1,
            Jc = null
        } else
            throw Error(te(198));
        Qc || (Qc = !0,
        Qh = c)
    }
}
function Ts(t) {
    var e = t
      , n = t;
    if (t.alternate)
        for (; e.return; )
            e = e.return;
    else {
        t = e;
        do
            e = t,
            e.flags & 4098 && (n = e.return),
            t = e.return;
        while (t)
    }
    return e.tag === 3 ? n : null
}
function lx(t) {
    if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate,
        t !== null && (e = t.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function n0(t) {
    if (Ts(t) !== t)
        throw Error(te(188))
}
function hT(t) {
    var e = t.alternate;
    if (!e) {
        if (e = Ts(t),
        e === null)
            throw Error(te(188));
        return e !== t ? null : t
    }
    for (var n = t, i = e; ; ) {
        var r = n.return;
        if (r === null)
            break;
        var s = r.alternate;
        if (s === null) {
            if (i = r.return,
            i !== null) {
                n = i;
                continue
            }
            break
        }
        if (r.child === s.child) {
            for (s = r.child; s; ) {
                if (s === n)
                    return n0(r),
                    t;
                if (s === i)
                    return n0(r),
                    e;
                s = s.sibling
            }
            throw Error(te(188))
        }
        if (n.return !== i.return)
            n = r,
            i = s;
        else {
            for (var o = !1, a = r.child; a; ) {
                if (a === n) {
                    o = !0,
                    n = r,
                    i = s;
                    break
                }
                if (a === i) {
                    o = !0,
                    i = r,
                    n = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === n) {
                        o = !0,
                        n = s,
                        i = r;
                        break
                    }
                    if (a === i) {
                        o = !0,
                        i = s,
                        n = r;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(te(189))
            }
        }
        if (n.alternate !== i)
            throw Error(te(190))
    }
    if (n.tag !== 3)
        throw Error(te(188));
    return n.stateNode.current === n ? t : e
}
function cx(t) {
    return t = hT(t),
    t !== null ? ux(t) : null
}
function ux(t) {
    if (t.tag === 5 || t.tag === 6)
        return t;
    for (t = t.child; t !== null; ) {
        var e = ux(t);
        if (e !== null)
            return e;
        t = t.sibling
    }
    return null
}
var dx = Nn.unstable_scheduleCallback
  , i0 = Nn.unstable_cancelCallback
  , fT = Nn.unstable_shouldYield
  , pT = Nn.unstable_requestPaint
  , Ct = Nn.unstable_now
  , mT = Nn.unstable_getCurrentPriorityLevel
  , dm = Nn.unstable_ImmediatePriority
  , hx = Nn.unstable_UserBlockingPriority
  , eu = Nn.unstable_NormalPriority
  , gT = Nn.unstable_LowPriority
  , fx = Nn.unstable_IdlePriority
  , Iu = null
  , xi = null;
function vT(t) {
    if (xi && typeof xi.onCommitFiberRoot == "function")
        try {
            xi.onCommitFiberRoot(Iu, t, void 0, (t.current.flags & 128) === 128)
        } catch {}
}
var li = Math.clz32 ? Math.clz32 : xT
  , _T = Math.log
  , yT = Math.LN2;
function xT(t) {
    return t >>>= 0,
    t === 0 ? 32 : 31 - (_T(t) / yT | 0) | 0
}
var Ol = 64
  , Fl = 4194304;
function ma(t) {
    switch (t & -t) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return t & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return t
    }
}
function tu(t, e) {
    var n = t.pendingLanes;
    if (n === 0)
        return 0;
    var i = 0
      , r = t.suspendedLanes
      , s = t.pingedLanes
      , o = n & 268435455;
    if (o !== 0) {
        var a = o & ~r;
        a !== 0 ? i = ma(a) : (s &= o,
        s !== 0 && (i = ma(s)))
    } else
        o = n & ~r,
        o !== 0 ? i = ma(o) : s !== 0 && (i = ma(s));
    if (i === 0)
        return 0;
    if (e !== 0 && e !== i && !(e & r) && (r = i & -i,
    s = e & -e,
    r >= s || r === 16 && (s & 4194240) !== 0))
        return e;
    if (i & 4 && (i |= n & 16),
    e = t.entangledLanes,
    e !== 0)
        for (t = t.entanglements,
        e &= i; 0 < e; )
            n = 31 - li(e),
            r = 1 << n,
            i |= t[n],
            e &= ~r;
    return i
}
function ST(t, e) {
    switch (t) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function wT(t, e) {
    for (var n = t.suspendedLanes, i = t.pingedLanes, r = t.expirationTimes, s = t.pendingLanes; 0 < s; ) {
        var o = 31 - li(s)
          , a = 1 << o
          , l = r[o];
        l === -1 ? (!(a & n) || a & i) && (r[o] = ST(a, e)) : l <= e && (t.expiredLanes |= a),
        s &= ~a
    }
}
function ef(t) {
    return t = t.pendingLanes & -1073741825,
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}
function px() {
    var t = Ol;
    return Ol <<= 1,
    !(Ol & 4194240) && (Ol = 64),
    t
}
function pd(t) {
    for (var e = [], n = 0; 31 > n; n++)
        e.push(t);
    return e
}
function fl(t, e, n) {
    t.pendingLanes |= e,
    e !== 536870912 && (t.suspendedLanes = 0,
    t.pingedLanes = 0),
    t = t.eventTimes,
    e = 31 - li(e),
    t[e] = n
}
function bT(t, e) {
    var n = t.pendingLanes & ~e;
    t.pendingLanes = e,
    t.suspendedLanes = 0,
    t.pingedLanes = 0,
    t.expiredLanes &= e,
    t.mutableReadLanes &= e,
    t.entangledLanes &= e,
    e = t.entanglements;
    var i = t.eventTimes;
    for (t = t.expirationTimes; 0 < n; ) {
        var r = 31 - li(n)
          , s = 1 << r;
        e[r] = 0,
        i[r] = -1,
        t[r] = -1,
        n &= ~s
    }
}
function hm(t, e) {
    var n = t.entangledLanes |= e;
    for (t = t.entanglements; n; ) {
        var i = 31 - li(n)
          , r = 1 << i;
        r & e | t[i] & e && (t[i] |= e),
        n &= ~r
    }
}
var nt = 0;
function mx(t) {
    return t &= -t,
    1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var gx, fm, vx, _x, yx, tf = !1, Bl = [], yr = null, xr = null, Sr = null, za = new Map, Va = new Map, fr = [], ET = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function r0(t, e) {
    switch (t) {
    case "focusin":
    case "focusout":
        yr = null;
        break;
    case "dragenter":
    case "dragleave":
        xr = null;
        break;
    case "mouseover":
    case "mouseout":
        Sr = null;
        break;
    case "pointerover":
    case "pointerout":
        za.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Va.delete(e.pointerId)
    }
}
function Qo(t, e, n, i, r, s) {
    return t === null || t.nativeEvent !== s ? (t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r]
    },
    e !== null && (e = ml(e),
    e !== null && fm(e)),
    t) : (t.eventSystemFlags |= i,
    e = t.targetContainers,
    r !== null && e.indexOf(r) === -1 && e.push(r),
    t)
}
function TT(t, e, n, i, r) {
    switch (e) {
    case "focusin":
        return yr = Qo(yr, t, e, n, i, r),
        !0;
    case "dragenter":
        return xr = Qo(xr, t, e, n, i, r),
        !0;
    case "mouseover":
        return Sr = Qo(Sr, t, e, n, i, r),
        !0;
    case "pointerover":
        var s = r.pointerId;
        return za.set(s, Qo(za.get(s) || null, t, e, n, i, r)),
        !0;
    case "gotpointercapture":
        return s = r.pointerId,
        Va.set(s, Qo(Va.get(s) || null, t, e, n, i, r)),
        !0
    }
    return !1
}
function xx(t) {
    var e = os(t.target);
    if (e !== null) {
        var n = Ts(e);
        if (n !== null) {
            if (e = n.tag,
            e === 13) {
                if (e = lx(n),
                e !== null) {
                    t.blockedOn = e,
                    yx(t.priority, function() {
                        vx(n)
                    });
                    return
                }
            } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}
function Nc(t) {
    if (t.blockedOn !== null)
        return !1;
    for (var e = t.targetContainers; 0 < e.length; ) {
        var n = nf(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
        if (n === null) {
            n = t.nativeEvent;
            var i = new n.constructor(n.type,n);
            Yh = i,
            n.target.dispatchEvent(i),
            Yh = null
        } else
            return e = ml(n),
            e !== null && fm(e),
            t.blockedOn = n,
            !1;
        e.shift()
    }
    return !0
}
function s0(t, e, n) {
    Nc(t) && n.delete(e)
}
function MT() {
    tf = !1,
    yr !== null && Nc(yr) && (yr = null),
    xr !== null && Nc(xr) && (xr = null),
    Sr !== null && Nc(Sr) && (Sr = null),
    za.forEach(s0),
    Va.forEach(s0)
}
function ea(t, e) {
    t.blockedOn === e && (t.blockedOn = null,
    tf || (tf = !0,
    Nn.unstable_scheduleCallback(Nn.unstable_NormalPriority, MT)))
}
function ja(t) {
    function e(r) {
        return ea(r, t)
    }
    if (0 < Bl.length) {
        ea(Bl[0], t);
        for (var n = 1; n < Bl.length; n++) {
            var i = Bl[n];
            i.blockedOn === t && (i.blockedOn = null)
        }
    }
    for (yr !== null && ea(yr, t),
    xr !== null && ea(xr, t),
    Sr !== null && ea(Sr, t),
    za.forEach(e),
    Va.forEach(e),
    n = 0; n < fr.length; n++)
        i = fr[n],
        i.blockedOn === t && (i.blockedOn = null);
    for (; 0 < fr.length && (n = fr[0],
    n.blockedOn === null); )
        xx(n),
        n.blockedOn === null && fr.shift()
}
var yo = Ji.ReactCurrentBatchConfig
  , nu = !0;
function AT(t, e, n, i) {
    var r = nt
      , s = yo.transition;
    yo.transition = null;
    try {
        nt = 1,
        pm(t, e, n, i)
    } finally {
        nt = r,
        yo.transition = s
    }
}
function CT(t, e, n, i) {
    var r = nt
      , s = yo.transition;
    yo.transition = null;
    try {
        nt = 4,
        pm(t, e, n, i)
    } finally {
        nt = r,
        yo.transition = s
    }
}
function pm(t, e, n, i) {
    if (nu) {
        var r = nf(t, e, n, i);
        if (r === null)
            Ed(t, e, i, iu, n),
            r0(t, i);
        else if (TT(r, t, e, n, i))
            i.stopPropagation();
        else if (r0(t, i),
        e & 4 && -1 < ET.indexOf(t)) {
            for (; r !== null; ) {
                var s = ml(r);
                if (s !== null && gx(s),
                s = nf(t, e, n, i),
                s === null && Ed(t, e, i, iu, n),
                s === r)
                    break;
                r = s
            }
            r !== null && i.stopPropagation()
        } else
            Ed(t, e, i, null, n)
    }
}
var iu = null;
function nf(t, e, n, i) {
    if (iu = null,
    t = um(i),
    t = os(t),
    t !== null)
        if (e = Ts(t),
        e === null)
            t = null;
        else if (n = e.tag,
        n === 13) {
            if (t = lx(e),
            t !== null)
                return t;
            t = null
        } else if (n === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            t = null
        } else
            e !== t && (t = null);
    return iu = t,
    null
}
function Sx(t) {
    switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (mT()) {
        case dm:
            return 1;
        case hx:
            return 4;
        case eu:
        case gT:
            return 16;
        case fx:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var vr = null
  , mm = null
  , Dc = null;
function wx() {
    if (Dc)
        return Dc;
    var t, e = mm, n = e.length, i, r = "value"in vr ? vr.value : vr.textContent, s = r.length;
    for (t = 0; t < n && e[t] === r[t]; t++)
        ;
    var o = n - t;
    for (i = 1; i <= o && e[n - i] === r[s - i]; i++)
        ;
    return Dc = r.slice(t, 1 < i ? 1 - i : void 0)
}
function Lc(t) {
    var e = t.keyCode;
    return "charCode"in t ? (t = t.charCode,
    t === 0 && e === 13 && (t = 13)) : t = e,
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
}
function zl() {
    return !0
}
function o0() {
    return !1
}
function Ln(t) {
    function e(n, i, r, s, o) {
        this._reactName = n,
        this._targetInst = r,
        this.type = i,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in t)
            t.hasOwnProperty(a) && (n = t[a],
            this[a] = n ? n(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? zl : o0,
        this.isPropagationStopped = o0,
        this
    }
    return wt(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1),
            this.isDefaultPrevented = zl)
        },
        stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
            this.isPropagationStopped = zl)
        },
        persist: function() {},
        isPersistent: zl
    }),
    e
}
var Vo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(t) {
        return t.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, gm = Ln(Vo), pl = wt({}, Vo, {
    view: 0,
    detail: 0
}), RT = Ln(pl), md, gd, ta, ku = wt({}, pl, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: vm,
    button: 0,
    buttons: 0,
    relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
    },
    movementX: function(t) {
        return "movementX"in t ? t.movementX : (t !== ta && (ta && t.type === "mousemove" ? (md = t.screenX - ta.screenX,
        gd = t.screenY - ta.screenY) : gd = md = 0,
        ta = t),
        md)
    },
    movementY: function(t) {
        return "movementY"in t ? t.movementY : gd
    }
}), a0 = Ln(ku), PT = wt({}, ku, {
    dataTransfer: 0
}), NT = Ln(PT), DT = wt({}, pl, {
    relatedTarget: 0
}), vd = Ln(DT), LT = wt({}, Vo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), IT = Ln(LT), kT = wt({}, Vo, {
    clipboardData: function(t) {
        return "clipboardData"in t ? t.clipboardData : window.clipboardData
    }
}), UT = Ln(kT), OT = wt({}, Vo, {
    data: 0
}), l0 = Ln(OT), FT = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, BT = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, zT = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function VT(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = zT[t]) ? !!e[t] : !1
}
function vm() {
    return VT
}
var jT = wt({}, pl, {
    key: function(t) {
        if (t.key) {
            var e = FT[t.key] || t.key;
            if (e !== "Unidentified")
                return e
        }
        return t.type === "keypress" ? (t = Lc(t),
        t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? BT[t.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: vm,
    charCode: function(t) {
        return t.type === "keypress" ? Lc(t) : 0
    },
    keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    },
    which: function(t) {
        return t.type === "keypress" ? Lc(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    }
})
  , HT = Ln(jT)
  , GT = wt({}, ku, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , c0 = Ln(GT)
  , WT = wt({}, pl, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: vm
})
  , $T = Ln(WT)
  , XT = wt({}, Vo, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , qT = Ln(XT)
  , KT = wt({}, ku, {
    deltaX: function(t) {
        return "deltaX"in t ? t.deltaX : "wheelDeltaX"in t ? -t.wheelDeltaX : 0
    },
    deltaY: function(t) {
        return "deltaY"in t ? t.deltaY : "wheelDeltaY"in t ? -t.wheelDeltaY : "wheelDelta"in t ? -t.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , YT = Ln(KT)
  , ZT = [9, 13, 27, 32]
  , _m = Gi && "CompositionEvent"in window
  , wa = null;
Gi && "documentMode"in document && (wa = document.documentMode);
var JT = Gi && "TextEvent"in window && !wa
  , bx = Gi && (!_m || wa && 8 < wa && 11 >= wa)
  , u0 = " "
  , d0 = !1;
function Ex(t, e) {
    switch (t) {
    case "keyup":
        return ZT.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function Tx(t) {
    return t = t.detail,
    typeof t == "object" && "data"in t ? t.data : null
}
var Qs = !1;
function QT(t, e) {
    switch (t) {
    case "compositionend":
        return Tx(e);
    case "keypress":
        return e.which !== 32 ? null : (d0 = !0,
        u0);
    case "textInput":
        return t = e.data,
        t === u0 && d0 ? null : t;
    default:
        return null
    }
}
function eM(t, e) {
    if (Qs)
        return t === "compositionend" || !_m && Ex(t, e) ? (t = wx(),
        Dc = mm = vr = null,
        Qs = !1,
        t) : null;
    switch (t) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return bx && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var tM = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function h0(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!tM[t.type] : e === "textarea"
}
function Mx(t, e, n, i) {
    ix(i),
    e = ru(e, "onChange"),
    0 < e.length && (n = new gm("onChange","change",null,n,i),
    t.push({
        event: n,
        listeners: e
    }))
}
var ba = null
  , Ha = null;
function nM(t) {
    Ox(t, 0)
}
function Uu(t) {
    var e = no(t);
    if (Yy(e))
        return t
}
function iM(t, e) {
    if (t === "change")
        return e
}
var Ax = !1;
if (Gi) {
    var _d;
    if (Gi) {
        var yd = "oninput"in document;
        if (!yd) {
            var f0 = document.createElement("div");
            f0.setAttribute("oninput", "return;"),
            yd = typeof f0.oninput == "function"
        }
        _d = yd
    } else
        _d = !1;
    Ax = _d && (!document.documentMode || 9 < document.documentMode)
}
function p0() {
    ba && (ba.detachEvent("onpropertychange", Cx),
    Ha = ba = null)
}
function Cx(t) {
    if (t.propertyName === "value" && Uu(Ha)) {
        var e = [];
        Mx(e, Ha, t, um(t)),
        ax(nM, e)
    }
}
function rM(t, e, n) {
    t === "focusin" ? (p0(),
    ba = e,
    Ha = n,
    ba.attachEvent("onpropertychange", Cx)) : t === "focusout" && p0()
}
function sM(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return Uu(Ha)
}
function oM(t, e) {
    if (t === "click")
        return Uu(e)
}
function aM(t, e) {
    if (t === "input" || t === "change")
        return Uu(e)
}
function lM(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var di = typeof Object.is == "function" ? Object.is : lM;
function Ga(t, e) {
    if (di(t, e))
        return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null)
        return !1;
    var n = Object.keys(t)
      , i = Object.keys(e);
    if (n.length !== i.length)
        return !1;
    for (i = 0; i < n.length; i++) {
        var r = n[i];
        if (!Fh.call(e, r) || !di(t[r], e[r]))
            return !1
    }
    return !0
}
function m0(t) {
    for (; t && t.firstChild; )
        t = t.firstChild;
    return t
}
function g0(t, e) {
    var n = m0(t);
    t = 0;
    for (var i; n; ) {
        if (n.nodeType === 3) {
            if (i = t + n.textContent.length,
            t <= e && i >= e)
                return {
                    node: n,
                    offset: e - t
                };
            t = i
        }
        e: {
            for (; n; ) {
                if (n.nextSibling) {
                    n = n.nextSibling;
                    break e
                }
                n = n.parentNode
            }
            n = void 0
        }
        n = m0(n)
    }
}
function Rx(t, e) {
    return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Rx(t, e.parentNode) : "contains"in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}
function Px() {
    for (var t = window, e = Zc(); e instanceof t.HTMLIFrameElement; ) {
        try {
            var n = typeof e.contentWindow.location.href == "string"
        } catch {
            n = !1
        }
        if (n)
            t = e.contentWindow;
        else
            break;
        e = Zc(t.document)
    }
    return e
}
function ym(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}
function cM(t) {
    var e = Px()
      , n = t.focusedElem
      , i = t.selectionRange;
    if (e !== n && n && n.ownerDocument && Rx(n.ownerDocument.documentElement, n)) {
        if (i !== null && ym(n)) {
            if (e = i.start,
            t = i.end,
            t === void 0 && (t = e),
            "selectionStart"in n)
                n.selectionStart = e,
                n.selectionEnd = Math.min(t, n.value.length);
            else if (t = (e = n.ownerDocument || document) && e.defaultView || window,
            t.getSelection) {
                t = t.getSelection();
                var r = n.textContent.length
                  , s = Math.min(i.start, r);
                i = i.end === void 0 ? s : Math.min(i.end, r),
                !t.extend && s > i && (r = i,
                i = s,
                s = r),
                r = g0(n, s);
                var o = g0(n, i);
                r && o && (t.rangeCount !== 1 || t.anchorNode !== r.node || t.anchorOffset !== r.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(r.node, r.offset),
                t.removeAllRanges(),
                s > i ? (t.addRange(e),
                t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                t.addRange(e)))
            }
        }
        for (e = [],
        t = n; t = t.parentNode; )
            t.nodeType === 1 && e.push({
                element: t,
                left: t.scrollLeft,
                top: t.scrollTop
            });
        for (typeof n.focus == "function" && n.focus(),
        n = 0; n < e.length; n++)
            t = e[n],
            t.element.scrollLeft = t.left,
            t.element.scrollTop = t.top
    }
}
var uM = Gi && "documentMode"in document && 11 >= document.documentMode
  , eo = null
  , rf = null
  , Ea = null
  , sf = !1;
function v0(t, e, n) {
    var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    sf || eo == null || eo !== Zc(i) || (i = eo,
    "selectionStart"in i && ym(i) ? i = {
        start: i.selectionStart,
        end: i.selectionEnd
    } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(),
    i = {
        anchorNode: i.anchorNode,
        anchorOffset: i.anchorOffset,
        focusNode: i.focusNode,
        focusOffset: i.focusOffset
    }),
    Ea && Ga(Ea, i) || (Ea = i,
    i = ru(rf, "onSelect"),
    0 < i.length && (e = new gm("onSelect","select",null,e,n),
    t.push({
        event: e,
        listeners: i
    }),
    e.target = eo)))
}
function Vl(t, e) {
    var n = {};
    return n[t.toLowerCase()] = e.toLowerCase(),
    n["Webkit" + t] = "webkit" + e,
    n["Moz" + t] = "moz" + e,
    n
}
var to = {
    animationend: Vl("Animation", "AnimationEnd"),
    animationiteration: Vl("Animation", "AnimationIteration"),
    animationstart: Vl("Animation", "AnimationStart"),
    transitionend: Vl("Transition", "TransitionEnd")
}
  , xd = {}
  , Nx = {};
Gi && (Nx = document.createElement("div").style,
"AnimationEvent"in window || (delete to.animationend.animation,
delete to.animationiteration.animation,
delete to.animationstart.animation),
"TransitionEvent"in window || delete to.transitionend.transition);
function Ou(t) {
    if (xd[t])
        return xd[t];
    if (!to[t])
        return t;
    var e = to[t], n;
    for (n in e)
        if (e.hasOwnProperty(n) && n in Nx)
            return xd[t] = e[n];
    return t
}
var Dx = Ou("animationend")
  , Lx = Ou("animationiteration")
  , Ix = Ou("animationstart")
  , kx = Ou("transitionend")
  , Ux = new Map
  , _0 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function kr(t, e) {
    Ux.set(t, e),
    Es(e, [t])
}
for (var Sd = 0; Sd < _0.length; Sd++) {
    var wd = _0[Sd]
      , dM = wd.toLowerCase()
      , hM = wd[0].toUpperCase() + wd.slice(1);
    kr(dM, "on" + hM)
}
kr(Dx, "onAnimationEnd");
kr(Lx, "onAnimationIteration");
kr(Ix, "onAnimationStart");
kr("dblclick", "onDoubleClick");
kr("focusin", "onFocus");
kr("focusout", "onBlur");
kr(kx, "onTransitionEnd");
To("onMouseEnter", ["mouseout", "mouseover"]);
To("onMouseLeave", ["mouseout", "mouseover"]);
To("onPointerEnter", ["pointerout", "pointerover"]);
To("onPointerLeave", ["pointerout", "pointerover"]);
Es("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Es("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Es("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Es("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Es("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Es("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ga = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , fM = new Set("cancel close invalid load scroll toggle".split(" ").concat(ga));
function y0(t, e, n) {
    var i = t.type || "unknown-event";
    t.currentTarget = n,
    dT(i, e, void 0, t),
    t.currentTarget = null
}
function Ox(t, e) {
    e = (e & 4) !== 0;
    for (var n = 0; n < t.length; n++) {
        var i = t[n]
          , r = i.event;
        i = i.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = i.length - 1; 0 <= o; o--) {
                    var a = i[o]
                      , l = a.instance
                      , c = a.currentTarget;
                    if (a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    y0(r, a, c),
                    s = l
                }
            else
                for (o = 0; o < i.length; o++) {
                    if (a = i[o],
                    l = a.instance,
                    c = a.currentTarget,
                    a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    y0(r, a, c),
                    s = l
                }
        }
    }
    if (Qc)
        throw t = Qh,
        Qc = !1,
        Qh = null,
        t
}
function dt(t, e) {
    var n = e[uf];
    n === void 0 && (n = e[uf] = new Set);
    var i = t + "__bubble";
    n.has(i) || (Fx(e, t, 2, !1),
    n.add(i))
}
function bd(t, e, n) {
    var i = 0;
    e && (i |= 4),
    Fx(n, t, i, e)
}
var jl = "_reactListening" + Math.random().toString(36).slice(2);
function Wa(t) {
    if (!t[jl]) {
        t[jl] = !0,
        Wy.forEach(function(n) {
            n !== "selectionchange" && (fM.has(n) || bd(n, !1, t),
            bd(n, !0, t))
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[jl] || (e[jl] = !0,
        bd("selectionchange", !1, e))
    }
}
function Fx(t, e, n, i) {
    switch (Sx(e)) {
    case 1:
        var r = AT;
        break;
    case 4:
        r = CT;
        break;
    default:
        r = pm
    }
    n = r.bind(null, e, n, t),
    r = void 0,
    !Jh || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0),
    i ? r !== void 0 ? t.addEventListener(e, n, {
        capture: !0,
        passive: r
    }) : t.addEventListener(e, n, !0) : r !== void 0 ? t.addEventListener(e, n, {
        passive: r
    }) : t.addEventListener(e, n, !1)
}
function Ed(t, e, n, i, r) {
    var s = i;
    if (!(e & 1) && !(e & 2) && i !== null)
        e: for (; ; ) {
            if (i === null)
                return;
            var o = i.tag;
            if (o === 3 || o === 4) {
                var a = i.stateNode.containerInfo;
                if (a === r || a.nodeType === 8 && a.parentNode === r)
                    break;
                if (o === 4)
                    for (o = i.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === r || l.nodeType === 8 && l.parentNode === r))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = os(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        i = s = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            i = i.return
        }
    ax(function() {
        var c = s
          , u = um(n)
          , d = [];
        e: {
            var h = Ux.get(t);
            if (h !== void 0) {
                var p = gm
                  , v = t;
                switch (t) {
                case "keypress":
                    if (Lc(n) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    p = HT;
                    break;
                case "focusin":
                    v = "focus",
                    p = vd;
                    break;
                case "focusout":
                    v = "blur",
                    p = vd;
                    break;
                case "beforeblur":
                case "afterblur":
                    p = vd;
                    break;
                case "click":
                    if (n.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    p = a0;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    p = NT;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    p = $T;
                    break;
                case Dx:
                case Lx:
                case Ix:
                    p = IT;
                    break;
                case kx:
                    p = qT;
                    break;
                case "scroll":
                    p = RT;
                    break;
                case "wheel":
                    p = YT;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    p = UT;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    p = c0
                }
                var x = (e & 4) !== 0
                  , g = !x && t === "scroll"
                  , f = x ? h !== null ? h + "Capture" : null : h;
                x = [];
                for (var y = c, _; y !== null; ) {
                    _ = y;
                    var S = _.stateNode;
                    if (_.tag === 5 && S !== null && (_ = S,
                    f !== null && (S = Ba(y, f),
                    S != null && x.push($a(y, S, _)))),
                    g)
                        break;
                    y = y.return
                }
                0 < x.length && (h = new p(h,v,null,n,u),
                d.push({
                    event: h,
                    listeners: x
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (h = t === "mouseover" || t === "pointerover",
                p = t === "mouseout" || t === "pointerout",
                h && n !== Yh && (v = n.relatedTarget || n.fromElement) && (os(v) || v[Wi]))
                    break e;
                if ((p || h) && (h = u.window === u ? u : (h = u.ownerDocument) ? h.defaultView || h.parentWindow : window,
                p ? (v = n.relatedTarget || n.toElement,
                p = c,
                v = v ? os(v) : null,
                v !== null && (g = Ts(v),
                v !== g || v.tag !== 5 && v.tag !== 6) && (v = null)) : (p = null,
                v = c),
                p !== v)) {
                    if (x = a0,
                    S = "onMouseLeave",
                    f = "onMouseEnter",
                    y = "mouse",
                    (t === "pointerout" || t === "pointerover") && (x = c0,
                    S = "onPointerLeave",
                    f = "onPointerEnter",
                    y = "pointer"),
                    g = p == null ? h : no(p),
                    _ = v == null ? h : no(v),
                    h = new x(S,y + "leave",p,n,u),
                    h.target = g,
                    h.relatedTarget = _,
                    S = null,
                    os(u) === c && (x = new x(f,y + "enter",v,n,u),
                    x.target = _,
                    x.relatedTarget = g,
                    S = x),
                    g = S,
                    p && v)
                        t: {
                            for (x = p,
                            f = v,
                            y = 0,
                            _ = x; _; _ = Cs(_))
                                y++;
                            for (_ = 0,
                            S = f; S; S = Cs(S))
                                _++;
                            for (; 0 < y - _; )
                                x = Cs(x),
                                y--;
                            for (; 0 < _ - y; )
                                f = Cs(f),
                                _--;
                            for (; y--; ) {
                                if (x === f || f !== null && x === f.alternate)
                                    break t;
                                x = Cs(x),
                                f = Cs(f)
                            }
                            x = null
                        }
                    else
                        x = null;
                    p !== null && x0(d, h, p, x, !1),
                    v !== null && g !== null && x0(d, g, v, x, !0)
                }
            }
            e: {
                if (h = c ? no(c) : window,
                p = h.nodeName && h.nodeName.toLowerCase(),
                p === "select" || p === "input" && h.type === "file")
                    var T = iM;
                else if (h0(h))
                    if (Ax)
                        T = aM;
                    else {
                        T = sM;
                        var A = rM
                    }
                else
                    (p = h.nodeName) && p.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (T = oM);
                if (T && (T = T(t, c))) {
                    Mx(d, T, n, u);
                    break e
                }
                A && A(t, h, c),
                t === "focusout" && (A = h._wrapperState) && A.controlled && h.type === "number" && Wh(h, "number", h.value)
            }
            switch (A = c ? no(c) : window,
            t) {
            case "focusin":
                (h0(A) || A.contentEditable === "true") && (eo = A,
                rf = c,
                Ea = null);
                break;
            case "focusout":
                Ea = rf = eo = null;
                break;
            case "mousedown":
                sf = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                sf = !1,
                v0(d, n, u);
                break;
            case "selectionchange":
                if (uM)
                    break;
            case "keydown":
            case "keyup":
                v0(d, n, u)
            }
            var C;
            if (_m)
                e: {
                    switch (t) {
                    case "compositionstart":
                        var P = "onCompositionStart";
                        break e;
                    case "compositionend":
                        P = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        P = "onCompositionUpdate";
                        break e
                    }
                    P = void 0
                }
            else
                Qs ? Ex(t, n) && (P = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (P = "onCompositionStart");
            P && (bx && n.locale !== "ko" && (Qs || P !== "onCompositionStart" ? P === "onCompositionEnd" && Qs && (C = wx()) : (vr = u,
            mm = "value"in vr ? vr.value : vr.textContent,
            Qs = !0)),
            A = ru(c, P),
            0 < A.length && (P = new l0(P,t,null,n,u),
            d.push({
                event: P,
                listeners: A
            }),
            C ? P.data = C : (C = Tx(n),
            C !== null && (P.data = C)))),
            (C = JT ? QT(t, n) : eM(t, n)) && (c = ru(c, "onBeforeInput"),
            0 < c.length && (u = new l0("onBeforeInput","beforeinput",null,n,u),
            d.push({
                event: u,
                listeners: c
            }),
            u.data = C))
        }
        Ox(d, e)
    })
}
function $a(t, e, n) {
    return {
        instance: t,
        listener: e,
        currentTarget: n
    }
}
function ru(t, e) {
    for (var n = e + "Capture", i = []; t !== null; ) {
        var r = t
          , s = r.stateNode;
        r.tag === 5 && s !== null && (r = s,
        s = Ba(t, n),
        s != null && i.unshift($a(t, s, r)),
        s = Ba(t, e),
        s != null && i.push($a(t, s, r))),
        t = t.return
    }
    return i
}
function Cs(t) {
    if (t === null)
        return null;
    do
        t = t.return;
    while (t && t.tag !== 5);
    return t || null
}
function x0(t, e, n, i, r) {
    for (var s = e._reactName, o = []; n !== null && n !== i; ) {
        var a = n
          , l = a.alternate
          , c = a.stateNode;
        if (l !== null && l === i)
            break;
        a.tag === 5 && c !== null && (a = c,
        r ? (l = Ba(n, s),
        l != null && o.unshift($a(n, l, a))) : r || (l = Ba(n, s),
        l != null && o.push($a(n, l, a)))),
        n = n.return
    }
    o.length !== 0 && t.push({
        event: e,
        listeners: o
    })
}
var pM = /\r\n?/g
  , mM = /\u0000|\uFFFD/g;
function S0(t) {
    return (typeof t == "string" ? t : "" + t).replace(pM, `
`).replace(mM, "")
}
function Hl(t, e, n) {
    if (e = S0(e),
    S0(t) !== e && n)
        throw Error(te(425))
}
function su() {}
var of = null
  , af = null;
function lf(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var cf = typeof setTimeout == "function" ? setTimeout : void 0
  , gM = typeof clearTimeout == "function" ? clearTimeout : void 0
  , w0 = typeof Promise == "function" ? Promise : void 0
  , vM = typeof queueMicrotask == "function" ? queueMicrotask : typeof w0 < "u" ? function(t) {
    return w0.resolve(null).then(t).catch(_M)
}
: cf;
function _M(t) {
    setTimeout(function() {
        throw t
    })
}
function Td(t, e) {
    var n = e
      , i = 0;
    do {
        var r = n.nextSibling;
        if (t.removeChild(n),
        r && r.nodeType === 8)
            if (n = r.data,
            n === "/$") {
                if (i === 0) {
                    t.removeChild(r),
                    ja(e);
                    return
                }
                i--
            } else
                n !== "$" && n !== "$?" && n !== "$!" || i++;
        n = r
    } while (n);
    ja(e)
}
function wr(t) {
    for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = t.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return t
}
function b0(t) {
    t = t.previousSibling;
    for (var e = 0; t; ) {
        if (t.nodeType === 8) {
            var n = t.data;
            if (n === "$" || n === "$!" || n === "$?") {
                if (e === 0)
                    return t;
                e--
            } else
                n === "/$" && e++
        }
        t = t.previousSibling
    }
    return null
}
var jo = Math.random().toString(36).slice(2)
  , vi = "__reactFiber$" + jo
  , Xa = "__reactProps$" + jo
  , Wi = "__reactContainer$" + jo
  , uf = "__reactEvents$" + jo
  , yM = "__reactListeners$" + jo
  , xM = "__reactHandles$" + jo;
function os(t) {
    var e = t[vi];
    if (e)
        return e;
    for (var n = t.parentNode; n; ) {
        if (e = n[Wi] || n[vi]) {
            if (n = e.alternate,
            e.child !== null || n !== null && n.child !== null)
                for (t = b0(t); t !== null; ) {
                    if (n = t[vi])
                        return n;
                    t = b0(t)
                }
            return e
        }
        t = n,
        n = t.parentNode
    }
    return null
}
function ml(t) {
    return t = t[vi] || t[Wi],
    !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}
function no(t) {
    if (t.tag === 5 || t.tag === 6)
        return t.stateNode;
    throw Error(te(33))
}
function Fu(t) {
    return t[Xa] || null
}
var df = []
  , io = -1;
function Ur(t) {
    return {
        current: t
    }
}
function ht(t) {
    0 > io || (t.current = df[io],
    df[io] = null,
    io--)
}
function ct(t, e) {
    io++,
    df[io] = t.current,
    t.current = e
}
var Pr = {}
  , nn = Ur(Pr)
  , _n = Ur(!1)
  , vs = Pr;
function Mo(t, e) {
    var n = t.type.contextTypes;
    if (!n)
        return Pr;
    var i = t.stateNode;
    if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
        return i.__reactInternalMemoizedMaskedChildContext;
    var r = {}, s;
    for (s in n)
        r[s] = e[s];
    return i && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = e,
    t.__reactInternalMemoizedMaskedChildContext = r),
    r
}
function yn(t) {
    return t = t.childContextTypes,
    t != null
}
function ou() {
    ht(_n),
    ht(nn)
}
function E0(t, e, n) {
    if (nn.current !== Pr)
        throw Error(te(168));
    ct(nn, e),
    ct(_n, n)
}
function Bx(t, e, n) {
    var i = t.stateNode;
    if (e = e.childContextTypes,
    typeof i.getChildContext != "function")
        return n;
    i = i.getChildContext();
    for (var r in i)
        if (!(r in e))
            throw Error(te(108, rT(t) || "Unknown", r));
    return wt({}, n, i)
}
function au(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Pr,
    vs = nn.current,
    ct(nn, t),
    ct(_n, _n.current),
    !0
}
function T0(t, e, n) {
    var i = t.stateNode;
    if (!i)
        throw Error(te(169));
    n ? (t = Bx(t, e, vs),
    i.__reactInternalMemoizedMergedChildContext = t,
    ht(_n),
    ht(nn),
    ct(nn, t)) : ht(_n),
    ct(_n, n)
}
var ki = null
  , Bu = !1
  , Md = !1;
function zx(t) {
    ki === null ? ki = [t] : ki.push(t)
}
function SM(t) {
    Bu = !0,
    zx(t)
}
function Or() {
    if (!Md && ki !== null) {
        Md = !0;
        var t = 0
          , e = nt;
        try {
            var n = ki;
            for (nt = 1; t < n.length; t++) {
                var i = n[t];
                do
                    i = i(!0);
                while (i !== null)
            }
            ki = null,
            Bu = !1
        } catch (r) {
            throw ki !== null && (ki = ki.slice(t + 1)),
            dx(dm, Or),
            r
        } finally {
            nt = e,
            Md = !1
        }
    }
    return null
}
var ro = []
  , so = 0
  , lu = null
  , cu = 0
  , zn = []
  , Vn = 0
  , _s = null
  , Oi = 1
  , Fi = "";
function Zr(t, e) {
    ro[so++] = cu,
    ro[so++] = lu,
    lu = t,
    cu = e
}
function Vx(t, e, n) {
    zn[Vn++] = Oi,
    zn[Vn++] = Fi,
    zn[Vn++] = _s,
    _s = t;
    var i = Oi;
    t = Fi;
    var r = 32 - li(i) - 1;
    i &= ~(1 << r),
    n += 1;
    var s = 32 - li(e) + r;
    if (30 < s) {
        var o = r - r % 5;
        s = (i & (1 << o) - 1).toString(32),
        i >>= o,
        r -= o,
        Oi = 1 << 32 - li(e) + r | n << r | i,
        Fi = s + t
    } else
        Oi = 1 << s | n << r | i,
        Fi = t
}
function xm(t) {
    t.return !== null && (Zr(t, 1),
    Vx(t, 1, 0))
}
function Sm(t) {
    for (; t === lu; )
        lu = ro[--so],
        ro[so] = null,
        cu = ro[--so],
        ro[so] = null;
    for (; t === _s; )
        _s = zn[--Vn],
        zn[Vn] = null,
        Fi = zn[--Vn],
        zn[Vn] = null,
        Oi = zn[--Vn],
        zn[Vn] = null
}
var Pn = null
  , Rn = null
  , mt = !1
  , si = null;
function jx(t, e) {
    var n = Hn(5, null, null, 0);
    n.elementType = "DELETED",
    n.stateNode = e,
    n.return = t,
    e = t.deletions,
    e === null ? (t.deletions = [n],
    t.flags |= 16) : e.push(n)
}
function M0(t, e) {
    switch (t.tag) {
    case 5:
        var n = t.type;
        return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (t.stateNode = e,
        Pn = t,
        Rn = wr(e.firstChild),
        !0) : !1;
    case 6:
        return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (t.stateNode = e,
        Pn = t,
        Rn = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (n = _s !== null ? {
            id: Oi,
            overflow: Fi
        } : null,
        t.memoizedState = {
            dehydrated: e,
            treeContext: n,
            retryLane: 1073741824
        },
        n = Hn(18, null, null, 0),
        n.stateNode = e,
        n.return = t,
        t.child = n,
        Pn = t,
        Rn = null,
        !0) : !1;
    default:
        return !1
    }
}
function hf(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}
function ff(t) {
    if (mt) {
        var e = Rn;
        if (e) {
            var n = e;
            if (!M0(t, e)) {
                if (hf(t))
                    throw Error(te(418));
                e = wr(n.nextSibling);
                var i = Pn;
                e && M0(t, e) ? jx(i, n) : (t.flags = t.flags & -4097 | 2,
                mt = !1,
                Pn = t)
            }
        } else {
            if (hf(t))
                throw Error(te(418));
            t.flags = t.flags & -4097 | 2,
            mt = !1,
            Pn = t
        }
    }
}
function A0(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
        t = t.return;
    Pn = t
}
function Gl(t) {
    if (t !== Pn)
        return !1;
    if (!mt)
        return A0(t),
        mt = !0,
        !1;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type,
    e = e !== "head" && e !== "body" && !lf(t.type, t.memoizedProps)),
    e && (e = Rn)) {
        if (hf(t))
            throw Hx(),
            Error(te(418));
        for (; e; )
            jx(t, e),
            e = wr(e.nextSibling)
    }
    if (A0(t),
    t.tag === 13) {
        if (t = t.memoizedState,
        t = t !== null ? t.dehydrated : null,
        !t)
            throw Error(te(317));
        e: {
            for (t = t.nextSibling,
            e = 0; t; ) {
                if (t.nodeType === 8) {
                    var n = t.data;
                    if (n === "/$") {
                        if (e === 0) {
                            Rn = wr(t.nextSibling);
                            break e
                        }
                        e--
                    } else
                        n !== "$" && n !== "$!" && n !== "$?" || e++
                }
                t = t.nextSibling
            }
            Rn = null
        }
    } else
        Rn = Pn ? wr(t.stateNode.nextSibling) : null;
    return !0
}
function Hx() {
    for (var t = Rn; t; )
        t = wr(t.nextSibling)
}
function Ao() {
    Rn = Pn = null,
    mt = !1
}
function wm(t) {
    si === null ? si = [t] : si.push(t)
}
var wM = Ji.ReactCurrentBatchConfig;
function na(t, e, n) {
    if (t = n.ref,
    t !== null && typeof t != "function" && typeof t != "object") {
        if (n._owner) {
            if (n = n._owner,
            n) {
                if (n.tag !== 1)
                    throw Error(te(309));
                var i = n.stateNode
            }
            if (!i)
                throw Error(te(147, t));
            var r = i
              , s = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = r.refs;
                o === null ? delete a[s] : a[s] = o
            }
            ,
            e._stringRef = s,
            e)
        }
        if (typeof t != "string")
            throw Error(te(284));
        if (!n._owner)
            throw Error(te(290, t))
    }
    return t
}
function Wl(t, e) {
    throw t = Object.prototype.toString.call(e),
    Error(te(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}
function C0(t) {
    var e = t._init;
    return e(t._payload)
}
function Gx(t) {
    function e(f, y) {
        if (t) {
            var _ = f.deletions;
            _ === null ? (f.deletions = [y],
            f.flags |= 16) : _.push(y)
        }
    }
    function n(f, y) {
        if (!t)
            return null;
        for (; y !== null; )
            e(f, y),
            y = y.sibling;
        return null
    }
    function i(f, y) {
        for (f = new Map; y !== null; )
            y.key !== null ? f.set(y.key, y) : f.set(y.index, y),
            y = y.sibling;
        return f
    }
    function r(f, y) {
        return f = Mr(f, y),
        f.index = 0,
        f.sibling = null,
        f
    }
    function s(f, y, _) {
        return f.index = _,
        t ? (_ = f.alternate,
        _ !== null ? (_ = _.index,
        _ < y ? (f.flags |= 2,
        y) : _) : (f.flags |= 2,
        y)) : (f.flags |= 1048576,
        y)
    }
    function o(f) {
        return t && f.alternate === null && (f.flags |= 2),
        f
    }
    function a(f, y, _, S) {
        return y === null || y.tag !== 6 ? (y = Ld(_, f.mode, S),
        y.return = f,
        y) : (y = r(y, _),
        y.return = f,
        y)
    }
    function l(f, y, _, S) {
        var T = _.type;
        return T === Js ? u(f, y, _.props.children, S, _.key) : y !== null && (y.elementType === T || typeof T == "object" && T !== null && T.$$typeof === dr && C0(T) === y.type) ? (S = r(y, _.props),
        S.ref = na(f, y, _),
        S.return = f,
        S) : (S = zc(_.type, _.key, _.props, null, f.mode, S),
        S.ref = na(f, y, _),
        S.return = f,
        S)
    }
    function c(f, y, _, S) {
        return y === null || y.tag !== 4 || y.stateNode.containerInfo !== _.containerInfo || y.stateNode.implementation !== _.implementation ? (y = Id(_, f.mode, S),
        y.return = f,
        y) : (y = r(y, _.children || []),
        y.return = f,
        y)
    }
    function u(f, y, _, S, T) {
        return y === null || y.tag !== 7 ? (y = ps(_, f.mode, S, T),
        y.return = f,
        y) : (y = r(y, _),
        y.return = f,
        y)
    }
    function d(f, y, _) {
        if (typeof y == "string" && y !== "" || typeof y == "number")
            return y = Ld("" + y, f.mode, _),
            y.return = f,
            y;
        if (typeof y == "object" && y !== null) {
            switch (y.$$typeof) {
            case Il:
                return _ = zc(y.type, y.key, y.props, null, f.mode, _),
                _.ref = na(f, null, y),
                _.return = f,
                _;
            case Zs:
                return y = Id(y, f.mode, _),
                y.return = f,
                y;
            case dr:
                var S = y._init;
                return d(f, S(y._payload), _)
            }
            if (pa(y) || Zo(y))
                return y = ps(y, f.mode, _, null),
                y.return = f,
                y;
            Wl(f, y)
        }
        return null
    }
    function h(f, y, _, S) {
        var T = y !== null ? y.key : null;
        if (typeof _ == "string" && _ !== "" || typeof _ == "number")
            return T !== null ? null : a(f, y, "" + _, S);
        if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
            case Il:
                return _.key === T ? l(f, y, _, S) : null;
            case Zs:
                return _.key === T ? c(f, y, _, S) : null;
            case dr:
                return T = _._init,
                h(f, y, T(_._payload), S)
            }
            if (pa(_) || Zo(_))
                return T !== null ? null : u(f, y, _, S, null);
            Wl(f, _)
        }
        return null
    }
    function p(f, y, _, S, T) {
        if (typeof S == "string" && S !== "" || typeof S == "number")
            return f = f.get(_) || null,
            a(y, f, "" + S, T);
        if (typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
            case Il:
                return f = f.get(S.key === null ? _ : S.key) || null,
                l(y, f, S, T);
            case Zs:
                return f = f.get(S.key === null ? _ : S.key) || null,
                c(y, f, S, T);
            case dr:
                var A = S._init;
                return p(f, y, _, A(S._payload), T)
            }
            if (pa(S) || Zo(S))
                return f = f.get(_) || null,
                u(y, f, S, T, null);
            Wl(y, S)
        }
        return null
    }
    function v(f, y, _, S) {
        for (var T = null, A = null, C = y, P = y = 0, M = null; C !== null && P < _.length; P++) {
            C.index > P ? (M = C,
            C = null) : M = C.sibling;
            var b = h(f, C, _[P], S);
            if (b === null) {
                C === null && (C = M);
                break
            }
            t && C && b.alternate === null && e(f, C),
            y = s(b, y, P),
            A === null ? T = b : A.sibling = b,
            A = b,
            C = M
        }
        if (P === _.length)
            return n(f, C),
            mt && Zr(f, P),
            T;
        if (C === null) {
            for (; P < _.length; P++)
                C = d(f, _[P], S),
                C !== null && (y = s(C, y, P),
                A === null ? T = C : A.sibling = C,
                A = C);
            return mt && Zr(f, P),
            T
        }
        for (C = i(f, C); P < _.length; P++)
            M = p(C, f, P, _[P], S),
            M !== null && (t && M.alternate !== null && C.delete(M.key === null ? P : M.key),
            y = s(M, y, P),
            A === null ? T = M : A.sibling = M,
            A = M);
        return t && C.forEach(function(L) {
            return e(f, L)
        }),
        mt && Zr(f, P),
        T
    }
    function x(f, y, _, S) {
        var T = Zo(_);
        if (typeof T != "function")
            throw Error(te(150));
        if (_ = T.call(_),
        _ == null)
            throw Error(te(151));
        for (var A = T = null, C = y, P = y = 0, M = null, b = _.next(); C !== null && !b.done; P++,
        b = _.next()) {
            C.index > P ? (M = C,
            C = null) : M = C.sibling;
            var L = h(f, C, b.value, S);
            if (L === null) {
                C === null && (C = M);
                break
            }
            t && C && L.alternate === null && e(f, C),
            y = s(L, y, P),
            A === null ? T = L : A.sibling = L,
            A = L,
            C = M
        }
        if (b.done)
            return n(f, C),
            mt && Zr(f, P),
            T;
        if (C === null) {
            for (; !b.done; P++,
            b = _.next())
                b = d(f, b.value, S),
                b !== null && (y = s(b, y, P),
                A === null ? T = b : A.sibling = b,
                A = b);
            return mt && Zr(f, P),
            T
        }
        for (C = i(f, C); !b.done; P++,
        b = _.next())
            b = p(C, f, P, b.value, S),
            b !== null && (t && b.alternate !== null && C.delete(b.key === null ? P : b.key),
            y = s(b, y, P),
            A === null ? T = b : A.sibling = b,
            A = b);
        return t && C.forEach(function(F) {
            return e(f, F)
        }),
        mt && Zr(f, P),
        T
    }
    function g(f, y, _, S) {
        if (typeof _ == "object" && _ !== null && _.type === Js && _.key === null && (_ = _.props.children),
        typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
            case Il:
                e: {
                    for (var T = _.key, A = y; A !== null; ) {
                        if (A.key === T) {
                            if (T = _.type,
                            T === Js) {
                                if (A.tag === 7) {
                                    n(f, A.sibling),
                                    y = r(A, _.props.children),
                                    y.return = f,
                                    f = y;
                                    break e
                                }
                            } else if (A.elementType === T || typeof T == "object" && T !== null && T.$$typeof === dr && C0(T) === A.type) {
                                n(f, A.sibling),
                                y = r(A, _.props),
                                y.ref = na(f, A, _),
                                y.return = f,
                                f = y;
                                break e
                            }
                            n(f, A);
                            break
                        } else
                            e(f, A);
                        A = A.sibling
                    }
                    _.type === Js ? (y = ps(_.props.children, f.mode, S, _.key),
                    y.return = f,
                    f = y) : (S = zc(_.type, _.key, _.props, null, f.mode, S),
                    S.ref = na(f, y, _),
                    S.return = f,
                    f = S)
                }
                return o(f);
            case Zs:
                e: {
                    for (A = _.key; y !== null; ) {
                        if (y.key === A)
                            if (y.tag === 4 && y.stateNode.containerInfo === _.containerInfo && y.stateNode.implementation === _.implementation) {
                                n(f, y.sibling),
                                y = r(y, _.children || []),
                                y.return = f,
                                f = y;
                                break e
                            } else {
                                n(f, y);
                                break
                            }
                        else
                            e(f, y);
                        y = y.sibling
                    }
                    y = Id(_, f.mode, S),
                    y.return = f,
                    f = y
                }
                return o(f);
            case dr:
                return A = _._init,
                g(f, y, A(_._payload), S)
            }
            if (pa(_))
                return v(f, y, _, S);
            if (Zo(_))
                return x(f, y, _, S);
            Wl(f, _)
        }
        return typeof _ == "string" && _ !== "" || typeof _ == "number" ? (_ = "" + _,
        y !== null && y.tag === 6 ? (n(f, y.sibling),
        y = r(y, _),
        y.return = f,
        f = y) : (n(f, y),
        y = Ld(_, f.mode, S),
        y.return = f,
        f = y),
        o(f)) : n(f, y)
    }
    return g
}
var Co = Gx(!0)
  , Wx = Gx(!1)
  , uu = Ur(null)
  , du = null
  , oo = null
  , bm = null;
function Em() {
    bm = oo = du = null
}
function Tm(t) {
    var e = uu.current;
    ht(uu),
    t._currentValue = e
}
function pf(t, e, n) {
    for (; t !== null; ) {
        var i = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e,
        i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
        t === n)
            break;
        t = t.return
    }
}
function xo(t, e) {
    du = t,
    bm = oo = null,
    t = t.dependencies,
    t !== null && t.firstContext !== null && (t.lanes & e && (gn = !0),
    t.firstContext = null)
}
function qn(t) {
    var e = t._currentValue;
    if (bm !== t)
        if (t = {
            context: t,
            memoizedValue: e,
            next: null
        },
        oo === null) {
            if (du === null)
                throw Error(te(308));
            oo = t,
            du.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else
            oo = oo.next = t;
    return e
}
var as = null;
function Mm(t) {
    as === null ? as = [t] : as.push(t)
}
function $x(t, e, n, i) {
    var r = e.interleaved;
    return r === null ? (n.next = n,
    Mm(e)) : (n.next = r.next,
    r.next = n),
    e.interleaved = n,
    $i(t, i)
}
function $i(t, e) {
    t.lanes |= e;
    var n = t.alternate;
    for (n !== null && (n.lanes |= e),
    n = t,
    t = t.return; t !== null; )
        t.childLanes |= e,
        n = t.alternate,
        n !== null && (n.childLanes |= e),
        n = t,
        t = t.return;
    return n.tag === 3 ? n.stateNode : null
}
var hr = !1;
function Am(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function Xx(t, e) {
    t = t.updateQueue,
    e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}
function Vi(t, e) {
    return {
        eventTime: t,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function br(t, e, n) {
    var i = t.updateQueue;
    if (i === null)
        return null;
    if (i = i.shared,
    Ze & 2) {
        var r = i.pending;
        return r === null ? e.next = e : (e.next = r.next,
        r.next = e),
        i.pending = e,
        $i(t, n)
    }
    return r = i.interleaved,
    r === null ? (e.next = e,
    Mm(i)) : (e.next = r.next,
    r.next = e),
    i.interleaved = e,
    $i(t, n)
}
function Ic(t, e, n) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (n & 4194240) !== 0)) {
        var i = e.lanes;
        i &= t.pendingLanes,
        n |= i,
        e.lanes = n,
        hm(t, n)
    }
}
function R0(t, e) {
    var n = t.updateQueue
      , i = t.alternate;
    if (i !== null && (i = i.updateQueue,
    n === i)) {
        var r = null
          , s = null;
        if (n = n.firstBaseUpdate,
        n !== null) {
            do {
                var o = {
                    eventTime: n.eventTime,
                    lane: n.lane,
                    tag: n.tag,
                    payload: n.payload,
                    callback: n.callback,
                    next: null
                };
                s === null ? r = s = o : s = s.next = o,
                n = n.next
            } while (n !== null);
            s === null ? r = s = e : s = s.next = e
        } else
            r = s = e;
        n = {
            baseState: i.baseState,
            firstBaseUpdate: r,
            lastBaseUpdate: s,
            shared: i.shared,
            effects: i.effects
        },
        t.updateQueue = n;
        return
    }
    t = n.lastBaseUpdate,
    t === null ? n.firstBaseUpdate = e : t.next = e,
    n.lastBaseUpdate = e
}
function hu(t, e, n, i) {
    var r = t.updateQueue;
    hr = !1;
    var s = r.firstBaseUpdate
      , o = r.lastBaseUpdate
      , a = r.shared.pending;
    if (a !== null) {
        r.shared.pending = null;
        var l = a
          , c = l.next;
        l.next = null,
        o === null ? s = c : o.next = c,
        o = l;
        var u = t.alternate;
        u !== null && (u = u.updateQueue,
        a = u.lastBaseUpdate,
        a !== o && (a === null ? u.firstBaseUpdate = c : a.next = c,
        u.lastBaseUpdate = l))
    }
    if (s !== null) {
        var d = r.baseState;
        o = 0,
        u = c = l = null,
        a = s;
        do {
            var h = a.lane
              , p = a.eventTime;
            if ((i & h) === h) {
                u !== null && (u = u.next = {
                    eventTime: p,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var v = t
                      , x = a;
                    switch (h = e,
                    p = n,
                    x.tag) {
                    case 1:
                        if (v = x.payload,
                        typeof v == "function") {
                            d = v.call(p, d, h);
                            break e
                        }
                        d = v;
                        break e;
                    case 3:
                        v.flags = v.flags & -65537 | 128;
                    case 0:
                        if (v = x.payload,
                        h = typeof v == "function" ? v.call(p, d, h) : v,
                        h == null)
                            break e;
                        d = wt({}, d, h);
                        break e;
                    case 2:
                        hr = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (t.flags |= 64,
                h = r.effects,
                h === null ? r.effects = [a] : h.push(a))
            } else
                p = {
                    eventTime: p,
                    lane: h,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                u === null ? (c = u = p,
                l = d) : u = u.next = p,
                o |= h;
            if (a = a.next,
            a === null) {
                if (a = r.shared.pending,
                a === null)
                    break;
                h = a,
                a = h.next,
                h.next = null,
                r.lastBaseUpdate = h,
                r.shared.pending = null
            }
        } while (!0);
        if (u === null && (l = d),
        r.baseState = l,
        r.firstBaseUpdate = c,
        r.lastBaseUpdate = u,
        e = r.shared.interleaved,
        e !== null) {
            r = e;
            do
                o |= r.lane,
                r = r.next;
            while (r !== e)
        } else
            s === null && (r.shared.lanes = 0);
        xs |= o,
        t.lanes = o,
        t.memoizedState = d
    }
}
function P0(t, e, n) {
    if (t = e.effects,
    e.effects = null,
    t !== null)
        for (e = 0; e < t.length; e++) {
            var i = t[e]
              , r = i.callback;
            if (r !== null) {
                if (i.callback = null,
                i = n,
                typeof r != "function")
                    throw Error(te(191, r));
                r.call(i)
            }
        }
}
var gl = {}
  , Si = Ur(gl)
  , qa = Ur(gl)
  , Ka = Ur(gl);
function ls(t) {
    if (t === gl)
        throw Error(te(174));
    return t
}
function Cm(t, e) {
    switch (ct(Ka, e),
    ct(qa, t),
    ct(Si, gl),
    t = e.nodeType,
    t) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : Xh(null, "");
        break;
    default:
        t = t === 8 ? e.parentNode : e,
        e = t.namespaceURI || null,
        t = t.tagName,
        e = Xh(e, t)
    }
    ht(Si),
    ct(Si, e)
}
function Ro() {
    ht(Si),
    ht(qa),
    ht(Ka)
}
function qx(t) {
    ls(Ka.current);
    var e = ls(Si.current)
      , n = Xh(e, t.type);
    e !== n && (ct(qa, t),
    ct(Si, n))
}
function Rm(t) {
    qa.current === t && (ht(Si),
    ht(qa))
}
var yt = Ur(0);
function fu(t) {
    for (var e = t; e !== null; ) {
        if (e.tag === 13) {
            var n = e.memoizedState;
            if (n !== null && (n = n.dehydrated,
            n === null || n.data === "$?" || n.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === t)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === t)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var Ad = [];
function Pm() {
    for (var t = 0; t < Ad.length; t++)
        Ad[t]._workInProgressVersionPrimary = null;
    Ad.length = 0
}
var kc = Ji.ReactCurrentDispatcher
  , Cd = Ji.ReactCurrentBatchConfig
  , ys = 0
  , St = null
  , Ot = null
  , Ht = null
  , pu = !1
  , Ta = !1
  , Ya = 0
  , bM = 0;
function Yt() {
    throw Error(te(321))
}
function Nm(t, e) {
    if (e === null)
        return !1;
    for (var n = 0; n < e.length && n < t.length; n++)
        if (!di(t[n], e[n]))
            return !1;
    return !0
}
function Dm(t, e, n, i, r, s) {
    if (ys = s,
    St = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    kc.current = t === null || t.memoizedState === null ? AM : CM,
    t = n(i, r),
    Ta) {
        s = 0;
        do {
            if (Ta = !1,
            Ya = 0,
            25 <= s)
                throw Error(te(301));
            s += 1,
            Ht = Ot = null,
            e.updateQueue = null,
            kc.current = RM,
            t = n(i, r)
        } while (Ta)
    }
    if (kc.current = mu,
    e = Ot !== null && Ot.next !== null,
    ys = 0,
    Ht = Ot = St = null,
    pu = !1,
    e)
        throw Error(te(300));
    return t
}
function Lm() {
    var t = Ya !== 0;
    return Ya = 0,
    t
}
function pi() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Ht === null ? St.memoizedState = Ht = t : Ht = Ht.next = t,
    Ht
}
function Kn() {
    if (Ot === null) {
        var t = St.alternate;
        t = t !== null ? t.memoizedState : null
    } else
        t = Ot.next;
    var e = Ht === null ? St.memoizedState : Ht.next;
    if (e !== null)
        Ht = e,
        Ot = t;
    else {
        if (t === null)
            throw Error(te(310));
        Ot = t,
        t = {
            memoizedState: Ot.memoizedState,
            baseState: Ot.baseState,
            baseQueue: Ot.baseQueue,
            queue: Ot.queue,
            next: null
        },
        Ht === null ? St.memoizedState = Ht = t : Ht = Ht.next = t
    }
    return Ht
}
function Za(t, e) {
    return typeof e == "function" ? e(t) : e
}
function Rd(t) {
    var e = Kn()
      , n = e.queue;
    if (n === null)
        throw Error(te(311));
    n.lastRenderedReducer = t;
    var i = Ot
      , r = i.baseQueue
      , s = n.pending;
    if (s !== null) {
        if (r !== null) {
            var o = r.next;
            r.next = s.next,
            s.next = o
        }
        i.baseQueue = r = s,
        n.pending = null
    }
    if (r !== null) {
        s = r.next,
        i = i.baseState;
        var a = o = null
          , l = null
          , c = s;
        do {
            var u = c.lane;
            if ((ys & u) === u)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                i = c.hasEagerState ? c.eagerState : t(i, c.action);
            else {
                var d = {
                    lane: u,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = d,
                o = i) : l = l.next = d,
                St.lanes |= u,
                xs |= u
            }
            c = c.next
        } while (c !== null && c !== s);
        l === null ? o = i : l.next = a,
        di(i, e.memoizedState) || (gn = !0),
        e.memoizedState = i,
        e.baseState = o,
        e.baseQueue = l,
        n.lastRenderedState = i
    }
    if (t = n.interleaved,
    t !== null) {
        r = t;
        do
            s = r.lane,
            St.lanes |= s,
            xs |= s,
            r = r.next;
        while (r !== t)
    } else
        r === null && (n.lanes = 0);
    return [e.memoizedState, n.dispatch]
}
function Pd(t) {
    var e = Kn()
      , n = e.queue;
    if (n === null)
        throw Error(te(311));
    n.lastRenderedReducer = t;
    var i = n.dispatch
      , r = n.pending
      , s = e.memoizedState;
    if (r !== null) {
        n.pending = null;
        var o = r = r.next;
        do
            s = t(s, o.action),
            o = o.next;
        while (o !== r);
        di(s, e.memoizedState) || (gn = !0),
        e.memoizedState = s,
        e.baseQueue === null && (e.baseState = s),
        n.lastRenderedState = s
    }
    return [s, i]
}
function Kx() {}
function Yx(t, e) {
    var n = St
      , i = Kn()
      , r = e()
      , s = !di(i.memoizedState, r);
    if (s && (i.memoizedState = r,
    gn = !0),
    i = i.queue,
    Im(Qx.bind(null, n, i, t), [t]),
    i.getSnapshot !== e || s || Ht !== null && Ht.memoizedState.tag & 1) {
        if (n.flags |= 2048,
        Ja(9, Jx.bind(null, n, i, r, e), void 0, null),
        Gt === null)
            throw Error(te(349));
        ys & 30 || Zx(n, e, r)
    }
    return r
}
function Zx(t, e, n) {
    t.flags |= 16384,
    t = {
        getSnapshot: e,
        value: n
    },
    e = St.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    St.updateQueue = e,
    e.stores = [t]) : (n = e.stores,
    n === null ? e.stores = [t] : n.push(t))
}
function Jx(t, e, n, i) {
    e.value = n,
    e.getSnapshot = i,
    eS(e) && tS(t)
}
function Qx(t, e, n) {
    return n(function() {
        eS(e) && tS(t)
    })
}
function eS(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var n = e();
        return !di(t, n)
    } catch {
        return !0
    }
}
function tS(t) {
    var e = $i(t, 1);
    e !== null && ci(e, t, 1, -1)
}
function N0(t) {
    var e = pi();
    return typeof t == "function" && (t = t()),
    e.memoizedState = e.baseState = t,
    t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Za,
        lastRenderedState: t
    },
    e.queue = t,
    t = t.dispatch = MM.bind(null, St, t),
    [e.memoizedState, t]
}
function Ja(t, e, n, i) {
    return t = {
        tag: t,
        create: e,
        destroy: n,
        deps: i,
        next: null
    },
    e = St.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    St.updateQueue = e,
    e.lastEffect = t.next = t) : (n = e.lastEffect,
    n === null ? e.lastEffect = t.next = t : (i = n.next,
    n.next = t,
    t.next = i,
    e.lastEffect = t)),
    t
}
function nS() {
    return Kn().memoizedState
}
function Uc(t, e, n, i) {
    var r = pi();
    St.flags |= t,
    r.memoizedState = Ja(1 | e, n, void 0, i === void 0 ? null : i)
}
function zu(t, e, n, i) {
    var r = Kn();
    i = i === void 0 ? null : i;
    var s = void 0;
    if (Ot !== null) {
        var o = Ot.memoizedState;
        if (s = o.destroy,
        i !== null && Nm(i, o.deps)) {
            r.memoizedState = Ja(e, n, s, i);
            return
        }
    }
    St.flags |= t,
    r.memoizedState = Ja(1 | e, n, s, i)
}
function D0(t, e) {
    return Uc(8390656, 8, t, e)
}
function Im(t, e) {
    return zu(2048, 8, t, e)
}
function iS(t, e) {
    return zu(4, 2, t, e)
}
function rS(t, e) {
    return zu(4, 4, t, e)
}
function sS(t, e) {
    if (typeof e == "function")
        return t = t(),
        e(t),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return t = t(),
        e.current = t,
        function() {
            e.current = null
        }
}
function oS(t, e, n) {
    return n = n != null ? n.concat([t]) : null,
    zu(4, 4, sS.bind(null, e, t), n)
}
function km() {}
function aS(t, e) {
    var n = Kn();
    e = e === void 0 ? null : e;
    var i = n.memoizedState;
    return i !== null && e !== null && Nm(e, i[1]) ? i[0] : (n.memoizedState = [t, e],
    t)
}
function lS(t, e) {
    var n = Kn();
    e = e === void 0 ? null : e;
    var i = n.memoizedState;
    return i !== null && e !== null && Nm(e, i[1]) ? i[0] : (t = t(),
    n.memoizedState = [t, e],
    t)
}
function cS(t, e, n) {
    return ys & 21 ? (di(n, e) || (n = px(),
    St.lanes |= n,
    xs |= n,
    t.baseState = !0),
    e) : (t.baseState && (t.baseState = !1,
    gn = !0),
    t.memoizedState = n)
}
function EM(t, e) {
    var n = nt;
    nt = n !== 0 && 4 > n ? n : 4,
    t(!0);
    var i = Cd.transition;
    Cd.transition = {};
    try {
        t(!1),
        e()
    } finally {
        nt = n,
        Cd.transition = i
    }
}
function uS() {
    return Kn().memoizedState
}
function TM(t, e, n) {
    var i = Tr(t);
    if (n = {
        lane: i,
        action: n,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    dS(t))
        hS(e, n);
    else if (n = $x(t, e, n, i),
    n !== null) {
        var r = cn();
        ci(n, t, i, r),
        fS(n, e, i)
    }
}
function MM(t, e, n) {
    var i = Tr(t)
      , r = {
        lane: i,
        action: n,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (dS(t))
        hS(e, r);
    else {
        var s = t.alternate;
        if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer,
        s !== null))
            try {
                var o = e.lastRenderedState
                  , a = s(o, n);
                if (r.hasEagerState = !0,
                r.eagerState = a,
                di(a, o)) {
                    var l = e.interleaved;
                    l === null ? (r.next = r,
                    Mm(e)) : (r.next = l.next,
                    l.next = r),
                    e.interleaved = r;
                    return
                }
            } catch {} finally {}
        n = $x(t, e, r, i),
        n !== null && (r = cn(),
        ci(n, t, i, r),
        fS(n, e, i))
    }
}
function dS(t) {
    var e = t.alternate;
    return t === St || e !== null && e === St
}
function hS(t, e) {
    Ta = pu = !0;
    var n = t.pending;
    n === null ? e.next = e : (e.next = n.next,
    n.next = e),
    t.pending = e
}
function fS(t, e, n) {
    if (n & 4194240) {
        var i = e.lanes;
        i &= t.pendingLanes,
        n |= i,
        e.lanes = n,
        hm(t, n)
    }
}
var mu = {
    readContext: qn,
    useCallback: Yt,
    useContext: Yt,
    useEffect: Yt,
    useImperativeHandle: Yt,
    useInsertionEffect: Yt,
    useLayoutEffect: Yt,
    useMemo: Yt,
    useReducer: Yt,
    useRef: Yt,
    useState: Yt,
    useDebugValue: Yt,
    useDeferredValue: Yt,
    useTransition: Yt,
    useMutableSource: Yt,
    useSyncExternalStore: Yt,
    useId: Yt,
    unstable_isNewReconciler: !1
}
  , AM = {
    readContext: qn,
    useCallback: function(t, e) {
        return pi().memoizedState = [t, e === void 0 ? null : e],
        t
    },
    useContext: qn,
    useEffect: D0,
    useImperativeHandle: function(t, e, n) {
        return n = n != null ? n.concat([t]) : null,
        Uc(4194308, 4, sS.bind(null, e, t), n)
    },
    useLayoutEffect: function(t, e) {
        return Uc(4194308, 4, t, e)
    },
    useInsertionEffect: function(t, e) {
        return Uc(4, 2, t, e)
    },
    useMemo: function(t, e) {
        var n = pi();
        return e = e === void 0 ? null : e,
        t = t(),
        n.memoizedState = [t, e],
        t
    },
    useReducer: function(t, e, n) {
        var i = pi();
        return e = n !== void 0 ? n(e) : e,
        i.memoizedState = i.baseState = e,
        t = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: t,
            lastRenderedState: e
        },
        i.queue = t,
        t = t.dispatch = TM.bind(null, St, t),
        [i.memoizedState, t]
    },
    useRef: function(t) {
        var e = pi();
        return t = {
            current: t
        },
        e.memoizedState = t
    },
    useState: N0,
    useDebugValue: km,
    useDeferredValue: function(t) {
        return pi().memoizedState = t
    },
    useTransition: function() {
        var t = N0(!1)
          , e = t[0];
        return t = EM.bind(null, t[1]),
        pi().memoizedState = t,
        [e, t]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(t, e, n) {
        var i = St
          , r = pi();
        if (mt) {
            if (n === void 0)
                throw Error(te(407));
            n = n()
        } else {
            if (n = e(),
            Gt === null)
                throw Error(te(349));
            ys & 30 || Zx(i, e, n)
        }
        r.memoizedState = n;
        var s = {
            value: n,
            getSnapshot: e
        };
        return r.queue = s,
        D0(Qx.bind(null, i, s, t), [t]),
        i.flags |= 2048,
        Ja(9, Jx.bind(null, i, s, n, e), void 0, null),
        n
    },
    useId: function() {
        var t = pi()
          , e = Gt.identifierPrefix;
        if (mt) {
            var n = Fi
              , i = Oi;
            n = (i & ~(1 << 32 - li(i) - 1)).toString(32) + n,
            e = ":" + e + "R" + n,
            n = Ya++,
            0 < n && (e += "H" + n.toString(32)),
            e += ":"
        } else
            n = bM++,
            e = ":" + e + "r" + n.toString(32) + ":";
        return t.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , CM = {
    readContext: qn,
    useCallback: aS,
    useContext: qn,
    useEffect: Im,
    useImperativeHandle: oS,
    useInsertionEffect: iS,
    useLayoutEffect: rS,
    useMemo: lS,
    useReducer: Rd,
    useRef: nS,
    useState: function() {
        return Rd(Za)
    },
    useDebugValue: km,
    useDeferredValue: function(t) {
        var e = Kn();
        return cS(e, Ot.memoizedState, t)
    },
    useTransition: function() {
        var t = Rd(Za)[0]
          , e = Kn().memoizedState;
        return [t, e]
    },
    useMutableSource: Kx,
    useSyncExternalStore: Yx,
    useId: uS,
    unstable_isNewReconciler: !1
}
  , RM = {
    readContext: qn,
    useCallback: aS,
    useContext: qn,
    useEffect: Im,
    useImperativeHandle: oS,
    useInsertionEffect: iS,
    useLayoutEffect: rS,
    useMemo: lS,
    useReducer: Pd,
    useRef: nS,
    useState: function() {
        return Pd(Za)
    },
    useDebugValue: km,
    useDeferredValue: function(t) {
        var e = Kn();
        return Ot === null ? e.memoizedState = t : cS(e, Ot.memoizedState, t)
    },
    useTransition: function() {
        var t = Pd(Za)[0]
          , e = Kn().memoizedState;
        return [t, e]
    },
    useMutableSource: Kx,
    useSyncExternalStore: Yx,
    useId: uS,
    unstable_isNewReconciler: !1
};
function ni(t, e) {
    if (t && t.defaultProps) {
        e = wt({}, e),
        t = t.defaultProps;
        for (var n in t)
            e[n] === void 0 && (e[n] = t[n]);
        return e
    }
    return e
}
function mf(t, e, n, i) {
    e = t.memoizedState,
    n = n(i, e),
    n = n == null ? e : wt({}, e, n),
    t.memoizedState = n,
    t.lanes === 0 && (t.updateQueue.baseState = n)
}
var Vu = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? Ts(t) === t : !1
    },
    enqueueSetState: function(t, e, n) {
        t = t._reactInternals;
        var i = cn()
          , r = Tr(t)
          , s = Vi(i, r);
        s.payload = e,
        n != null && (s.callback = n),
        e = br(t, s, r),
        e !== null && (ci(e, t, r, i),
        Ic(e, t, r))
    },
    enqueueReplaceState: function(t, e, n) {
        t = t._reactInternals;
        var i = cn()
          , r = Tr(t)
          , s = Vi(i, r);
        s.tag = 1,
        s.payload = e,
        n != null && (s.callback = n),
        e = br(t, s, r),
        e !== null && (ci(e, t, r, i),
        Ic(e, t, r))
    },
    enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var n = cn()
          , i = Tr(t)
          , r = Vi(n, i);
        r.tag = 2,
        e != null && (r.callback = e),
        e = br(t, r, i),
        e !== null && (ci(e, t, i, n),
        Ic(e, t, i))
    }
};
function L0(t, e, n, i, r, s, o) {
    return t = t.stateNode,
    typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Ga(n, i) || !Ga(r, s) : !0
}
function pS(t, e, n) {
    var i = !1
      , r = Pr
      , s = e.contextType;
    return typeof s == "object" && s !== null ? s = qn(s) : (r = yn(e) ? vs : nn.current,
    i = e.contextTypes,
    s = (i = i != null) ? Mo(t, r) : Pr),
    e = new e(n,s),
    t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = Vu,
    t.stateNode = e,
    e._reactInternals = t,
    i && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = r,
    t.__reactInternalMemoizedMaskedChildContext = s),
    e
}
function I0(t, e, n, i) {
    t = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, i),
    e.state !== t && Vu.enqueueReplaceState(e, e.state, null)
}
function gf(t, e, n, i) {
    var r = t.stateNode;
    r.props = n,
    r.state = t.memoizedState,
    r.refs = {},
    Am(t);
    var s = e.contextType;
    typeof s == "object" && s !== null ? r.context = qn(s) : (s = yn(e) ? vs : nn.current,
    r.context = Mo(t, s)),
    r.state = t.memoizedState,
    s = e.getDerivedStateFromProps,
    typeof s == "function" && (mf(t, e, s, n),
    r.state = t.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state,
    typeof r.componentWillMount == "function" && r.componentWillMount(),
    typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(),
    e !== r.state && Vu.enqueueReplaceState(r, r.state, null),
    hu(t, n, r, i),
    r.state = t.memoizedState),
    typeof r.componentDidMount == "function" && (t.flags |= 4194308)
}
function Po(t, e) {
    try {
        var n = ""
          , i = e;
        do
            n += iT(i),
            i = i.return;
        while (i);
        var r = n
    } catch (s) {
        r = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: t,
        source: e,
        stack: r,
        digest: null
    }
}
function Nd(t, e, n) {
    return {
        value: t,
        source: null,
        stack: n ?? null,
        digest: e ?? null
    }
}
function vf(t, e) {
    try {
        console.error(e.value)
    } catch (n) {
        setTimeout(function() {
            throw n
        })
    }
}
var PM = typeof WeakMap == "function" ? WeakMap : Map;
function mS(t, e, n) {
    n = Vi(-1, n),
    n.tag = 3,
    n.payload = {
        element: null
    };
    var i = e.value;
    return n.callback = function() {
        vu || (vu = !0,
        Af = i),
        vf(t, e)
    }
    ,
    n
}
function gS(t, e, n) {
    n = Vi(-1, n),
    n.tag = 3;
    var i = t.type.getDerivedStateFromError;
    if (typeof i == "function") {
        var r = e.value;
        n.payload = function() {
            return i(r)
        }
        ,
        n.callback = function() {
            vf(t, e)
        }
    }
    var s = t.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function() {
        vf(t, e),
        typeof i != "function" && (Er === null ? Er = new Set([this]) : Er.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    n
}
function k0(t, e, n) {
    var i = t.pingCache;
    if (i === null) {
        i = t.pingCache = new PM;
        var r = new Set;
        i.set(e, r)
    } else
        r = i.get(e),
        r === void 0 && (r = new Set,
        i.set(e, r));
    r.has(n) || (r.add(n),
    t = GM.bind(null, t, e, n),
    e.then(t, t))
}
function U0(t) {
    do {
        var e;
        if ((e = t.tag === 13) && (e = t.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return t;
        t = t.return
    } while (t !== null);
    return null
}
function O0(t, e, n, i, r) {
    return t.mode & 1 ? (t.flags |= 65536,
    t.lanes = r,
    t) : (t === e ? t.flags |= 65536 : (t.flags |= 128,
    n.flags |= 131072,
    n.flags &= -52805,
    n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = Vi(-1, 1),
    e.tag = 2,
    br(n, e, 1))),
    n.lanes |= 1),
    t)
}
var NM = Ji.ReactCurrentOwner
  , gn = !1;
function an(t, e, n, i) {
    e.child = t === null ? Wx(e, null, n, i) : Co(e, t.child, n, i)
}
function F0(t, e, n, i, r) {
    n = n.render;
    var s = e.ref;
    return xo(e, r),
    i = Dm(t, e, n, i, s, r),
    n = Lm(),
    t !== null && !gn ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~r,
    Xi(t, e, r)) : (mt && n && xm(e),
    e.flags |= 1,
    an(t, e, i, r),
    e.child)
}
function B0(t, e, n, i, r) {
    if (t === null) {
        var s = n.type;
        return typeof s == "function" && !Hm(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15,
        e.type = s,
        vS(t, e, s, i, r)) : (t = zc(n.type, null, i, e, e.mode, r),
        t.ref = e.ref,
        t.return = e,
        e.child = t)
    }
    if (s = t.child,
    !(t.lanes & r)) {
        var o = s.memoizedProps;
        if (n = n.compare,
        n = n !== null ? n : Ga,
        n(o, i) && t.ref === e.ref)
            return Xi(t, e, r)
    }
    return e.flags |= 1,
    t = Mr(s, i),
    t.ref = e.ref,
    t.return = e,
    e.child = t
}
function vS(t, e, n, i, r) {
    if (t !== null) {
        var s = t.memoizedProps;
        if (Ga(s, i) && t.ref === e.ref)
            if (gn = !1,
            e.pendingProps = i = s,
            (t.lanes & r) !== 0)
                t.flags & 131072 && (gn = !0);
            else
                return e.lanes = t.lanes,
                Xi(t, e, r)
    }
    return _f(t, e, n, i, r)
}
function _S(t, e, n) {
    var i = e.pendingProps
      , r = i.children
      , s = t !== null ? t.memoizedState : null;
    if (i.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            ct(lo, Cn),
            Cn |= n;
        else {
            if (!(n & 1073741824))
                return t = s !== null ? s.baseLanes | n : n,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: t,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                ct(lo, Cn),
                Cn |= t,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            i = s !== null ? s.baseLanes : n,
            ct(lo, Cn),
            Cn |= i
        }
    else
        s !== null ? (i = s.baseLanes | n,
        e.memoizedState = null) : i = n,
        ct(lo, Cn),
        Cn |= i;
    return an(t, e, r, n),
    e.child
}
function yS(t, e) {
    var n = e.ref;
    (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512,
    e.flags |= 2097152)
}
function _f(t, e, n, i, r) {
    var s = yn(n) ? vs : nn.current;
    return s = Mo(e, s),
    xo(e, r),
    n = Dm(t, e, n, i, s, r),
    i = Lm(),
    t !== null && !gn ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~r,
    Xi(t, e, r)) : (mt && i && xm(e),
    e.flags |= 1,
    an(t, e, n, r),
    e.child)
}
function z0(t, e, n, i, r) {
    if (yn(n)) {
        var s = !0;
        au(e)
    } else
        s = !1;
    if (xo(e, r),
    e.stateNode === null)
        Oc(t, e),
        pS(e, n, i),
        gf(e, n, i, r),
        i = !0;
    else if (t === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , c = n.contextType;
        typeof c == "object" && c !== null ? c = qn(c) : (c = yn(n) ? vs : nn.current,
        c = Mo(e, c));
        var u = n.getDerivedStateFromProps
          , d = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== c) && I0(e, o, i, c),
        hr = !1;
        var h = e.memoizedState;
        o.state = h,
        hu(e, i, o, r),
        l = e.memoizedState,
        a !== i || h !== l || _n.current || hr ? (typeof u == "function" && (mf(e, n, u, i),
        l = e.memoizedState),
        (a = hr || L0(e, n, a, i, h, l, c)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = i,
        e.memoizedState = l),
        o.props = i,
        o.state = l,
        o.context = c,
        i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        i = !1)
    } else {
        o = e.stateNode,
        Xx(t, e),
        a = e.memoizedProps,
        c = e.type === e.elementType ? a : ni(e.type, a),
        o.props = c,
        d = e.pendingProps,
        h = o.context,
        l = n.contextType,
        typeof l == "object" && l !== null ? l = qn(l) : (l = yn(n) ? vs : nn.current,
        l = Mo(e, l));
        var p = n.getDerivedStateFromProps;
        (u = typeof p == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || h !== l) && I0(e, o, i, l),
        hr = !1,
        h = e.memoizedState,
        o.state = h,
        hu(e, i, o, r);
        var v = e.memoizedState;
        a !== d || h !== v || _n.current || hr ? (typeof p == "function" && (mf(e, n, p, i),
        v = e.memoizedState),
        (c = hr || L0(e, n, c, i, h, v, l) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, v, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, v, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024),
        e.memoizedProps = i,
        e.memoizedState = v),
        o.props = i,
        o.state = v,
        o.context = l,
        i = c) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024),
        i = !1)
    }
    return yf(t, e, n, i, s, r)
}
function yf(t, e, n, i, r, s) {
    yS(t, e);
    var o = (e.flags & 128) !== 0;
    if (!i && !o)
        return r && T0(e, n, !1),
        Xi(t, e, s);
    i = e.stateNode,
    NM.current = e;
    var a = o && typeof n.getDerivedStateFromError != "function" ? null : i.render();
    return e.flags |= 1,
    t !== null && o ? (e.child = Co(e, t.child, null, s),
    e.child = Co(e, null, a, s)) : an(t, e, a, s),
    e.memoizedState = i.state,
    r && T0(e, n, !0),
    e.child
}
function xS(t) {
    var e = t.stateNode;
    e.pendingContext ? E0(t, e.pendingContext, e.pendingContext !== e.context) : e.context && E0(t, e.context, !1),
    Cm(t, e.containerInfo)
}
function V0(t, e, n, i, r) {
    return Ao(),
    wm(r),
    e.flags |= 256,
    an(t, e, n, i),
    e.child
}
var xf = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function Sf(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}
function SS(t, e, n) {
    var i = e.pendingProps, r = yt.current, s = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (r & 2) !== 0),
    a ? (s = !0,
    e.flags &= -129) : (t === null || t.memoizedState !== null) && (r |= 1),
    ct(yt, r & 1),
    t === null)
        return ff(e),
        t = e.memoizedState,
        t !== null && (t = t.dehydrated,
        t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = i.children,
        t = i.fallback,
        s ? (i = e.mode,
        s = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(i & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = Gu(o, i, 0, null),
        t = ps(t, i, n, null),
        s.return = e,
        t.return = e,
        s.sibling = t,
        e.child = s,
        e.child.memoizedState = Sf(n),
        e.memoizedState = xf,
        t) : Um(e, o));
    if (r = t.memoizedState,
    r !== null && (a = r.dehydrated,
    a !== null))
        return DM(t, e, o, i, a, r, n);
    if (s) {
        s = i.fallback,
        o = e.mode,
        r = t.child,
        a = r.sibling;
        var l = {
            mode: "hidden",
            children: i.children
        };
        return !(o & 1) && e.child !== r ? (i = e.child,
        i.childLanes = 0,
        i.pendingProps = l,
        e.deletions = null) : (i = Mr(r, l),
        i.subtreeFlags = r.subtreeFlags & 14680064),
        a !== null ? s = Mr(a, s) : (s = ps(s, o, n, null),
        s.flags |= 2),
        s.return = e,
        i.return = e,
        i.sibling = s,
        e.child = i,
        i = s,
        s = e.child,
        o = t.child.memoizedState,
        o = o === null ? Sf(n) : {
            baseLanes: o.baseLanes | n,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = t.childLanes & ~n,
        e.memoizedState = xf,
        i
    }
    return s = t.child,
    t = s.sibling,
    i = Mr(s, {
        mode: "visible",
        children: i.children
    }),
    !(e.mode & 1) && (i.lanes = n),
    i.return = e,
    i.sibling = null,
    t !== null && (n = e.deletions,
    n === null ? (e.deletions = [t],
    e.flags |= 16) : n.push(t)),
    e.child = i,
    e.memoizedState = null,
    i
}
function Um(t, e) {
    return e = Gu({
        mode: "visible",
        children: e
    }, t.mode, 0, null),
    e.return = t,
    t.child = e
}
function $l(t, e, n, i) {
    return i !== null && wm(i),
    Co(e, t.child, null, n),
    t = Um(e, e.pendingProps.children),
    t.flags |= 2,
    e.memoizedState = null,
    t
}
function DM(t, e, n, i, r, s, o) {
    if (n)
        return e.flags & 256 ? (e.flags &= -257,
        i = Nd(Error(te(422))),
        $l(t, e, o, i)) : e.memoizedState !== null ? (e.child = t.child,
        e.flags |= 128,
        null) : (s = i.fallback,
        r = e.mode,
        i = Gu({
            mode: "visible",
            children: i.children
        }, r, 0, null),
        s = ps(s, r, o, null),
        s.flags |= 2,
        i.return = e,
        s.return = e,
        i.sibling = s,
        e.child = i,
        e.mode & 1 && Co(e, t.child, null, o),
        e.child.memoizedState = Sf(o),
        e.memoizedState = xf,
        s);
    if (!(e.mode & 1))
        return $l(t, e, o, null);
    if (r.data === "$!") {
        if (i = r.nextSibling && r.nextSibling.dataset,
        i)
            var a = i.dgst;
        return i = a,
        s = Error(te(419)),
        i = Nd(s, i, void 0),
        $l(t, e, o, i)
    }
    if (a = (o & t.childLanes) !== 0,
    gn || a) {
        if (i = Gt,
        i !== null) {
            switch (o & -o) {
            case 4:
                r = 2;
                break;
            case 16:
                r = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                r = 32;
                break;
            case 536870912:
                r = 268435456;
                break;
            default:
                r = 0
            }
            r = r & (i.suspendedLanes | o) ? 0 : r,
            r !== 0 && r !== s.retryLane && (s.retryLane = r,
            $i(t, r),
            ci(i, t, r, -1))
        }
        return jm(),
        i = Nd(Error(te(421))),
        $l(t, e, o, i)
    }
    return r.data === "$?" ? (e.flags |= 128,
    e.child = t.child,
    e = WM.bind(null, t),
    r._reactRetry = e,
    null) : (t = s.treeContext,
    Rn = wr(r.nextSibling),
    Pn = e,
    mt = !0,
    si = null,
    t !== null && (zn[Vn++] = Oi,
    zn[Vn++] = Fi,
    zn[Vn++] = _s,
    Oi = t.id,
    Fi = t.overflow,
    _s = e),
    e = Um(e, i.children),
    e.flags |= 4096,
    e)
}
function j0(t, e, n) {
    t.lanes |= e;
    var i = t.alternate;
    i !== null && (i.lanes |= e),
    pf(t.return, e, n)
}
function Dd(t, e, n, i, r) {
    var s = t.memoizedState;
    s === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: n,
        tailMode: r
    } : (s.isBackwards = e,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = i,
    s.tail = n,
    s.tailMode = r)
}
function wS(t, e, n) {
    var i = e.pendingProps
      , r = i.revealOrder
      , s = i.tail;
    if (an(t, e, i.children, n),
    i = yt.current,
    i & 2)
        i = i & 1 | 2,
        e.flags |= 128;
    else {
        if (t !== null && t.flags & 128)
            e: for (t = e.child; t !== null; ) {
                if (t.tag === 13)
                    t.memoizedState !== null && j0(t, n, e);
                else if (t.tag === 19)
                    j0(t, n, e);
                else if (t.child !== null) {
                    t.child.return = t,
                    t = t.child;
                    continue
                }
                if (t === e)
                    break e;
                for (; t.sibling === null; ) {
                    if (t.return === null || t.return === e)
                        break e;
                    t = t.return
                }
                t.sibling.return = t.return,
                t = t.sibling
            }
        i &= 1
    }
    if (ct(yt, i),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (r) {
        case "forwards":
            for (n = e.child,
            r = null; n !== null; )
                t = n.alternate,
                t !== null && fu(t) === null && (r = n),
                n = n.sibling;
            n = r,
            n === null ? (r = e.child,
            e.child = null) : (r = n.sibling,
            n.sibling = null),
            Dd(e, !1, r, n, s);
            break;
        case "backwards":
            for (n = null,
            r = e.child,
            e.child = null; r !== null; ) {
                if (t = r.alternate,
                t !== null && fu(t) === null) {
                    e.child = r;
                    break
                }
                t = r.sibling,
                r.sibling = n,
                n = r,
                r = t
            }
            Dd(e, !0, n, null, s);
            break;
        case "together":
            Dd(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function Oc(t, e) {
    !(e.mode & 1) && t !== null && (t.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function Xi(t, e, n) {
    if (t !== null && (e.dependencies = t.dependencies),
    xs |= e.lanes,
    !(n & e.childLanes))
        return null;
    if (t !== null && e.child !== t.child)
        throw Error(te(153));
    if (e.child !== null) {
        for (t = e.child,
        n = Mr(t, t.pendingProps),
        e.child = n,
        n.return = e; t.sibling !== null; )
            t = t.sibling,
            n = n.sibling = Mr(t, t.pendingProps),
            n.return = e;
        n.sibling = null
    }
    return e.child
}
function LM(t, e, n) {
    switch (e.tag) {
    case 3:
        xS(e),
        Ao();
        break;
    case 5:
        qx(e);
        break;
    case 1:
        yn(e.type) && au(e);
        break;
    case 4:
        Cm(e, e.stateNode.containerInfo);
        break;
    case 10:
        var i = e.type._context
          , r = e.memoizedProps.value;
        ct(uu, i._currentValue),
        i._currentValue = r;
        break;
    case 13:
        if (i = e.memoizedState,
        i !== null)
            return i.dehydrated !== null ? (ct(yt, yt.current & 1),
            e.flags |= 128,
            null) : n & e.child.childLanes ? SS(t, e, n) : (ct(yt, yt.current & 1),
            t = Xi(t, e, n),
            t !== null ? t.sibling : null);
        ct(yt, yt.current & 1);
        break;
    case 19:
        if (i = (n & e.childLanes) !== 0,
        t.flags & 128) {
            if (i)
                return wS(t, e, n);
            e.flags |= 128
        }
        if (r = e.memoizedState,
        r !== null && (r.rendering = null,
        r.tail = null,
        r.lastEffect = null),
        ct(yt, yt.current),
        i)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        _S(t, e, n)
    }
    return Xi(t, e, n)
}
var bS, wf, ES, TS;
bS = function(t, e) {
    for (var n = e.child; n !== null; ) {
        if (n.tag === 5 || n.tag === 6)
            t.appendChild(n.stateNode);
        else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n,
            n = n.child;
            continue
        }
        if (n === e)
            break;
        for (; n.sibling === null; ) {
            if (n.return === null || n.return === e)
                return;
            n = n.return
        }
        n.sibling.return = n.return,
        n = n.sibling
    }
}
;
wf = function() {}
;
ES = function(t, e, n, i) {
    var r = t.memoizedProps;
    if (r !== i) {
        t = e.stateNode,
        ls(Si.current);
        var s = null;
        switch (n) {
        case "input":
            r = Hh(t, r),
            i = Hh(t, i),
            s = [];
            break;
        case "select":
            r = wt({}, r, {
                value: void 0
            }),
            i = wt({}, i, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            r = $h(t, r),
            i = $h(t, i),
            s = [];
            break;
        default:
            typeof r.onClick != "function" && typeof i.onClick == "function" && (t.onclick = su)
        }
        qh(n, i);
        var o;
        n = null;
        for (c in r)
            if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
                if (c === "style") {
                    var a = r[c];
                    for (o in a)
                        a.hasOwnProperty(o) && (n || (n = {}),
                        n[o] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (Oa.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in i) {
            var l = i[c];
            if (a = r != null ? r[c] : void 0,
            i.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}),
                            n[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}),
                            n[o] = l[o])
                    } else
                        n || (s || (s = []),
                        s.push(c, n)),
                        n = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (Oa.hasOwnProperty(c) ? (l != null && c === "onScroll" && dt("scroll", t),
                    s || a === l || (s = [])) : (s = s || []).push(c, l))
        }
        n && (s = s || []).push("style", n);
        var c = s;
        (e.updateQueue = c) && (e.flags |= 4)
    }
}
;
TS = function(t, e, n, i) {
    n !== i && (e.flags |= 4)
}
;
function ia(t, e) {
    if (!mt)
        switch (t.tailMode) {
        case "hidden":
            e = t.tail;
            for (var n = null; e !== null; )
                e.alternate !== null && (n = e),
                e = e.sibling;
            n === null ? t.tail = null : n.sibling = null;
            break;
        case "collapsed":
            n = t.tail;
            for (var i = null; n !== null; )
                n.alternate !== null && (i = n),
                n = n.sibling;
            i === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : i.sibling = null
        }
}
function Zt(t) {
    var e = t.alternate !== null && t.alternate.child === t.child
      , n = 0
      , i = 0;
    if (e)
        for (var r = t.child; r !== null; )
            n |= r.lanes | r.childLanes,
            i |= r.subtreeFlags & 14680064,
            i |= r.flags & 14680064,
            r.return = t,
            r = r.sibling;
    else
        for (r = t.child; r !== null; )
            n |= r.lanes | r.childLanes,
            i |= r.subtreeFlags,
            i |= r.flags,
            r.return = t,
            r = r.sibling;
    return t.subtreeFlags |= i,
    t.childLanes = n,
    e
}
function IM(t, e, n) {
    var i = e.pendingProps;
    switch (Sm(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return Zt(e),
        null;
    case 1:
        return yn(e.type) && ou(),
        Zt(e),
        null;
    case 3:
        return i = e.stateNode,
        Ro(),
        ht(_n),
        ht(nn),
        Pm(),
        i.pendingContext && (i.context = i.pendingContext,
        i.pendingContext = null),
        (t === null || t.child === null) && (Gl(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        si !== null && (Pf(si),
        si = null))),
        wf(t, e),
        Zt(e),
        null;
    case 5:
        Rm(e);
        var r = ls(Ka.current);
        if (n = e.type,
        t !== null && e.stateNode != null)
            ES(t, e, n, i, r),
            t.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!i) {
                if (e.stateNode === null)
                    throw Error(te(166));
                return Zt(e),
                null
            }
            if (t = ls(Si.current),
            Gl(e)) {
                i = e.stateNode,
                n = e.type;
                var s = e.memoizedProps;
                switch (i[vi] = e,
                i[Xa] = s,
                t = (e.mode & 1) !== 0,
                n) {
                case "dialog":
                    dt("cancel", i),
                    dt("close", i);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    dt("load", i);
                    break;
                case "video":
                case "audio":
                    for (r = 0; r < ga.length; r++)
                        dt(ga[r], i);
                    break;
                case "source":
                    dt("error", i);
                    break;
                case "img":
                case "image":
                case "link":
                    dt("error", i),
                    dt("load", i);
                    break;
                case "details":
                    dt("toggle", i);
                    break;
                case "input":
                    Zg(i, s),
                    dt("invalid", i);
                    break;
                case "select":
                    i._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    dt("invalid", i);
                    break;
                case "textarea":
                    Qg(i, s),
                    dt("invalid", i)
                }
                qh(n, s),
                r = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && Hl(i.textContent, a, t),
                        r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Hl(i.textContent, a, t),
                        r = ["children", "" + a]) : Oa.hasOwnProperty(o) && a != null && o === "onScroll" && dt("scroll", i)
                    }
                switch (n) {
                case "input":
                    kl(i),
                    Jg(i, s, !0);
                    break;
                case "textarea":
                    kl(i),
                    e0(i);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (i.onclick = su)
                }
                i = r,
                e.updateQueue = i,
                i !== null && (e.flags |= 4)
            } else {
                o = r.nodeType === 9 ? r : r.ownerDocument,
                t === "http://www.w3.org/1999/xhtml" && (t = Qy(n)),
                t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"),
                t.innerHTML = "<script><\/script>",
                t = t.removeChild(t.firstChild)) : typeof i.is == "string" ? t = o.createElement(n, {
                    is: i.is
                }) : (t = o.createElement(n),
                n === "select" && (o = t,
                i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : t = o.createElementNS(t, n),
                t[vi] = e,
                t[Xa] = i,
                bS(t, e, !1, !1),
                e.stateNode = t;
                e: {
                    switch (o = Kh(n, i),
                    n) {
                    case "dialog":
                        dt("cancel", t),
                        dt("close", t),
                        r = i;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        dt("load", t),
                        r = i;
                        break;
                    case "video":
                    case "audio":
                        for (r = 0; r < ga.length; r++)
                            dt(ga[r], t);
                        r = i;
                        break;
                    case "source":
                        dt("error", t),
                        r = i;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        dt("error", t),
                        dt("load", t),
                        r = i;
                        break;
                    case "details":
                        dt("toggle", t),
                        r = i;
                        break;
                    case "input":
                        Zg(t, i),
                        r = Hh(t, i),
                        dt("invalid", t);
                        break;
                    case "option":
                        r = i;
                        break;
                    case "select":
                        t._wrapperState = {
                            wasMultiple: !!i.multiple
                        },
                        r = wt({}, i, {
                            value: void 0
                        }),
                        dt("invalid", t);
                        break;
                    case "textarea":
                        Qg(t, i),
                        r = $h(t, i),
                        dt("invalid", t);
                        break;
                    default:
                        r = i
                    }
                    qh(n, r),
                    a = r;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var l = a[s];
                            s === "style" ? nx(t, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && ex(t, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Fa(t, l) : typeof l == "number" && Fa(t, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Oa.hasOwnProperty(s) ? l != null && s === "onScroll" && dt("scroll", t) : l != null && om(t, s, l, o))
                        }
                    switch (n) {
                    case "input":
                        kl(t),
                        Jg(t, i, !1);
                        break;
                    case "textarea":
                        kl(t),
                        e0(t);
                        break;
                    case "option":
                        i.value != null && t.setAttribute("value", "" + Rr(i.value));
                        break;
                    case "select":
                        t.multiple = !!i.multiple,
                        s = i.value,
                        s != null ? go(t, !!i.multiple, s, !1) : i.defaultValue != null && go(t, !!i.multiple, i.defaultValue, !0);
                        break;
                    default:
                        typeof r.onClick == "function" && (t.onclick = su)
                    }
                    switch (n) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        i = !!i.autoFocus;
                        break e;
                    case "img":
                        i = !0;
                        break e;
                    default:
                        i = !1
                    }
                }
                i && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return Zt(e),
        null;
    case 6:
        if (t && e.stateNode != null)
            TS(t, e, t.memoizedProps, i);
        else {
            if (typeof i != "string" && e.stateNode === null)
                throw Error(te(166));
            if (n = ls(Ka.current),
            ls(Si.current),
            Gl(e)) {
                if (i = e.stateNode,
                n = e.memoizedProps,
                i[vi] = e,
                (s = i.nodeValue !== n) && (t = Pn,
                t !== null))
                    switch (t.tag) {
                    case 3:
                        Hl(i.nodeValue, n, (t.mode & 1) !== 0);
                        break;
                    case 5:
                        t.memoizedProps.suppressHydrationWarning !== !0 && Hl(i.nodeValue, n, (t.mode & 1) !== 0)
                    }
                s && (e.flags |= 4)
            } else
                i = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(i),
                i[vi] = e,
                e.stateNode = i
        }
        return Zt(e),
        null;
    case 13:
        if (ht(yt),
        i = e.memoizedState,
        t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (mt && Rn !== null && e.mode & 1 && !(e.flags & 128))
                Hx(),
                Ao(),
                e.flags |= 98560,
                s = !1;
            else if (s = Gl(e),
            i !== null && i.dehydrated !== null) {
                if (t === null) {
                    if (!s)
                        throw Error(te(318));
                    if (s = e.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(te(317));
                    s[vi] = e
                } else
                    Ao(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                Zt(e),
                s = !1
            } else
                si !== null && (Pf(si),
                si = null),
                s = !0;
            if (!s)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = n,
        e) : (i = i !== null,
        i !== (t !== null && t.memoizedState !== null) && i && (e.child.flags |= 8192,
        e.mode & 1 && (t === null || yt.current & 1 ? Ft === 0 && (Ft = 3) : jm())),
        e.updateQueue !== null && (e.flags |= 4),
        Zt(e),
        null);
    case 4:
        return Ro(),
        wf(t, e),
        t === null && Wa(e.stateNode.containerInfo),
        Zt(e),
        null;
    case 10:
        return Tm(e.type._context),
        Zt(e),
        null;
    case 17:
        return yn(e.type) && ou(),
        Zt(e),
        null;
    case 19:
        if (ht(yt),
        s = e.memoizedState,
        s === null)
            return Zt(e),
            null;
        if (i = (e.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (i)
                ia(s, !1);
            else {
                if (Ft !== 0 || t !== null && t.flags & 128)
                    for (t = e.child; t !== null; ) {
                        if (o = fu(t),
                        o !== null) {
                            for (e.flags |= 128,
                            ia(s, !1),
                            i = o.updateQueue,
                            i !== null && (e.updateQueue = i,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            i = n,
                            n = e.child; n !== null; )
                                s = n,
                                t = i,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = t,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                t = o.dependencies,
                                s.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }),
                                n = n.sibling;
                            return ct(yt, yt.current & 1 | 2),
                            e.child
                        }
                        t = t.sibling
                    }
                s.tail !== null && Ct() > No && (e.flags |= 128,
                i = !0,
                ia(s, !1),
                e.lanes = 4194304)
            }
        else {
            if (!i)
                if (t = fu(o),
                t !== null) {
                    if (e.flags |= 128,
                    i = !0,
                    n = t.updateQueue,
                    n !== null && (e.updateQueue = n,
                    e.flags |= 4),
                    ia(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !mt)
                        return Zt(e),
                        null
                } else
                    2 * Ct() - s.renderingStartTime > No && n !== 1073741824 && (e.flags |= 128,
                    i = !0,
                    ia(s, !1),
                    e.lanes = 4194304);
            s.isBackwards ? (o.sibling = e.child,
            e.child = o) : (n = s.last,
            n !== null ? n.sibling = o : e.child = o,
            s.last = o)
        }
        return s.tail !== null ? (e = s.tail,
        s.rendering = e,
        s.tail = e.sibling,
        s.renderingStartTime = Ct(),
        e.sibling = null,
        n = yt.current,
        ct(yt, i ? n & 1 | 2 : n & 1),
        e) : (Zt(e),
        null);
    case 22:
    case 23:
        return Vm(),
        i = e.memoizedState !== null,
        t !== null && t.memoizedState !== null !== i && (e.flags |= 8192),
        i && e.mode & 1 ? Cn & 1073741824 && (Zt(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : Zt(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(te(156, e.tag))
}
function kM(t, e) {
    switch (Sm(e),
    e.tag) {
    case 1:
        return yn(e.type) && ou(),
        t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 3:
        return Ro(),
        ht(_n),
        ht(nn),
        Pm(),
        t = e.flags,
        t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128,
        e) : null;
    case 5:
        return Rm(e),
        null;
    case 13:
        if (ht(yt),
        t = e.memoizedState,
        t !== null && t.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(te(340));
            Ao()
        }
        return t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 19:
        return ht(yt),
        null;
    case 4:
        return Ro(),
        null;
    case 10:
        return Tm(e.type._context),
        null;
    case 22:
    case 23:
        return Vm(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Xl = !1
  , en = !1
  , UM = typeof WeakSet == "function" ? WeakSet : Set
  , pe = null;
function ao(t, e) {
    var n = t.ref;
    if (n !== null)
        if (typeof n == "function")
            try {
                n(null)
            } catch (i) {
                Tt(t, e, i)
            }
        else
            n.current = null
}
function bf(t, e, n) {
    try {
        n()
    } catch (i) {
        Tt(t, e, i)
    }
}
var H0 = !1;
function OM(t, e) {
    if (of = nu,
    t = Px(),
    ym(t)) {
        if ("selectionStart"in t)
            var n = {
                start: t.selectionStart,
                end: t.selectionEnd
            };
        else
            e: {
                n = (n = t.ownerDocument) && n.defaultView || window;
                var i = n.getSelection && n.getSelection();
                if (i && i.rangeCount !== 0) {
                    n = i.anchorNode;
                    var r = i.anchorOffset
                      , s = i.focusNode;
                    i = i.focusOffset;
                    try {
                        n.nodeType,
                        s.nodeType
                    } catch {
                        n = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , c = 0
                      , u = 0
                      , d = t
                      , h = null;
                    t: for (; ; ) {
                        for (var p; d !== n || r !== 0 && d.nodeType !== 3 || (a = o + r),
                        d !== s || i !== 0 && d.nodeType !== 3 || (l = o + i),
                        d.nodeType === 3 && (o += d.nodeValue.length),
                        (p = d.firstChild) !== null; )
                            h = d,
                            d = p;
                        for (; ; ) {
                            if (d === t)
                                break t;
                            if (h === n && ++c === r && (a = o),
                            h === s && ++u === i && (l = o),
                            (p = d.nextSibling) !== null)
                                break;
                            d = h,
                            h = d.parentNode
                        }
                        d = p
                    }
                    n = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    n = null
            }
        n = n || {
            start: 0,
            end: 0
        }
    } else
        n = null;
    for (af = {
        focusedElem: t,
        selectionRange: n
    },
    nu = !1,
    pe = e; pe !== null; )
        if (e = pe,
        t = e.child,
        (e.subtreeFlags & 1028) !== 0 && t !== null)
            t.return = e,
            pe = t;
        else
            for (; pe !== null; ) {
                e = pe;
                try {
                    var v = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (v !== null) {
                                var x = v.memoizedProps
                                  , g = v.memoizedState
                                  , f = e.stateNode
                                  , y = f.getSnapshotBeforeUpdate(e.elementType === e.type ? x : ni(e.type, x), g);
                                f.__reactInternalSnapshotBeforeUpdate = y
                            }
                            break;
                        case 3:
                            var _ = e.stateNode.containerInfo;
                            _.nodeType === 1 ? _.textContent = "" : _.nodeType === 9 && _.documentElement && _.removeChild(_.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(te(163))
                        }
                } catch (S) {
                    Tt(e, e.return, S)
                }
                if (t = e.sibling,
                t !== null) {
                    t.return = e.return,
                    pe = t;
                    break
                }
                pe = e.return
            }
    return v = H0,
    H0 = !1,
    v
}
function Ma(t, e, n) {
    var i = e.updateQueue;
    if (i = i !== null ? i.lastEffect : null,
    i !== null) {
        var r = i = i.next;
        do {
            if ((r.tag & t) === t) {
                var s = r.destroy;
                r.destroy = void 0,
                s !== void 0 && bf(e, n, s)
            }
            r = r.next
        } while (r !== i)
    }
}
function ju(t, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var n = e = e.next;
        do {
            if ((n.tag & t) === t) {
                var i = n.create;
                n.destroy = i()
            }
            n = n.next
        } while (n !== e)
    }
}
function Ef(t) {
    var e = t.ref;
    if (e !== null) {
        var n = t.stateNode;
        switch (t.tag) {
        case 5:
            t = n;
            break;
        default:
            t = n
        }
        typeof e == "function" ? e(t) : e.current = t
    }
}
function MS(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null,
    MS(e)),
    t.child = null,
    t.deletions = null,
    t.sibling = null,
    t.tag === 5 && (e = t.stateNode,
    e !== null && (delete e[vi],
    delete e[Xa],
    delete e[uf],
    delete e[yM],
    delete e[xM])),
    t.stateNode = null,
    t.return = null,
    t.dependencies = null,
    t.memoizedProps = null,
    t.memoizedState = null,
    t.pendingProps = null,
    t.stateNode = null,
    t.updateQueue = null
}
function AS(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}
function G0(t) {
    e: for (; ; ) {
        for (; t.sibling === null; ) {
            if (t.return === null || AS(t.return))
                return null;
            t = t.return
        }
        for (t.sibling.return = t.return,
        t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
            if (t.flags & 2 || t.child === null || t.tag === 4)
                continue e;
            t.child.return = t,
            t = t.child
        }
        if (!(t.flags & 2))
            return t.stateNode
    }
}
function Tf(t, e, n) {
    var i = t.tag;
    if (i === 5 || i === 6)
        t = t.stateNode,
        e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode,
        e.insertBefore(t, n)) : (e = n,
        e.appendChild(t)),
        n = n._reactRootContainer,
        n != null || e.onclick !== null || (e.onclick = su));
    else if (i !== 4 && (t = t.child,
    t !== null))
        for (Tf(t, e, n),
        t = t.sibling; t !== null; )
            Tf(t, e, n),
            t = t.sibling
}
function Mf(t, e, n) {
    var i = t.tag;
    if (i === 5 || i === 6)
        t = t.stateNode,
        e ? n.insertBefore(t, e) : n.appendChild(t);
    else if (i !== 4 && (t = t.child,
    t !== null))
        for (Mf(t, e, n),
        t = t.sibling; t !== null; )
            Mf(t, e, n),
            t = t.sibling
}
var Wt = null
  , ii = !1;
function er(t, e, n) {
    for (n = n.child; n !== null; )
        CS(t, e, n),
        n = n.sibling
}
function CS(t, e, n) {
    if (xi && typeof xi.onCommitFiberUnmount == "function")
        try {
            xi.onCommitFiberUnmount(Iu, n)
        } catch {}
    switch (n.tag) {
    case 5:
        en || ao(n, e);
    case 6:
        var i = Wt
          , r = ii;
        Wt = null,
        er(t, e, n),
        Wt = i,
        ii = r,
        Wt !== null && (ii ? (t = Wt,
        n = n.stateNode,
        t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Wt.removeChild(n.stateNode));
        break;
    case 18:
        Wt !== null && (ii ? (t = Wt,
        n = n.stateNode,
        t.nodeType === 8 ? Td(t.parentNode, n) : t.nodeType === 1 && Td(t, n),
        ja(t)) : Td(Wt, n.stateNode));
        break;
    case 4:
        i = Wt,
        r = ii,
        Wt = n.stateNode.containerInfo,
        ii = !0,
        er(t, e, n),
        Wt = i,
        ii = r;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!en && (i = n.updateQueue,
        i !== null && (i = i.lastEffect,
        i !== null))) {
            r = i = i.next;
            do {
                var s = r
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && bf(n, e, o),
                r = r.next
            } while (r !== i)
        }
        er(t, e, n);
        break;
    case 1:
        if (!en && (ao(n, e),
        i = n.stateNode,
        typeof i.componentWillUnmount == "function"))
            try {
                i.props = n.memoizedProps,
                i.state = n.memoizedState,
                i.componentWillUnmount()
            } catch (a) {
                Tt(n, e, a)
            }
        er(t, e, n);
        break;
    case 21:
        er(t, e, n);
        break;
    case 22:
        n.mode & 1 ? (en = (i = en) || n.memoizedState !== null,
        er(t, e, n),
        en = i) : er(t, e, n);
        break;
    default:
        er(t, e, n)
    }
}
function W0(t) {
    var e = t.updateQueue;
    if (e !== null) {
        t.updateQueue = null;
        var n = t.stateNode;
        n === null && (n = t.stateNode = new UM),
        e.forEach(function(i) {
            var r = $M.bind(null, t, i);
            n.has(i) || (n.add(i),
            i.then(r, r))
        })
    }
}
function Yn(t, e) {
    var n = e.deletions;
    if (n !== null)
        for (var i = 0; i < n.length; i++) {
            var r = n[i];
            try {
                var s = t
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        Wt = a.stateNode,
                        ii = !1;
                        break e;
                    case 3:
                        Wt = a.stateNode.containerInfo,
                        ii = !0;
                        break e;
                    case 4:
                        Wt = a.stateNode.containerInfo,
                        ii = !0;
                        break e
                    }
                    a = a.return
                }
                if (Wt === null)
                    throw Error(te(160));
                CS(s, o, r),
                Wt = null,
                ii = !1;
                var l = r.alternate;
                l !== null && (l.return = null),
                r.return = null
            } catch (c) {
                Tt(r, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            RS(e, t),
            e = e.sibling
}
function RS(t, e) {
    var n = t.alternate
      , i = t.flags;
    switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (Yn(e, t),
        fi(t),
        i & 4) {
            try {
                Ma(3, t, t.return),
                ju(3, t)
            } catch (x) {
                Tt(t, t.return, x)
            }
            try {
                Ma(5, t, t.return)
            } catch (x) {
                Tt(t, t.return, x)
            }
        }
        break;
    case 1:
        Yn(e, t),
        fi(t),
        i & 512 && n !== null && ao(n, n.return);
        break;
    case 5:
        if (Yn(e, t),
        fi(t),
        i & 512 && n !== null && ao(n, n.return),
        t.flags & 32) {
            var r = t.stateNode;
            try {
                Fa(r, "")
            } catch (x) {
                Tt(t, t.return, x)
            }
        }
        if (i & 4 && (r = t.stateNode,
        r != null)) {
            var s = t.memoizedProps
              , o = n !== null ? n.memoizedProps : s
              , a = t.type
              , l = t.updateQueue;
            if (t.updateQueue = null,
            l !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && Zy(r, s),
                    Kh(a, o);
                    var c = Kh(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var u = l[o]
                          , d = l[o + 1];
                        u === "style" ? nx(r, d) : u === "dangerouslySetInnerHTML" ? ex(r, d) : u === "children" ? Fa(r, d) : om(r, u, d, c)
                    }
                    switch (a) {
                    case "input":
                        Gh(r, s);
                        break;
                    case "textarea":
                        Jy(r, s);
                        break;
                    case "select":
                        var h = r._wrapperState.wasMultiple;
                        r._wrapperState.wasMultiple = !!s.multiple;
                        var p = s.value;
                        p != null ? go(r, !!s.multiple, p, !1) : h !== !!s.multiple && (s.defaultValue != null ? go(r, !!s.multiple, s.defaultValue, !0) : go(r, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    r[Xa] = s
                } catch (x) {
                    Tt(t, t.return, x)
                }
        }
        break;
    case 6:
        if (Yn(e, t),
        fi(t),
        i & 4) {
            if (t.stateNode === null)
                throw Error(te(162));
            r = t.stateNode,
            s = t.memoizedProps;
            try {
                r.nodeValue = s
            } catch (x) {
                Tt(t, t.return, x)
            }
        }
        break;
    case 3:
        if (Yn(e, t),
        fi(t),
        i & 4 && n !== null && n.memoizedState.isDehydrated)
            try {
                ja(e.containerInfo)
            } catch (x) {
                Tt(t, t.return, x)
            }
        break;
    case 4:
        Yn(e, t),
        fi(t);
        break;
    case 13:
        Yn(e, t),
        fi(t),
        r = t.child,
        r.flags & 8192 && (s = r.memoizedState !== null,
        r.stateNode.isHidden = s,
        !s || r.alternate !== null && r.alternate.memoizedState !== null || (Bm = Ct())),
        i & 4 && W0(t);
        break;
    case 22:
        if (u = n !== null && n.memoizedState !== null,
        t.mode & 1 ? (en = (c = en) || u,
        Yn(e, t),
        en = c) : Yn(e, t),
        fi(t),
        i & 8192) {
            if (c = t.memoizedState !== null,
            (t.stateNode.isHidden = c) && !u && t.mode & 1)
                for (pe = t,
                u = t.child; u !== null; ) {
                    for (d = pe = u; pe !== null; ) {
                        switch (h = pe,
                        p = h.child,
                        h.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Ma(4, h, h.return);
                            break;
                        case 1:
                            ao(h, h.return);
                            var v = h.stateNode;
                            if (typeof v.componentWillUnmount == "function") {
                                i = h,
                                n = h.return;
                                try {
                                    e = i,
                                    v.props = e.memoizedProps,
                                    v.state = e.memoizedState,
                                    v.componentWillUnmount()
                                } catch (x) {
                                    Tt(i, n, x)
                                }
                            }
                            break;
                        case 5:
                            ao(h, h.return);
                            break;
                        case 22:
                            if (h.memoizedState !== null) {
                                X0(d);
                                continue
                            }
                        }
                        p !== null ? (p.return = h,
                        pe = p) : X0(d)
                    }
                    u = u.sibling
                }
            e: for (u = null,
            d = t; ; ) {
                if (d.tag === 5) {
                    if (u === null) {
                        u = d;
                        try {
                            r = d.stateNode,
                            c ? (s = r.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode,
                            l = d.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = tx("display", o))
                        } catch (x) {
                            Tt(t, t.return, x)
                        }
                    }
                } else if (d.tag === 6) {
                    if (u === null)
                        try {
                            d.stateNode.nodeValue = c ? "" : d.memoizedProps
                        } catch (x) {
                            Tt(t, t.return, x)
                        }
                } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) {
                    d.child.return = d,
                    d = d.child;
                    continue
                }
                if (d === t)
                    break e;
                for (; d.sibling === null; ) {
                    if (d.return === null || d.return === t)
                        break e;
                    u === d && (u = null),
                    d = d.return
                }
                u === d && (u = null),
                d.sibling.return = d.return,
                d = d.sibling
            }
        }
        break;
    case 19:
        Yn(e, t),
        fi(t),
        i & 4 && W0(t);
        break;
    case 21:
        break;
    default:
        Yn(e, t),
        fi(t)
    }
}
function fi(t) {
    var e = t.flags;
    if (e & 2) {
        try {
            e: {
                for (var n = t.return; n !== null; ) {
                    if (AS(n)) {
                        var i = n;
                        break e
                    }
                    n = n.return
                }
                throw Error(te(160))
            }
            switch (i.tag) {
            case 5:
                var r = i.stateNode;
                i.flags & 32 && (Fa(r, ""),
                i.flags &= -33);
                var s = G0(t);
                Mf(t, s, r);
                break;
            case 3:
            case 4:
                var o = i.stateNode.containerInfo
                  , a = G0(t);
                Tf(t, a, o);
                break;
            default:
                throw Error(te(161))
            }
        } catch (l) {
            Tt(t, t.return, l)
        }
        t.flags &= -3
    }
    e & 4096 && (t.flags &= -4097)
}
function FM(t, e, n) {
    pe = t,
    PS(t)
}
function PS(t, e, n) {
    for (var i = (t.mode & 1) !== 0; pe !== null; ) {
        var r = pe
          , s = r.child;
        if (r.tag === 22 && i) {
            var o = r.memoizedState !== null || Xl;
            if (!o) {
                var a = r.alternate
                  , l = a !== null && a.memoizedState !== null || en;
                a = Xl;
                var c = en;
                if (Xl = o,
                (en = l) && !c)
                    for (pe = r; pe !== null; )
                        o = pe,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? q0(r) : l !== null ? (l.return = o,
                        pe = l) : q0(r);
                for (; s !== null; )
                    pe = s,
                    PS(s),
                    s = s.sibling;
                pe = r,
                Xl = a,
                en = c
            }
            $0(t)
        } else
            r.subtreeFlags & 8772 && s !== null ? (s.return = r,
            pe = s) : $0(t)
    }
}
function $0(t) {
    for (; pe !== null; ) {
        var e = pe;
        if (e.flags & 8772) {
            var n = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        en || ju(5, e);
                        break;
                    case 1:
                        var i = e.stateNode;
                        if (e.flags & 4 && !en)
                            if (n === null)
                                i.componentDidMount();
                            else {
                                var r = e.elementType === e.type ? n.memoizedProps : ni(e.type, n.memoizedProps);
                                i.componentDidUpdate(r, n.memoizedState, i.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && P0(e, s, i);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (n = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    n = e.child.stateNode;
                                    break;
                                case 1:
                                    n = e.child.stateNode
                                }
                            P0(e, o, n)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (n === null && e.flags & 4) {
                            n = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && n.focus();
                                break;
                            case "img":
                                l.src && (n.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var u = c.memoizedState;
                                if (u !== null) {
                                    var d = u.dehydrated;
                                    d !== null && ja(d)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(te(163))
                    }
                en || e.flags & 512 && Ef(e)
            } catch (h) {
                Tt(e, e.return, h)
            }
        }
        if (e === t) {
            pe = null;
            break
        }
        if (n = e.sibling,
        n !== null) {
            n.return = e.return,
            pe = n;
            break
        }
        pe = e.return
    }
}
function X0(t) {
    for (; pe !== null; ) {
        var e = pe;
        if (e === t) {
            pe = null;
            break
        }
        var n = e.sibling;
        if (n !== null) {
            n.return = e.return,
            pe = n;
            break
        }
        pe = e.return
    }
}
function q0(t) {
    for (; pe !== null; ) {
        var e = pe;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var n = e.return;
                try {
                    ju(4, e)
                } catch (l) {
                    Tt(e, n, l)
                }
                break;
            case 1:
                var i = e.stateNode;
                if (typeof i.componentDidMount == "function") {
                    var r = e.return;
                    try {
                        i.componentDidMount()
                    } catch (l) {
                        Tt(e, r, l)
                    }
                }
                var s = e.return;
                try {
                    Ef(e)
                } catch (l) {
                    Tt(e, s, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    Ef(e)
                } catch (l) {
                    Tt(e, o, l)
                }
            }
        } catch (l) {
            Tt(e, e.return, l)
        }
        if (e === t) {
            pe = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            pe = a;
            break
        }
        pe = e.return
    }
}
var BM = Math.ceil
  , gu = Ji.ReactCurrentDispatcher
  , Om = Ji.ReactCurrentOwner
  , Wn = Ji.ReactCurrentBatchConfig
  , Ze = 0
  , Gt = null
  , Dt = null
  , Xt = 0
  , Cn = 0
  , lo = Ur(0)
  , Ft = 0
  , Qa = null
  , xs = 0
  , Hu = 0
  , Fm = 0
  , Aa = null
  , pn = null
  , Bm = 0
  , No = 1 / 0
  , Li = null
  , vu = !1
  , Af = null
  , Er = null
  , ql = !1
  , _r = null
  , _u = 0
  , Ca = 0
  , Cf = null
  , Fc = -1
  , Bc = 0;
function cn() {
    return Ze & 6 ? Ct() : Fc !== -1 ? Fc : Fc = Ct()
}
function Tr(t) {
    return t.mode & 1 ? Ze & 2 && Xt !== 0 ? Xt & -Xt : wM.transition !== null ? (Bc === 0 && (Bc = px()),
    Bc) : (t = nt,
    t !== 0 || (t = window.event,
    t = t === void 0 ? 16 : Sx(t.type)),
    t) : 1
}
function ci(t, e, n, i) {
    if (50 < Ca)
        throw Ca = 0,
        Cf = null,
        Error(te(185));
    fl(t, n, i),
    (!(Ze & 2) || t !== Gt) && (t === Gt && (!(Ze & 2) && (Hu |= n),
    Ft === 4 && pr(t, Xt)),
    xn(t, i),
    n === 1 && Ze === 0 && !(e.mode & 1) && (No = Ct() + 500,
    Bu && Or()))
}
function xn(t, e) {
    var n = t.callbackNode;
    wT(t, e);
    var i = tu(t, t === Gt ? Xt : 0);
    if (i === 0)
        n !== null && i0(n),
        t.callbackNode = null,
        t.callbackPriority = 0;
    else if (e = i & -i,
    t.callbackPriority !== e) {
        if (n != null && i0(n),
        e === 1)
            t.tag === 0 ? SM(K0.bind(null, t)) : zx(K0.bind(null, t)),
            vM(function() {
                !(Ze & 6) && Or()
            }),
            n = null;
        else {
            switch (mx(i)) {
            case 1:
                n = dm;
                break;
            case 4:
                n = hx;
                break;
            case 16:
                n = eu;
                break;
            case 536870912:
                n = fx;
                break;
            default:
                n = eu
            }
            n = FS(n, NS.bind(null, t))
        }
        t.callbackPriority = e,
        t.callbackNode = n
    }
}
function NS(t, e) {
    if (Fc = -1,
    Bc = 0,
    Ze & 6)
        throw Error(te(327));
    var n = t.callbackNode;
    if (So() && t.callbackNode !== n)
        return null;
    var i = tu(t, t === Gt ? Xt : 0);
    if (i === 0)
        return null;
    if (i & 30 || i & t.expiredLanes || e)
        e = yu(t, i);
    else {
        e = i;
        var r = Ze;
        Ze |= 2;
        var s = LS();
        (Gt !== t || Xt !== e) && (Li = null,
        No = Ct() + 500,
        fs(t, e));
        do
            try {
                jM();
                break
            } catch (a) {
                DS(t, a)
            }
        while (!0);
        Em(),
        gu.current = s,
        Ze = r,
        Dt !== null ? e = 0 : (Gt = null,
        Xt = 0,
        e = Ft)
    }
    if (e !== 0) {
        if (e === 2 && (r = ef(t),
        r !== 0 && (i = r,
        e = Rf(t, r))),
        e === 1)
            throw n = Qa,
            fs(t, 0),
            pr(t, i),
            xn(t, Ct()),
            n;
        if (e === 6)
            pr(t, i);
        else {
            if (r = t.current.alternate,
            !(i & 30) && !zM(r) && (e = yu(t, i),
            e === 2 && (s = ef(t),
            s !== 0 && (i = s,
            e = Rf(t, s))),
            e === 1))
                throw n = Qa,
                fs(t, 0),
                pr(t, i),
                xn(t, Ct()),
                n;
            switch (t.finishedWork = r,
            t.finishedLanes = i,
            e) {
            case 0:
            case 1:
                throw Error(te(345));
            case 2:
                Jr(t, pn, Li);
                break;
            case 3:
                if (pr(t, i),
                (i & 130023424) === i && (e = Bm + 500 - Ct(),
                10 < e)) {
                    if (tu(t, 0) !== 0)
                        break;
                    if (r = t.suspendedLanes,
                    (r & i) !== i) {
                        cn(),
                        t.pingedLanes |= t.suspendedLanes & r;
                        break
                    }
                    t.timeoutHandle = cf(Jr.bind(null, t, pn, Li), e);
                    break
                }
                Jr(t, pn, Li);
                break;
            case 4:
                if (pr(t, i),
                (i & 4194240) === i)
                    break;
                for (e = t.eventTimes,
                r = -1; 0 < i; ) {
                    var o = 31 - li(i);
                    s = 1 << o,
                    o = e[o],
                    o > r && (r = o),
                    i &= ~s
                }
                if (i = r,
                i = Ct() - i,
                i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * BM(i / 1960)) - i,
                10 < i) {
                    t.timeoutHandle = cf(Jr.bind(null, t, pn, Li), i);
                    break
                }
                Jr(t, pn, Li);
                break;
            case 5:
                Jr(t, pn, Li);
                break;
            default:
                throw Error(te(329))
            }
        }
    }
    return xn(t, Ct()),
    t.callbackNode === n ? NS.bind(null, t) : null
}
function Rf(t, e) {
    var n = Aa;
    return t.current.memoizedState.isDehydrated && (fs(t, e).flags |= 256),
    t = yu(t, e),
    t !== 2 && (e = pn,
    pn = n,
    e !== null && Pf(e)),
    t
}
function Pf(t) {
    pn === null ? pn = t : pn.push.apply(pn, t)
}
function zM(t) {
    for (var e = t; ; ) {
        if (e.flags & 16384) {
            var n = e.updateQueue;
            if (n !== null && (n = n.stores,
            n !== null))
                for (var i = 0; i < n.length; i++) {
                    var r = n[i]
                      , s = r.getSnapshot;
                    r = r.value;
                    try {
                        if (!di(s(), r))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (n = e.child,
        e.subtreeFlags & 16384 && n !== null)
            n.return = e,
            e = n;
        else {
            if (e === t)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === t)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function pr(t, e) {
    for (e &= ~Fm,
    e &= ~Hu,
    t.suspendedLanes |= e,
    t.pingedLanes &= ~e,
    t = t.expirationTimes; 0 < e; ) {
        var n = 31 - li(e)
          , i = 1 << n;
        t[n] = -1,
        e &= ~i
    }
}
function K0(t) {
    if (Ze & 6)
        throw Error(te(327));
    So();
    var e = tu(t, 0);
    if (!(e & 1))
        return xn(t, Ct()),
        null;
    var n = yu(t, e);
    if (t.tag !== 0 && n === 2) {
        var i = ef(t);
        i !== 0 && (e = i,
        n = Rf(t, i))
    }
    if (n === 1)
        throw n = Qa,
        fs(t, 0),
        pr(t, e),
        xn(t, Ct()),
        n;
    if (n === 6)
        throw Error(te(345));
    return t.finishedWork = t.current.alternate,
    t.finishedLanes = e,
    Jr(t, pn, Li),
    xn(t, Ct()),
    null
}
function zm(t, e) {
    var n = Ze;
    Ze |= 1;
    try {
        return t(e)
    } finally {
        Ze = n,
        Ze === 0 && (No = Ct() + 500,
        Bu && Or())
    }
}
function Ss(t) {
    _r !== null && _r.tag === 0 && !(Ze & 6) && So();
    var e = Ze;
    Ze |= 1;
    var n = Wn.transition
      , i = nt;
    try {
        if (Wn.transition = null,
        nt = 1,
        t)
            return t()
    } finally {
        nt = i,
        Wn.transition = n,
        Ze = e,
        !(Ze & 6) && Or()
    }
}
function Vm() {
    Cn = lo.current,
    ht(lo)
}
function fs(t, e) {
    t.finishedWork = null,
    t.finishedLanes = 0;
    var n = t.timeoutHandle;
    if (n !== -1 && (t.timeoutHandle = -1,
    gM(n)),
    Dt !== null)
        for (n = Dt.return; n !== null; ) {
            var i = n;
            switch (Sm(i),
            i.tag) {
            case 1:
                i = i.type.childContextTypes,
                i != null && ou();
                break;
            case 3:
                Ro(),
                ht(_n),
                ht(nn),
                Pm();
                break;
            case 5:
                Rm(i);
                break;
            case 4:
                Ro();
                break;
            case 13:
                ht(yt);
                break;
            case 19:
                ht(yt);
                break;
            case 10:
                Tm(i.type._context);
                break;
            case 22:
            case 23:
                Vm()
            }
            n = n.return
        }
    if (Gt = t,
    Dt = t = Mr(t.current, null),
    Xt = Cn = e,
    Ft = 0,
    Qa = null,
    Fm = Hu = xs = 0,
    pn = Aa = null,
    as !== null) {
        for (e = 0; e < as.length; e++)
            if (n = as[e],
            i = n.interleaved,
            i !== null) {
                n.interleaved = null;
                var r = i.next
                  , s = n.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = r,
                    i.next = o
                }
                n.pending = i
            }
        as = null
    }
    return t
}
function DS(t, e) {
    do {
        var n = Dt;
        try {
            if (Em(),
            kc.current = mu,
            pu) {
                for (var i = St.memoizedState; i !== null; ) {
                    var r = i.queue;
                    r !== null && (r.pending = null),
                    i = i.next
                }
                pu = !1
            }
            if (ys = 0,
            Ht = Ot = St = null,
            Ta = !1,
            Ya = 0,
            Om.current = null,
            n === null || n.return === null) {
                Ft = 1,
                Qa = e,
                Dt = null;
                break
            }
            e: {
                var s = t
                  , o = n.return
                  , a = n
                  , l = e;
                if (e = Xt,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , u = a
                      , d = u.tag;
                    if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
                        var h = u.alternate;
                        h ? (u.updateQueue = h.updateQueue,
                        u.memoizedState = h.memoizedState,
                        u.lanes = h.lanes) : (u.updateQueue = null,
                        u.memoizedState = null)
                    }
                    var p = U0(o);
                    if (p !== null) {
                        p.flags &= -257,
                        O0(p, o, a, s, e),
                        p.mode & 1 && k0(s, c, e),
                        e = p,
                        l = c;
                        var v = e.updateQueue;
                        if (v === null) {
                            var x = new Set;
                            x.add(l),
                            e.updateQueue = x
                        } else
                            v.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            k0(s, c, e),
                            jm();
                            break e
                        }
                        l = Error(te(426))
                    }
                } else if (mt && a.mode & 1) {
                    var g = U0(o);
                    if (g !== null) {
                        !(g.flags & 65536) && (g.flags |= 256),
                        O0(g, o, a, s, e),
                        wm(Po(l, a));
                        break e
                    }
                }
                s = l = Po(l, a),
                Ft !== 4 && (Ft = 2),
                Aa === null ? Aa = [s] : Aa.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        e &= -e,
                        s.lanes |= e;
                        var f = mS(s, l, e);
                        R0(s, f);
                        break e;
                    case 1:
                        a = l;
                        var y = s.type
                          , _ = s.stateNode;
                        if (!(s.flags & 128) && (typeof y.getDerivedStateFromError == "function" || _ !== null && typeof _.componentDidCatch == "function" && (Er === null || !Er.has(_)))) {
                            s.flags |= 65536,
                            e &= -e,
                            s.lanes |= e;
                            var S = gS(s, a, e);
                            R0(s, S);
                            break e
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            kS(n)
        } catch (T) {
            e = T,
            Dt === n && n !== null && (Dt = n = n.return);
            continue
        }
        break
    } while (!0)
}
function LS() {
    var t = gu.current;
    return gu.current = mu,
    t === null ? mu : t
}
function jm() {
    (Ft === 0 || Ft === 3 || Ft === 2) && (Ft = 4),
    Gt === null || !(xs & 268435455) && !(Hu & 268435455) || pr(Gt, Xt)
}
function yu(t, e) {
    var n = Ze;
    Ze |= 2;
    var i = LS();
    (Gt !== t || Xt !== e) && (Li = null,
    fs(t, e));
    do
        try {
            VM();
            break
        } catch (r) {
            DS(t, r)
        }
    while (!0);
    if (Em(),
    Ze = n,
    gu.current = i,
    Dt !== null)
        throw Error(te(261));
    return Gt = null,
    Xt = 0,
    Ft
}
function VM() {
    for (; Dt !== null; )
        IS(Dt)
}
function jM() {
    for (; Dt !== null && !fT(); )
        IS(Dt)
}
function IS(t) {
    var e = OS(t.alternate, t, Cn);
    t.memoizedProps = t.pendingProps,
    e === null ? kS(t) : Dt = e,
    Om.current = null
}
function kS(t) {
    var e = t;
    do {
        var n = e.alternate;
        if (t = e.return,
        e.flags & 32768) {
            if (n = kM(n, e),
            n !== null) {
                n.flags &= 32767,
                Dt = n;
                return
            }
            if (t !== null)
                t.flags |= 32768,
                t.subtreeFlags = 0,
                t.deletions = null;
            else {
                Ft = 6,
                Dt = null;
                return
            }
        } else if (n = IM(n, e, Cn),
        n !== null) {
            Dt = n;
            return
        }
        if (e = e.sibling,
        e !== null) {
            Dt = e;
            return
        }
        Dt = e = t
    } while (e !== null);
    Ft === 0 && (Ft = 5)
}
function Jr(t, e, n) {
    var i = nt
      , r = Wn.transition;
    try {
        Wn.transition = null,
        nt = 1,
        HM(t, e, n, i)
    } finally {
        Wn.transition = r,
        nt = i
    }
    return null
}
function HM(t, e, n, i) {
    do
        So();
    while (_r !== null);
    if (Ze & 6)
        throw Error(te(327));
    n = t.finishedWork;
    var r = t.finishedLanes;
    if (n === null)
        return null;
    if (t.finishedWork = null,
    t.finishedLanes = 0,
    n === t.current)
        throw Error(te(177));
    t.callbackNode = null,
    t.callbackPriority = 0;
    var s = n.lanes | n.childLanes;
    if (bT(t, s),
    t === Gt && (Dt = Gt = null,
    Xt = 0),
    !(n.subtreeFlags & 2064) && !(n.flags & 2064) || ql || (ql = !0,
    FS(eu, function() {
        return So(),
        null
    })),
    s = (n.flags & 15990) !== 0,
    n.subtreeFlags & 15990 || s) {
        s = Wn.transition,
        Wn.transition = null;
        var o = nt;
        nt = 1;
        var a = Ze;
        Ze |= 4,
        Om.current = null,
        OM(t, n),
        RS(n, t),
        cM(af),
        nu = !!of,
        af = of = null,
        t.current = n,
        FM(n),
        pT(),
        Ze = a,
        nt = o,
        Wn.transition = s
    } else
        t.current = n;
    if (ql && (ql = !1,
    _r = t,
    _u = r),
    s = t.pendingLanes,
    s === 0 && (Er = null),
    vT(n.stateNode),
    xn(t, Ct()),
    e !== null)
        for (i = t.onRecoverableError,
        n = 0; n < e.length; n++)
            r = e[n],
            i(r.value, {
                componentStack: r.stack,
                digest: r.digest
            });
    if (vu)
        throw vu = !1,
        t = Af,
        Af = null,
        t;
    return _u & 1 && t.tag !== 0 && So(),
    s = t.pendingLanes,
    s & 1 ? t === Cf ? Ca++ : (Ca = 0,
    Cf = t) : Ca = 0,
    Or(),
    null
}
function So() {
    if (_r !== null) {
        var t = mx(_u)
          , e = Wn.transition
          , n = nt;
        try {
            if (Wn.transition = null,
            nt = 16 > t ? 16 : t,
            _r === null)
                var i = !1;
            else {
                if (t = _r,
                _r = null,
                _u = 0,
                Ze & 6)
                    throw Error(te(331));
                var r = Ze;
                for (Ze |= 4,
                pe = t.current; pe !== null; ) {
                    var s = pe
                      , o = s.child;
                    if (pe.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (pe = c; pe !== null; ) {
                                    var u = pe;
                                    switch (u.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ma(8, u, s)
                                    }
                                    var d = u.child;
                                    if (d !== null)
                                        d.return = u,
                                        pe = d;
                                    else
                                        for (; pe !== null; ) {
                                            u = pe;
                                            var h = u.sibling
                                              , p = u.return;
                                            if (MS(u),
                                            u === c) {
                                                pe = null;
                                                break
                                            }
                                            if (h !== null) {
                                                h.return = p,
                                                pe = h;
                                                break
                                            }
                                            pe = p
                                        }
                                }
                            }
                            var v = s.alternate;
                            if (v !== null) {
                                var x = v.child;
                                if (x !== null) {
                                    v.child = null;
                                    do {
                                        var g = x.sibling;
                                        x.sibling = null,
                                        x = g
                                    } while (x !== null)
                                }
                            }
                            pe = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        pe = o;
                    else
                        e: for (; pe !== null; ) {
                            if (s = pe,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Ma(9, s, s.return)
                                }
                            var f = s.sibling;
                            if (f !== null) {
                                f.return = s.return,
                                pe = f;
                                break e
                            }
                            pe = s.return
                        }
                }
                var y = t.current;
                for (pe = y; pe !== null; ) {
                    o = pe;
                    var _ = o.child;
                    if (o.subtreeFlags & 2064 && _ !== null)
                        _.return = o,
                        pe = _;
                    else
                        e: for (o = y; pe !== null; ) {
                            if (a = pe,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        ju(9, a)
                                    }
                                } catch (T) {
                                    Tt(a, a.return, T)
                                }
                            if (a === o) {
                                pe = null;
                                break e
                            }
                            var S = a.sibling;
                            if (S !== null) {
                                S.return = a.return,
                                pe = S;
                                break e
                            }
                            pe = a.return
                        }
                }
                if (Ze = r,
                Or(),
                xi && typeof xi.onPostCommitFiberRoot == "function")
                    try {
                        xi.onPostCommitFiberRoot(Iu, t)
                    } catch {}
                i = !0
            }
            return i
        } finally {
            nt = n,
            Wn.transition = e
        }
    }
    return !1
}
function Y0(t, e, n) {
    e = Po(n, e),
    e = mS(t, e, 1),
    t = br(t, e, 1),
    e = cn(),
    t !== null && (fl(t, 1, e),
    xn(t, e))
}
function Tt(t, e, n) {
    if (t.tag === 3)
        Y0(t, t, n);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                Y0(e, t, n);
                break
            } else if (e.tag === 1) {
                var i = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Er === null || !Er.has(i))) {
                    t = Po(n, t),
                    t = gS(e, t, 1),
                    e = br(e, t, 1),
                    t = cn(),
                    e !== null && (fl(e, 1, t),
                    xn(e, t));
                    break
                }
            }
            e = e.return
        }
}
function GM(t, e, n) {
    var i = t.pingCache;
    i !== null && i.delete(e),
    e = cn(),
    t.pingedLanes |= t.suspendedLanes & n,
    Gt === t && (Xt & n) === n && (Ft === 4 || Ft === 3 && (Xt & 130023424) === Xt && 500 > Ct() - Bm ? fs(t, 0) : Fm |= n),
    xn(t, e)
}
function US(t, e) {
    e === 0 && (t.mode & 1 ? (e = Fl,
    Fl <<= 1,
    !(Fl & 130023424) && (Fl = 4194304)) : e = 1);
    var n = cn();
    t = $i(t, e),
    t !== null && (fl(t, e, n),
    xn(t, n))
}
function WM(t) {
    var e = t.memoizedState
      , n = 0;
    e !== null && (n = e.retryLane),
    US(t, n)
}
function $M(t, e) {
    var n = 0;
    switch (t.tag) {
    case 13:
        var i = t.stateNode
          , r = t.memoizedState;
        r !== null && (n = r.retryLane);
        break;
    case 19:
        i = t.stateNode;
        break;
    default:
        throw Error(te(314))
    }
    i !== null && i.delete(e),
    US(t, n)
}
var OS;
OS = function(t, e, n) {
    if (t !== null)
        if (t.memoizedProps !== e.pendingProps || _n.current)
            gn = !0;
        else {
            if (!(t.lanes & n) && !(e.flags & 128))
                return gn = !1,
                LM(t, e, n);
            gn = !!(t.flags & 131072)
        }
    else
        gn = !1,
        mt && e.flags & 1048576 && Vx(e, cu, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var i = e.type;
        Oc(t, e),
        t = e.pendingProps;
        var r = Mo(e, nn.current);
        xo(e, n),
        r = Dm(null, e, i, t, r, n);
        var s = Lm();
        return e.flags |= 1,
        typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        yn(i) ? (s = !0,
        au(e)) : s = !1,
        e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null,
        Am(e),
        r.updater = Vu,
        e.stateNode = r,
        r._reactInternals = e,
        gf(e, i, t, n),
        e = yf(null, e, i, !0, s, n)) : (e.tag = 0,
        mt && s && xm(e),
        an(null, e, r, n),
        e = e.child),
        e;
    case 16:
        i = e.elementType;
        e: {
            switch (Oc(t, e),
            t = e.pendingProps,
            r = i._init,
            i = r(i._payload),
            e.type = i,
            r = e.tag = qM(i),
            t = ni(i, t),
            r) {
            case 0:
                e = _f(null, e, i, t, n);
                break e;
            case 1:
                e = z0(null, e, i, t, n);
                break e;
            case 11:
                e = F0(null, e, i, t, n);
                break e;
            case 14:
                e = B0(null, e, i, ni(i.type, t), n);
                break e
            }
            throw Error(te(306, i, ""))
        }
        return e;
    case 0:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : ni(i, r),
        _f(t, e, i, r, n);
    case 1:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : ni(i, r),
        z0(t, e, i, r, n);
    case 3:
        e: {
            if (xS(e),
            t === null)
                throw Error(te(387));
            i = e.pendingProps,
            s = e.memoizedState,
            r = s.element,
            Xx(t, e),
            hu(e, i, null, n);
            var o = e.memoizedState;
            if (i = o.element,
            s.isDehydrated)
                if (s = {
                    element: i,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = s,
                e.memoizedState = s,
                e.flags & 256) {
                    r = Po(Error(te(423)), e),
                    e = V0(t, e, i, n, r);
                    break e
                } else if (i !== r) {
                    r = Po(Error(te(424)), e),
                    e = V0(t, e, i, n, r);
                    break e
                } else
                    for (Rn = wr(e.stateNode.containerInfo.firstChild),
                    Pn = e,
                    mt = !0,
                    si = null,
                    n = Wx(e, null, i, n),
                    e.child = n; n; )
                        n.flags = n.flags & -3 | 4096,
                        n = n.sibling;
            else {
                if (Ao(),
                i === r) {
                    e = Xi(t, e, n);
                    break e
                }
                an(t, e, i, n)
            }
            e = e.child
        }
        return e;
    case 5:
        return qx(e),
        t === null && ff(e),
        i = e.type,
        r = e.pendingProps,
        s = t !== null ? t.memoizedProps : null,
        o = r.children,
        lf(i, r) ? o = null : s !== null && lf(i, s) && (e.flags |= 32),
        yS(t, e),
        an(t, e, o, n),
        e.child;
    case 6:
        return t === null && ff(e),
        null;
    case 13:
        return SS(t, e, n);
    case 4:
        return Cm(e, e.stateNode.containerInfo),
        i = e.pendingProps,
        t === null ? e.child = Co(e, null, i, n) : an(t, e, i, n),
        e.child;
    case 11:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : ni(i, r),
        F0(t, e, i, r, n);
    case 7:
        return an(t, e, e.pendingProps, n),
        e.child;
    case 8:
        return an(t, e, e.pendingProps.children, n),
        e.child;
    case 12:
        return an(t, e, e.pendingProps.children, n),
        e.child;
    case 10:
        e: {
            if (i = e.type._context,
            r = e.pendingProps,
            s = e.memoizedProps,
            o = r.value,
            ct(uu, i._currentValue),
            i._currentValue = o,
            s !== null)
                if (di(s.value, o)) {
                    if (s.children === r.children && !_n.current) {
                        e = Xi(t, e, n);
                        break e
                    }
                } else
                    for (s = e.child,
                    s !== null && (s.return = e); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === i) {
                                    if (s.tag === 1) {
                                        l = Vi(-1, n & -n),
                                        l.tag = 2;
                                        var c = s.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var u = c.pending;
                                            u === null ? l.next = l : (l.next = u.next,
                                            u.next = l),
                                            c.pending = l
                                        }
                                    }
                                    s.lanes |= n,
                                    l = s.alternate,
                                    l !== null && (l.lanes |= n),
                                    pf(s.return, n, e),
                                    a.lanes |= n;
                                    break
                                }
                                l = l.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === e.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(te(341));
                            o.lanes |= n,
                            a = o.alternate,
                            a !== null && (a.lanes |= n),
                            pf(o, n, e),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            an(t, e, r.children, n),
            e = e.child
        }
        return e;
    case 9:
        return r = e.type,
        i = e.pendingProps.children,
        xo(e, n),
        r = qn(r),
        i = i(r),
        e.flags |= 1,
        an(t, e, i, n),
        e.child;
    case 14:
        return i = e.type,
        r = ni(i, e.pendingProps),
        r = ni(i.type, r),
        B0(t, e, i, r, n);
    case 15:
        return vS(t, e, e.type, e.pendingProps, n);
    case 17:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : ni(i, r),
        Oc(t, e),
        e.tag = 1,
        yn(i) ? (t = !0,
        au(e)) : t = !1,
        xo(e, n),
        pS(e, i, r),
        gf(e, i, r, n),
        yf(null, e, i, !0, t, n);
    case 19:
        return wS(t, e, n);
    case 22:
        return _S(t, e, n)
    }
    throw Error(te(156, e.tag))
}
;
function FS(t, e) {
    return dx(t, e)
}
function XM(t, e, n, i) {
    this.tag = t,
    this.key = n,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = i,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Hn(t, e, n, i) {
    return new XM(t,e,n,i)
}
function Hm(t) {
    return t = t.prototype,
    !(!t || !t.isReactComponent)
}
function qM(t) {
    if (typeof t == "function")
        return Hm(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof,
        t === lm)
            return 11;
        if (t === cm)
            return 14
    }
    return 2
}
function Mr(t, e) {
    var n = t.alternate;
    return n === null ? (n = Hn(t.tag, e, t.key, t.mode),
    n.elementType = t.elementType,
    n.type = t.type,
    n.stateNode = t.stateNode,
    n.alternate = t,
    t.alternate = n) : (n.pendingProps = e,
    n.type = t.type,
    n.flags = 0,
    n.subtreeFlags = 0,
    n.deletions = null),
    n.flags = t.flags & 14680064,
    n.childLanes = t.childLanes,
    n.lanes = t.lanes,
    n.child = t.child,
    n.memoizedProps = t.memoizedProps,
    n.memoizedState = t.memoizedState,
    n.updateQueue = t.updateQueue,
    e = t.dependencies,
    n.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    n.sibling = t.sibling,
    n.index = t.index,
    n.ref = t.ref,
    n
}
function zc(t, e, n, i, r, s) {
    var o = 2;
    if (i = t,
    typeof t == "function")
        Hm(t) && (o = 1);
    else if (typeof t == "string")
        o = 5;
    else
        e: switch (t) {
        case Js:
            return ps(n.children, r, s, e);
        case am:
            o = 8,
            r |= 8;
            break;
        case Bh:
            return t = Hn(12, n, e, r | 2),
            t.elementType = Bh,
            t.lanes = s,
            t;
        case zh:
            return t = Hn(13, n, e, r),
            t.elementType = zh,
            t.lanes = s,
            t;
        case Vh:
            return t = Hn(19, n, e, r),
            t.elementType = Vh,
            t.lanes = s,
            t;
        case qy:
            return Gu(n, r, s, e);
        default:
            if (typeof t == "object" && t !== null)
                switch (t.$$typeof) {
                case $y:
                    o = 10;
                    break e;
                case Xy:
                    o = 9;
                    break e;
                case lm:
                    o = 11;
                    break e;
                case cm:
                    o = 14;
                    break e;
                case dr:
                    o = 16,
                    i = null;
                    break e
                }
            throw Error(te(130, t == null ? t : typeof t, ""))
        }
    return e = Hn(o, n, e, r),
    e.elementType = t,
    e.type = i,
    e.lanes = s,
    e
}
function ps(t, e, n, i) {
    return t = Hn(7, t, i, e),
    t.lanes = n,
    t
}
function Gu(t, e, n, i) {
    return t = Hn(22, t, i, e),
    t.elementType = qy,
    t.lanes = n,
    t.stateNode = {
        isHidden: !1
    },
    t
}
function Ld(t, e, n) {
    return t = Hn(6, t, null, e),
    t.lanes = n,
    t
}
function Id(t, e, n) {
    return e = Hn(4, t.children !== null ? t.children : [], t.key, e),
    e.lanes = n,
    e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    },
    e
}
function KM(t, e, n, i, r) {
    this.tag = e,
    this.containerInfo = t,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = pd(0),
    this.expirationTimes = pd(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = pd(0),
    this.identifierPrefix = i,
    this.onRecoverableError = r,
    this.mutableSourceEagerHydrationData = null
}
function Gm(t, e, n, i, r, s, o, a, l) {
    return t = new KM(t,e,n,a,l),
    e === 1 ? (e = 1,
    s === !0 && (e |= 8)) : e = 0,
    s = Hn(3, null, null, e),
    t.current = s,
    s.stateNode = t,
    s.memoizedState = {
        element: i,
        isDehydrated: n,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    Am(s),
    t
}
function YM(t, e, n) {
    var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Zs,
        key: i == null ? null : "" + i,
        children: t,
        containerInfo: e,
        implementation: n
    }
}
function BS(t) {
    if (!t)
        return Pr;
    t = t._reactInternals;
    e: {
        if (Ts(t) !== t || t.tag !== 1)
            throw Error(te(170));
        var e = t;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (yn(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(te(171))
    }
    if (t.tag === 1) {
        var n = t.type;
        if (yn(n))
            return Bx(t, n, e)
    }
    return e
}
function zS(t, e, n, i, r, s, o, a, l) {
    return t = Gm(n, i, !0, t, r, s, o, a, l),
    t.context = BS(null),
    n = t.current,
    i = cn(),
    r = Tr(n),
    s = Vi(i, r),
    s.callback = e ?? null,
    br(n, s, r),
    t.current.lanes = r,
    fl(t, r, i),
    xn(t, i),
    t
}
function Wu(t, e, n, i) {
    var r = e.current
      , s = cn()
      , o = Tr(r);
    return n = BS(n),
    e.context === null ? e.context = n : e.pendingContext = n,
    e = Vi(s, o),
    e.payload = {
        element: t
    },
    i = i === void 0 ? null : i,
    i !== null && (e.callback = i),
    t = br(r, e, o),
    t !== null && (ci(t, r, o, s),
    Ic(t, r, o)),
    o
}
function xu(t) {
    if (t = t.current,
    !t.child)
        return null;
    switch (t.child.tag) {
    case 5:
        return t.child.stateNode;
    default:
        return t.child.stateNode
    }
}
function Z0(t, e) {
    if (t = t.memoizedState,
    t !== null && t.dehydrated !== null) {
        var n = t.retryLane;
        t.retryLane = n !== 0 && n < e ? n : e
    }
}
function Wm(t, e) {
    Z0(t, e),
    (t = t.alternate) && Z0(t, e)
}
function ZM() {
    return null
}
var VS = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
}
;
function $m(t) {
    this._internalRoot = t
}
$u.prototype.render = $m.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(te(409));
    Wu(t, e, null, null)
}
;
$u.prototype.unmount = $m.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        Ss(function() {
            Wu(null, t, null, null)
        }),
        e[Wi] = null
    }
}
;
function $u(t) {
    this._internalRoot = t
}
$u.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var e = _x();
        t = {
            blockedOn: null,
            target: t,
            priority: e
        };
        for (var n = 0; n < fr.length && e !== 0 && e < fr[n].priority; n++)
            ;
        fr.splice(n, 0, t),
        n === 0 && xx(t)
    }
}
;
function Xm(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}
function Xu(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}
function J0() {}
function JM(t, e, n, i, r) {
    if (r) {
        if (typeof i == "function") {
            var s = i;
            i = function() {
                var c = xu(o);
                s.call(c)
            }
        }
        var o = zS(e, i, t, 0, null, !1, !1, "", J0);
        return t._reactRootContainer = o,
        t[Wi] = o.current,
        Wa(t.nodeType === 8 ? t.parentNode : t),
        Ss(),
        o
    }
    for (; r = t.lastChild; )
        t.removeChild(r);
    if (typeof i == "function") {
        var a = i;
        i = function() {
            var c = xu(l);
            a.call(c)
        }
    }
    var l = Gm(t, 0, !1, null, null, !1, !1, "", J0);
    return t._reactRootContainer = l,
    t[Wi] = l.current,
    Wa(t.nodeType === 8 ? t.parentNode : t),
    Ss(function() {
        Wu(e, l, n, i)
    }),
    l
}
function qu(t, e, n, i, r) {
    var s = n._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof r == "function") {
            var a = r;
            r = function() {
                var l = xu(o);
                a.call(l)
            }
        }
        Wu(e, o, t, r)
    } else
        o = JM(n, e, t, r, i);
    return xu(o)
}
gx = function(t) {
    switch (t.tag) {
    case 3:
        var e = t.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var n = ma(e.pendingLanes);
            n !== 0 && (hm(e, n | 1),
            xn(e, Ct()),
            !(Ze & 6) && (No = Ct() + 500,
            Or()))
        }
        break;
    case 13:
        Ss(function() {
            var i = $i(t, 1);
            if (i !== null) {
                var r = cn();
                ci(i, t, 1, r)
            }
        }),
        Wm(t, 1)
    }
}
;
fm = function(t) {
    if (t.tag === 13) {
        var e = $i(t, 134217728);
        if (e !== null) {
            var n = cn();
            ci(e, t, 134217728, n)
        }
        Wm(t, 134217728)
    }
}
;
vx = function(t) {
    if (t.tag === 13) {
        var e = Tr(t)
          , n = $i(t, e);
        if (n !== null) {
            var i = cn();
            ci(n, t, e, i)
        }
        Wm(t, e)
    }
}
;
_x = function() {
    return nt
}
;
yx = function(t, e) {
    var n = nt;
    try {
        return nt = t,
        e()
    } finally {
        nt = n
    }
}
;
Zh = function(t, e, n) {
    switch (e) {
    case "input":
        if (Gh(t, n),
        e = n.name,
        n.type === "radio" && e != null) {
            for (n = t; n.parentNode; )
                n = n.parentNode;
            for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < n.length; e++) {
                var i = n[e];
                if (i !== t && i.form === t.form) {
                    var r = Fu(i);
                    if (!r)
                        throw Error(te(90));
                    Yy(i),
                    Gh(i, r)
                }
            }
        }
        break;
    case "textarea":
        Jy(t, n);
        break;
    case "select":
        e = n.value,
        e != null && go(t, !!n.multiple, e, !1)
    }
}
;
sx = zm;
ox = Ss;
var QM = {
    usingClientEntryPoint: !1,
    Events: [ml, no, Fu, ix, rx, zm]
}
  , ra = {
    findFiberByHostInstance: os,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , e1 = {
    bundleType: ra.bundleType,
    version: ra.version,
    rendererPackageName: ra.rendererPackageName,
    rendererConfig: ra.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Ji.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(t) {
        return t = cx(t),
        t === null ? null : t.stateNode
    },
    findFiberByHostInstance: ra.findFiberByHostInstance || ZM,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Kl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Kl.isDisabled && Kl.supportsFiber)
        try {
            Iu = Kl.inject(e1),
            xi = Kl
        } catch {}
}
Dn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = QM;
Dn.createPortal = function(t, e) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Xm(e))
        throw Error(te(200));
    return YM(t, e, null, n)
}
;
Dn.createRoot = function(t, e) {
    if (!Xm(t))
        throw Error(te(299));
    var n = !1
      , i = ""
      , r = VS;
    return e != null && (e.unstable_strictMode === !0 && (n = !0),
    e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    e = Gm(t, 1, !1, null, null, n, !1, i, r),
    t[Wi] = e.current,
    Wa(t.nodeType === 8 ? t.parentNode : t),
    new $m(e)
}
;
Dn.findDOMNode = function(t) {
    if (t == null)
        return null;
    if (t.nodeType === 1)
        return t;
    var e = t._reactInternals;
    if (e === void 0)
        throw typeof t.render == "function" ? Error(te(188)) : (t = Object.keys(t).join(","),
        Error(te(268, t)));
    return t = cx(e),
    t = t === null ? null : t.stateNode,
    t
}
;
Dn.flushSync = function(t) {
    return Ss(t)
}
;
Dn.hydrate = function(t, e, n) {
    if (!Xu(e))
        throw Error(te(200));
    return qu(null, t, e, !0, n)
}
;
Dn.hydrateRoot = function(t, e, n) {
    if (!Xm(t))
        throw Error(te(405));
    var i = n != null && n.hydratedSources || null
      , r = !1
      , s = ""
      , o = VS;
    if (n != null && (n.unstable_strictMode === !0 && (r = !0),
    n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
    n.onRecoverableError !== void 0 && (o = n.onRecoverableError)),
    e = zS(e, null, t, 1, n ?? null, r, !1, s, o),
    t[Wi] = e.current,
    Wa(t),
    i)
        for (t = 0; t < i.length; t++)
            n = i[t],
            r = n._getVersion,
            r = r(n._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, r] : e.mutableSourceEagerHydrationData.push(n, r);
    return new $u(e)
}
;
Dn.render = function(t, e, n) {
    if (!Xu(e))
        throw Error(te(200));
    return qu(null, t, e, !1, n)
}
;
Dn.unmountComponentAtNode = function(t) {
    if (!Xu(t))
        throw Error(te(40));
    return t._reactRootContainer ? (Ss(function() {
        qu(null, null, t, !1, function() {
            t._reactRootContainer = null,
            t[Wi] = null
        })
    }),
    !0) : !1
}
;
Dn.unstable_batchedUpdates = zm;
Dn.unstable_renderSubtreeIntoContainer = function(t, e, n, i) {
    if (!Xu(n))
        throw Error(te(200));
    if (t == null || t._reactInternals === void 0)
        throw Error(te(38));
    return qu(t, e, n, !1, i)
}
;
Dn.version = "18.3.1-next-f1338f8080-20240426";
function jS() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(jS)
        } catch (t) {
            console.error(t)
        }
}
jS(),
jy.exports = Dn;
var t1 = jy.exports, HS, Q0 = t1;
HS = Q0.createRoot,
Q0.hydrateRoot;
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var n1 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const i1 = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase().trim()
  , It = (t, e) => {
    const n = oe.forwardRef( ({color: i="currentColor", size: r=24, strokeWidth: s=2, absoluteStrokeWidth: o, className: a="", children: l, ...c}, u) => oe.createElement("svg", {
        ref: u,
        ...n1,
        width: r,
        height: r,
        stroke: i,
        strokeWidth: o ? Number(s) * 24 / Number(r) : s,
        className: ["lucide", `lucide-${i1(t)}`, a].join(" "),
        ...c
    }, [...e.map( ([d,h]) => oe.createElement(d, h)), ...Array.isArray(l) ? l : [l]]));
    return n.displayName = `${t}`,
    n
}
;
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tr = It("ArrowRight", [["path", {
    d: "M5 12h14",
    key: "1ays0h"
}], ["path", {
    d: "m12 5 7 7-7 7",
    key: "xquz4c"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const r1 = It("ArrowUp", [["path", {
    d: "m5 12 7-7 7 7",
    key: "hav0vg"
}], ["path", {
    d: "M12 19V5",
    key: "x0mq9r"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ev = It("Award", [["circle", {
    cx: "12",
    cy: "8",
    r: "6",
    key: "1vp47v"
}], ["path", {
    d: "M15.477 12.89 17 22l-5-3-5 3 1.523-9.11",
    key: "em7aur"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const s1 = It("Bot", [["path", {
    d: "M12 8V4H8",
    key: "hb8ula"
}], ["rect", {
    width: "16",
    height: "12",
    x: "4",
    y: "8",
    rx: "2",
    key: "enze0r"
}], ["path", {
    d: "M2 14h2",
    key: "vft8re"
}], ["path", {
    d: "M20 14h2",
    key: "4cs60a"
}], ["path", {
    d: "M15 13v2",
    key: "1xurst"
}], ["path", {
    d: "M9 13v2",
    key: "rq6x2g"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tv = It("Briefcase", [["rect", {
    width: "20",
    height: "14",
    x: "2",
    y: "7",
    rx: "2",
    ry: "2",
    key: "eto64e"
}], ["path", {
    d: "M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16",
    key: "zwj3tp"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Yl = It("Code", [["polyline", {
    points: "16 18 22 12 16 6",
    key: "z7tu5w"
}], ["polyline", {
    points: "8 6 2 12 8 18",
    key: "1eg1df"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Zl = It("GraduationCap", [["path", {
    d: "M21.42 10.922a1 1 0 0 0-.019-1.838L12.83 5.18a2 2 0 0 0-1.66 0L2.6 9.08a1 1 0 0 0 0 1.832l8.57 3.908a2 2 0 0 0 1.66 0z",
    key: "j76jl0"
}], ["path", {
    d: "M22 10v6",
    key: "1lu8f3"
}], ["path", {
    d: "M6 12.5V16a6 3 0 0 0 12 0v-3.5",
    key: "1r8lef"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const o1 = It("MousePointer2", [["path", {
    d: "m4 4 7.07 17 2.51-7.39L21 11.07z",
    key: "1vqm48"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kd = It("Palette", [["circle", {
    cx: "13.5",
    cy: "6.5",
    r: ".5",
    fill: "currentColor",
    key: "1okk4w"
}], ["circle", {
    cx: "17.5",
    cy: "10.5",
    r: ".5",
    fill: "currentColor",
    key: "f64h9f"
}], ["circle", {
    cx: "8.5",
    cy: "7.5",
    r: ".5",
    fill: "currentColor",
    key: "fotxhn"
}], ["circle", {
    cx: "6.5",
    cy: "12.5",
    r: ".5",
    fill: "currentColor",
    key: "qy21gx"
}], ["path", {
    d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",
    key: "12rzf8"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nv = It("Rocket", [["path", {
    d: "M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z",
    key: "m3kijz"
}], ["path", {
    d: "m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z",
    key: "1fmvmk"
}], ["path", {
    d: "M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0",
    key: "1f8sc4"
}], ["path", {
    d: "M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5",
    key: "qeys4"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const a1 = It("Settings", [["path", {
    d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
    key: "1qme2f"
}], ["circle", {
    cx: "12",
    cy: "12",
    r: "3",
    key: "1v7zrd"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Su = It("Sparkles", [["path", {
    d: "m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z",
    key: "17u4zn"
}], ["path", {
    d: "M5 3v4",
    key: "bklmnn"
}], ["path", {
    d: "M19 17v4",
    key: "iiml17"
}], ["path", {
    d: "M3 5h4",
    key: "nem4j1"
}], ["path", {
    d: "M17 19h4",
    key: "lbex7p"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iv = It("Target", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["circle", {
    cx: "12",
    cy: "12",
    r: "6",
    key: "1vlfrh"
}], ["circle", {
    cx: "12",
    cy: "12",
    r: "2",
    key: "1c9p78"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const l1 = It("TrendingUp", [["polyline", {
    points: "22 7 13.5 15.5 8.5 10.5 2 17",
    key: "126l90"
}], ["polyline", {
    points: "16 7 22 7 22 13",
    key: "kwv8wd"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ud = It("Users", [["path", {
    d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
    key: "1yyitq"
}], ["circle", {
    cx: "9",
    cy: "7",
    r: "4",
    key: "nufk8"
}], ["path", {
    d: "M22 21v-2a4 4 0 0 0-3-3.87",
    key: "kshegd"
}], ["path", {
    d: "M16 3.13a4 4 0 0 1 0 7.75",
    key: "1da9ce"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sa = It("Video", [["path", {
    d: "m22 8-6 4 6 4V8Z",
    key: "50v9me"
}], ["rect", {
    width: "14",
    height: "12",
    x: "2",
    y: "6",
    rx: "2",
    ry: "2",
    key: "1rqjg6"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vl = It("X", [["path", {
    d: "M18 6 6 18",
    key: "1bl5f8"
}], ["path", {
    d: "m6 6 12 12",
    key: "d8bk6v"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Od = It("Zap", [["polygon", {
    points: "13 2 3 14 12 14 11 22 21 10 12 10 13 2",
    key: "45s27k"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rv = It("ZoomIn", [["circle", {
    cx: "11",
    cy: "11",
    r: "8",
    key: "4ej97u"
}], ["line", {
    x1: "21",
    x2: "16.65",
    y1: "21",
    y2: "16.65",
    key: "13gj7c"
}], ["line", {
    x1: "11",
    x2: "11",
    y1: "8",
    y2: "14",
    key: "1vmskp"
}], ["line", {
    x1: "8",
    x2: "14",
    y1: "11",
    y2: "11",
    key: "durymu"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const c1 = It("ZoomOut", [["circle", {
    cx: "11",
    cy: "11",
    r: "8",
    key: "4ej97u"
}], ["line", {
    x1: "21",
    x2: "16.65",
    y1: "21",
    y2: "16.65",
    key: "13gj7c"
}], ["line", {
    x1: "8",
    x2: "14",
    y1: "11",
    y2: "11",
    key: "durymu"
}]])
  , GS = oe.createContext({});
function u1(t) {
    const e = oe.useRef(null);
    return e.current === null && (e.current = t()),
    e.current
}
const qm = typeof window < "u"
  , d1 = qm ? oe.useLayoutEffect : oe.useEffect
  , Km = oe.createContext(null);
function Ym(t, e) {
    t.indexOf(e) === -1 && t.push(e)
}
function Zm(t, e) {
    const n = t.indexOf(e);
    n > -1 && t.splice(n, 1)
}
const qi = (t, e, n) => n > e ? e : n < t ? t : n;
let wu = () => {}
;
const Ki = {}
  , WS = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t);
function $S(t) {
    return typeof t == "object" && t !== null
}
const XS = t => /^0[^.\s]+$/u.test(t);
function Jm(t) {
    let e;
    return () => (e === void 0 && (e = t()),
    e)
}
const $n = t => t
  , h1 = (t, e) => n => e(t(n))
  , _l = (...t) => t.reduce(h1)
  , el = (t, e, n) => {
    const i = e - t;
    return i === 0 ? 1 : (n - t) / i
}
;
class Qm {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return Ym(this.subscriptions, e),
        () => Zm(this.subscriptions, e)
    }
    notify(e, n, i) {
        const r = this.subscriptions.length;
        if (r)
            if (r === 1)
                this.subscriptions[0](e, n, i);
            else
                for (let s = 0; s < r; s++) {
                    const o = this.subscriptions[s];
                    o && o(e, n, i)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const wi = t => t * 1e3
  , Gn = t => t / 1e3;
function qS(t, e) {
    return e ? t * (1e3 / e) : 0
}
const KS = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t
  , f1 = 1e-7
  , p1 = 12;
function m1(t, e, n, i, r) {
    let s, o, a = 0;
    do
        o = e + (n - e) / 2,
        s = KS(o, i, r) - t,
        s > 0 ? n = o : e = o;
    while (Math.abs(s) > f1 && ++a < p1);
    return o
}
function yl(t, e, n, i) {
    if (t === e && n === i)
        return $n;
    const r = s => m1(s, 0, 1, t, n);
    return s => s === 0 || s === 1 ? s : KS(r(s), e, i)
}
const YS = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2
  , ZS = t => e => 1 - t(1 - e)
  , JS = yl(.33, 1.53, .69, .99)
  , eg = ZS(JS)
  , QS = YS(eg)
  , ew = t => (t *= 2) < 1 ? .5 * eg(t) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
  , tg = t => 1 - Math.sin(Math.acos(t))
  , tw = ZS(tg)
  , nw = YS(tg)
  , g1 = yl(.42, 0, 1, 1)
  , v1 = yl(0, 0, .58, 1)
  , iw = yl(.42, 0, .58, 1)
  , _1 = t => Array.isArray(t) && typeof t[0] != "number"
  , rw = t => Array.isArray(t) && typeof t[0] == "number"
  , sv = {
    linear: $n,
    easeIn: g1,
    easeInOut: iw,
    easeOut: v1,
    circIn: tg,
    circInOut: nw,
    circOut: tw,
    backIn: eg,
    backInOut: QS,
    backOut: JS,
    anticipate: ew
}
  , y1 = t => typeof t == "string"
  , ov = t => {
    if (rw(t)) {
        wu(t.length === 4);
        const [e,n,i,r] = t;
        return yl(e, n, i, r)
    } else if (y1(t))
        return wu(sv[t] !== void 0),
        sv[t];
    return t
}
  , Jl = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"]
  , av = {
    value: null,
    addProjectionMetrics: null
};
function x1(t, e) {
    let n = new Set
      , i = new Set
      , r = !1
      , s = !1;
    const o = new WeakSet;
    let a = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , l = 0;
    function c(d) {
        o.has(d) && (u.schedule(d),
        t()),
        l++,
        d(a)
    }
    const u = {
        schedule: (d, h=!1, p=!1) => {
            const x = p && r ? n : i;
            return h && o.add(d),
            x.has(d) || x.add(d),
            d
        }
        ,
        cancel: d => {
            i.delete(d),
            o.delete(d)
        }
        ,
        process: d => {
            if (a = d,
            r) {
                s = !0;
                return
            }
            r = !0,
            [n,i] = [i, n],
            n.forEach(c),
            e && av.value && av.value.frameloop[e].push(l),
            l = 0,
            n.clear(),
            r = !1,
            s && (s = !1,
            u.process(d))
        }
    };
    return u
}
const S1 = 40;
function sw(t, e) {
    let n = !1
      , i = !0;
    const r = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , s = () => n = !0
      , o = Jl.reduce( (_, S) => (_[S] = x1(s, e ? S : void 0),
    _), {})
      , {setup: a, read: l, resolveKeyframes: c, preUpdate: u, update: d, preRender: h, render: p, postRender: v} = o
      , x = () => {
        const _ = Ki.useManualTiming ? r.timestamp : performance.now();
        n = !1,
        Ki.useManualTiming || (r.delta = i ? 1e3 / 60 : Math.max(Math.min(_ - r.timestamp, S1), 1)),
        r.timestamp = _,
        r.isProcessing = !0,
        a.process(r),
        l.process(r),
        c.process(r),
        u.process(r),
        d.process(r),
        h.process(r),
        p.process(r),
        v.process(r),
        r.isProcessing = !1,
        n && e && (i = !1,
        t(x))
    }
      , g = () => {
        n = !0,
        i = !0,
        r.isProcessing || t(x)
    }
    ;
    return {
        schedule: Jl.reduce( (_, S) => {
            const T = o[S];
            return _[S] = (A, C=!1, P=!1) => (n || g(),
            T.schedule(A, C, P)),
            _
        }
        , {}),
        cancel: _ => {
            for (let S = 0; S < Jl.length; S++)
                o[Jl[S]].cancel(_)
        }
        ,
        state: r,
        steps: o
    }
}
const {schedule: gt, cancel: Nr, state: $t, steps: Fd} = sw(typeof requestAnimationFrame < "u" ? requestAnimationFrame : $n, !0);
let Vc;
function w1() {
    Vc = void 0
}
const vn = {
    now: () => (Vc === void 0 && vn.set($t.isProcessing || Ki.useManualTiming ? $t.timestamp : performance.now()),
    Vc),
    set: t => {
        Vc = t,
        queueMicrotask(w1)
    }
}
  , ow = t => e => typeof e == "string" && e.startsWith(t)
  , ng = ow("--")
  , b1 = ow("var(--")
  , ig = t => b1(t) ? E1.test(t.split("/*")[0].trim()) : !1
  , E1 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , Ho = {
    test: t => typeof t == "number",
    parse: parseFloat,
    transform: t => t
}
  , tl = {
    ...Ho,
    transform: t => qi(0, 1, t)
}
  , Ql = {
    ...Ho,
    default: 1
}
  , Ra = t => Math.round(t * 1e5) / 1e5
  , rg = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function T1(t) {
    return t == null
}
const M1 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
  , sg = (t, e) => n => !!(typeof n == "string" && M1.test(n) && n.startsWith(t) || e && !T1(n) && Object.prototype.hasOwnProperty.call(n, e))
  , aw = (t, e, n) => i => {
    if (typeof i != "string")
        return i;
    const [r,s,o,a] = i.match(rg);
    return {
        [t]: parseFloat(r),
        [e]: parseFloat(s),
        [n]: parseFloat(o),
        alpha: a !== void 0 ? parseFloat(a) : 1
    }
}
  , A1 = t => qi(0, 255, t)
  , Bd = {
    ...Ho,
    transform: t => Math.round(A1(t))
}
  , cs = {
    test: sg("rgb", "red"),
    parse: aw("red", "green", "blue"),
    transform: ({red: t, green: e, blue: n, alpha: i=1}) => "rgba(" + Bd.transform(t) + ", " + Bd.transform(e) + ", " + Bd.transform(n) + ", " + Ra(tl.transform(i)) + ")"
};
function C1(t) {
    let e = ""
      , n = ""
      , i = ""
      , r = "";
    return t.length > 5 ? (e = t.substring(1, 3),
    n = t.substring(3, 5),
    i = t.substring(5, 7),
    r = t.substring(7, 9)) : (e = t.substring(1, 2),
    n = t.substring(2, 3),
    i = t.substring(3, 4),
    r = t.substring(4, 5),
    e += e,
    n += n,
    i += i,
    r += r),
    {
        red: parseInt(e, 16),
        green: parseInt(n, 16),
        blue: parseInt(i, 16),
        alpha: r ? parseInt(r, 16) / 255 : 1
    }
}
const Nf = {
    test: sg("#"),
    parse: C1,
    transform: cs.transform
}
  , xl = t => ({
    test: e => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: e => `${e}${t}`
})
  , cr = xl("deg")
  , bi = xl("%")
  , De = xl("px")
  , R1 = xl("vh")
  , P1 = xl("vw")
  , lv = {
    ...bi,
    parse: t => bi.parse(t) / 100,
    transform: t => bi.transform(t * 100)
}
  , co = {
    test: sg("hsl", "hue"),
    parse: aw("hue", "saturation", "lightness"),
    transform: ({hue: t, saturation: e, lightness: n, alpha: i=1}) => "hsla(" + Math.round(t) + ", " + bi.transform(Ra(e)) + ", " + bi.transform(Ra(n)) + ", " + Ra(tl.transform(i)) + ")"
}
  , Nt = {
    test: t => cs.test(t) || Nf.test(t) || co.test(t),
    parse: t => cs.test(t) ? cs.parse(t) : co.test(t) ? co.parse(t) : Nf.parse(t),
    transform: t => typeof t == "string" ? t : t.hasOwnProperty("red") ? cs.transform(t) : co.transform(t),
    getAnimatableNone: t => {
        const e = Nt.parse(t);
        return e.alpha = 0,
        Nt.transform(e)
    }
}
  , N1 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function D1(t) {
    var e, n;
    return isNaN(t) && typeof t == "string" && (((e = t.match(rg)) == null ? void 0 : e.length) || 0) + (((n = t.match(N1)) == null ? void 0 : n.length) || 0) > 0
}
const lw = "number"
  , cw = "color"
  , L1 = "var"
  , I1 = "var("
  , cv = "${}"
  , k1 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function nl(t) {
    const e = t.toString()
      , n = []
      , i = {
        color: [],
        number: [],
        var: []
    }
      , r = [];
    let s = 0;
    const a = e.replace(k1, l => (Nt.test(l) ? (i.color.push(s),
    r.push(cw),
    n.push(Nt.parse(l))) : l.startsWith(I1) ? (i.var.push(s),
    r.push(L1),
    n.push(l)) : (i.number.push(s),
    r.push(lw),
    n.push(parseFloat(l))),
    ++s,
    cv)).split(cv);
    return {
        values: n,
        split: a,
        indexes: i,
        types: r
    }
}
function uw(t) {
    return nl(t).values
}
function dw(t) {
    const {split: e, types: n} = nl(t)
      , i = e.length;
    return r => {
        let s = "";
        for (let o = 0; o < i; o++)
            if (s += e[o],
            r[o] !== void 0) {
                const a = n[o];
                a === lw ? s += Ra(r[o]) : a === cw ? s += Nt.transform(r[o]) : s += r[o]
            }
        return s
    }
}
const U1 = t => typeof t == "number" ? 0 : Nt.test(t) ? Nt.getAnimatableNone(t) : t;
function O1(t) {
    const e = uw(t);
    return dw(t)(e.map(U1))
}
const Dr = {
    test: D1,
    parse: uw,
    createTransformer: dw,
    getAnimatableNone: O1
};
function zd(t, e, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
}
function F1({hue: t, saturation: e, lightness: n, alpha: i}) {
    t /= 360,
    e /= 100,
    n /= 100;
    let r = 0
      , s = 0
      , o = 0;
    if (!e)
        r = s = o = n;
    else {
        const a = n < .5 ? n * (1 + e) : n + e - n * e
          , l = 2 * n - a;
        r = zd(l, a, t + 1 / 3),
        s = zd(l, a, t),
        o = zd(l, a, t - 1 / 3)
    }
    return {
        red: Math.round(r * 255),
        green: Math.round(s * 255),
        blue: Math.round(o * 255),
        alpha: i
    }
}
function bu(t, e) {
    return n => n > 0 ? e : t
}
const xt = (t, e, n) => t + (e - t) * n
  , Vd = (t, e, n) => {
    const i = t * t
      , r = n * (e * e - i) + i;
    return r < 0 ? 0 : Math.sqrt(r)
}
  , B1 = [Nf, cs, co]
  , z1 = t => B1.find(e => e.test(t));
function uv(t) {
    const e = z1(t);
    if (!e)
        return !1;
    let n = e.parse(t);
    return e === co && (n = F1(n)),
    n
}
const dv = (t, e) => {
    const n = uv(t)
      , i = uv(e);
    if (!n || !i)
        return bu(t, e);
    const r = {
        ...n
    };
    return s => (r.red = Vd(n.red, i.red, s),
    r.green = Vd(n.green, i.green, s),
    r.blue = Vd(n.blue, i.blue, s),
    r.alpha = xt(n.alpha, i.alpha, s),
    cs.transform(r))
}
  , Df = new Set(["none", "hidden"]);
function V1(t, e) {
    return Df.has(t) ? n => n <= 0 ? t : e : n => n >= 1 ? e : t
}
function j1(t, e) {
    return n => xt(t, e, n)
}
function og(t) {
    return typeof t == "number" ? j1 : typeof t == "string" ? ig(t) ? bu : Nt.test(t) ? dv : W1 : Array.isArray(t) ? hw : typeof t == "object" ? Nt.test(t) ? dv : H1 : bu
}
function hw(t, e) {
    const n = [...t]
      , i = n.length
      , r = t.map( (s, o) => og(s)(s, e[o]));
    return s => {
        for (let o = 0; o < i; o++)
            n[o] = r[o](s);
        return n
    }
}
function H1(t, e) {
    const n = {
        ...t,
        ...e
    }
      , i = {};
    for (const r in n)
        t[r] !== void 0 && e[r] !== void 0 && (i[r] = og(t[r])(t[r], e[r]));
    return r => {
        for (const s in i)
            n[s] = i[s](r);
        return n
    }
}
function G1(t, e) {
    const n = []
      , i = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let r = 0; r < e.values.length; r++) {
        const s = e.types[r]
          , o = t.indexes[s][i[s]]
          , a = t.values[o] ?? 0;
        n[r] = a,
        i[s]++
    }
    return n
}
const W1 = (t, e) => {
    const n = Dr.createTransformer(e)
      , i = nl(t)
      , r = nl(e);
    return i.indexes.var.length === r.indexes.var.length && i.indexes.color.length === r.indexes.color.length && i.indexes.number.length >= r.indexes.number.length ? Df.has(t) && !r.values.length || Df.has(e) && !i.values.length ? V1(t, e) : _l(hw(G1(i, r), r.values), n) : bu(t, e)
}
;
function fw(t, e, n) {
    return typeof t == "number" && typeof e == "number" && typeof n == "number" ? xt(t, e, n) : og(t)(t, e)
}
const $1 = t => {
    const e = ({timestamp: n}) => t(n);
    return {
        start: (n=!0) => gt.update(e, n),
        stop: () => Nr(e),
        now: () => $t.isProcessing ? $t.timestamp : vn.now()
    }
}
  , pw = (t, e, n=10) => {
    let i = "";
    const r = Math.max(Math.round(e / n), 2);
    for (let s = 0; s < r; s++)
        i += Math.round(t(s / (r - 1)) * 1e4) / 1e4 + ", ";
    return `linear(${i.substring(0, i.length - 2)})`
}
  , Eu = 2e4;
function ag(t) {
    let e = 0;
    const n = 50;
    let i = t.next(e);
    for (; !i.done && e < Eu; )
        e += n,
        i = t.next(e);
    return e >= Eu ? 1 / 0 : e
}
function X1(t, e=100, n) {
    const i = n({
        ...t,
        keyframes: [0, e]
    })
      , r = Math.min(ag(i), Eu);
    return {
        type: "keyframes",
        ease: s => i.next(r * s).value / e,
        duration: Gn(r)
    }
}
const q1 = 5;
function mw(t, e, n) {
    const i = Math.max(e - q1, 0);
    return qS(n - t(i), e - i)
}
const Et = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: .3,
    visualDuration: .3,
    restSpeed: {
        granular: .01,
        default: 2
    },
    restDelta: {
        granular: .005,
        default: .5
    },
    minDuration: .01,
    maxDuration: 10,
    minDamping: .05,
    maxDamping: 1
}
  , jd = .001;
function K1({duration: t=Et.duration, bounce: e=Et.bounce, velocity: n=Et.velocity, mass: i=Et.mass}) {
    let r, s, o = 1 - e;
    o = qi(Et.minDamping, Et.maxDamping, o),
    t = qi(Et.minDuration, Et.maxDuration, Gn(t)),
    o < 1 ? (r = c => {
        const u = c * o
          , d = u * t
          , h = u - n
          , p = Lf(c, o)
          , v = Math.exp(-d);
        return jd - h / p * v
    }
    ,
    s = c => {
        const d = c * o * t
          , h = d * n + n
          , p = Math.pow(o, 2) * Math.pow(c, 2) * t
          , v = Math.exp(-d)
          , x = Lf(Math.pow(c, 2), o);
        return (-r(c) + jd > 0 ? -1 : 1) * ((h - p) * v) / x
    }
    ) : (r = c => {
        const u = Math.exp(-c * t)
          , d = (c - n) * t + 1;
        return -jd + u * d
    }
    ,
    s = c => {
        const u = Math.exp(-c * t)
          , d = (n - c) * (t * t);
        return u * d
    }
    );
    const a = 5 / t
      , l = Z1(r, s, a);
    if (t = wi(t),
    isNaN(l))
        return {
            stiffness: Et.stiffness,
            damping: Et.damping,
            duration: t
        };
    {
        const c = Math.pow(l, 2) * i;
        return {
            stiffness: c,
            damping: o * 2 * Math.sqrt(i * c),
            duration: t
        }
    }
}
const Y1 = 12;
function Z1(t, e, n) {
    let i = n;
    for (let r = 1; r < Y1; r++)
        i = i - t(i) / e(i);
    return i
}
function Lf(t, e) {
    return t * Math.sqrt(1 - e * e)
}
const J1 = ["duration", "bounce"]
  , Q1 = ["stiffness", "damping", "mass"];
function hv(t, e) {
    return e.some(n => t[n] !== void 0)
}
function eA(t) {
    let e = {
        velocity: Et.velocity,
        stiffness: Et.stiffness,
        damping: Et.damping,
        mass: Et.mass,
        isResolvedFromDuration: !1,
        ...t
    };
    if (!hv(t, Q1) && hv(t, J1))
        if (t.visualDuration) {
            const n = t.visualDuration
              , i = 2 * Math.PI / (n * 1.2)
              , r = i * i
              , s = 2 * qi(.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(r);
            e = {
                ...e,
                mass: Et.mass,
                stiffness: r,
                damping: s
            }
        } else {
            const n = K1(t);
            e = {
                ...e,
                ...n,
                mass: Et.mass
            },
            e.isResolvedFromDuration = !0
        }
    return e
}
function Tu(t=Et.visualDuration, e=Et.bounce) {
    const n = typeof t != "object" ? {
        visualDuration: t,
        keyframes: [0, 1],
        bounce: e
    } : t;
    let {restSpeed: i, restDelta: r} = n;
    const s = n.keyframes[0]
      , o = n.keyframes[n.keyframes.length - 1]
      , a = {
        done: !1,
        value: s
    }
      , {stiffness: l, damping: c, mass: u, duration: d, velocity: h, isResolvedFromDuration: p} = eA({
        ...n,
        velocity: -Gn(n.velocity || 0)
    })
      , v = h || 0
      , x = c / (2 * Math.sqrt(l * u))
      , g = o - s
      , f = Gn(Math.sqrt(l / u))
      , y = Math.abs(g) < 5;
    i || (i = y ? Et.restSpeed.granular : Et.restSpeed.default),
    r || (r = y ? Et.restDelta.granular : Et.restDelta.default);
    let _;
    if (x < 1) {
        const T = Lf(f, x);
        _ = A => {
            const C = Math.exp(-x * f * A);
            return o - C * ((v + x * f * g) / T * Math.sin(T * A) + g * Math.cos(T * A))
        }
    } else if (x === 1)
        _ = T => o - Math.exp(-f * T) * (g + (v + f * g) * T);
    else {
        const T = f * Math.sqrt(x * x - 1);
        _ = A => {
            const C = Math.exp(-x * f * A)
              , P = Math.min(T * A, 300);
            return o - C * ((v + x * f * g) * Math.sinh(P) + T * g * Math.cosh(P)) / T
        }
    }
    const S = {
        calculatedDuration: p && d || null,
        next: T => {
            const A = _(T);
            if (p)
                a.done = T >= d;
            else {
                let C = T === 0 ? v : 0;
                x < 1 && (C = T === 0 ? wi(v) : mw(_, T, A));
                const P = Math.abs(C) <= i
                  , M = Math.abs(o - A) <= r;
                a.done = P && M
            }
            return a.value = a.done ? o : A,
            a
        }
        ,
        toString: () => {
            const T = Math.min(ag(S), Eu)
              , A = pw(C => S.next(T * C).value, T, 30);
            return T + "ms " + A
        }
        ,
        toTransition: () => {}
    };
    return S
}
Tu.applyToOptions = t => {
    const e = X1(t, 100, Tu);
    return t.ease = e.ease,
    t.duration = wi(e.duration),
    t.type = "keyframes",
    t
}
;
function If({keyframes: t, velocity: e=0, power: n=.8, timeConstant: i=325, bounceDamping: r=10, bounceStiffness: s=500, modifyTarget: o, min: a, max: l, restDelta: c=.5, restSpeed: u}) {
    const d = t[0]
      , h = {
        done: !1,
        value: d
    }
      , p = P => a !== void 0 && P < a || l !== void 0 && P > l
      , v = P => a === void 0 ? l : l === void 0 || Math.abs(a - P) < Math.abs(l - P) ? a : l;
    let x = n * e;
    const g = d + x
      , f = o === void 0 ? g : o(g);
    f !== g && (x = f - d);
    const y = P => -x * Math.exp(-P / i)
      , _ = P => f + y(P)
      , S = P => {
        const M = y(P)
          , b = _(P);
        h.done = Math.abs(M) <= c,
        h.value = h.done ? f : b
    }
    ;
    let T, A;
    const C = P => {
        p(h.value) && (T = P,
        A = Tu({
            keyframes: [h.value, v(h.value)],
            velocity: mw(_, P, h.value),
            damping: r,
            stiffness: s,
            restDelta: c,
            restSpeed: u
        }))
    }
    ;
    return C(0),
    {
        calculatedDuration: null,
        next: P => {
            let M = !1;
            return !A && T === void 0 && (M = !0,
            S(P),
            C(P)),
            T !== void 0 && P >= T ? A.next(P - T) : (!M && S(P),
            h)
        }
    }
}
function tA(t, e, n) {
    const i = []
      , r = n || Ki.mix || fw
      , s = t.length - 1;
    for (let o = 0; o < s; o++) {
        let a = r(t[o], t[o + 1]);
        if (e) {
            const l = Array.isArray(e) ? e[o] || $n : e;
            a = _l(l, a)
        }
        i.push(a)
    }
    return i
}
function nA(t, e, {clamp: n=!0, ease: i, mixer: r}={}) {
    const s = t.length;
    if (wu(s === e.length),
    s === 1)
        return () => e[0];
    if (s === 2 && e[0] === e[1])
        return () => e[1];
    const o = t[0] === t[1];
    t[0] > t[s - 1] && (t = [...t].reverse(),
    e = [...e].reverse());
    const a = tA(e, i, r)
      , l = a.length
      , c = u => {
        if (o && u < t[0])
            return e[0];
        let d = 0;
        if (l > 1)
            for (; d < t.length - 2 && !(u < t[d + 1]); d++)
                ;
        const h = el(t[d], t[d + 1], u);
        return a[d](h)
    }
    ;
    return n ? u => c(qi(t[0], t[s - 1], u)) : c
}
function iA(t, e) {
    const n = t[t.length - 1];
    for (let i = 1; i <= e; i++) {
        const r = el(0, e, i);
        t.push(xt(n, 1, r))
    }
}
function rA(t) {
    const e = [0];
    return iA(e, t.length - 1),
    e
}
function sA(t, e) {
    return t.map(n => n * e)
}
function oA(t, e) {
    return t.map( () => e || iw).splice(0, t.length - 1)
}
function Pa({duration: t=300, keyframes: e, times: n, ease: i="easeInOut"}) {
    const r = _1(i) ? i.map(ov) : ov(i)
      , s = {
        done: !1,
        value: e[0]
    }
      , o = sA(n && n.length === e.length ? n : rA(e), t)
      , a = nA(o, e, {
        ease: Array.isArray(r) ? r : oA(e, r)
    });
    return {
        calculatedDuration: t,
        next: l => (s.value = a(l),
        s.done = l >= t,
        s)
    }
}
const aA = t => t !== null;
function lg(t, {repeat: e, repeatType: n="loop"}, i, r=1) {
    const s = t.filter(aA)
      , a = r < 0 || e && n !== "loop" && e % 2 === 1 ? 0 : s.length - 1;
    return !a || i === void 0 ? s[a] : i
}
const lA = {
    decay: If,
    inertia: If,
    tween: Pa,
    keyframes: Pa,
    spring: Tu
};
function gw(t) {
    typeof t.type == "string" && (t.type = lA[t.type])
}
class cg {
    constructor() {
        this.updateFinished()
    }
    get finished() {
        return this._finished
    }
    updateFinished() {
        this._finished = new Promise(e => {
            this.resolve = e
        }
        )
    }
    notifyFinished() {
        this.resolve()
    }
    then(e, n) {
        return this.finished.then(e, n)
    }
}
const cA = t => t / 100;
class ug extends cg {
    constructor(e) {
        super(),
        this.state = "idle",
        this.startTime = null,
        this.isStopped = !1,
        this.currentTime = 0,
        this.holdTime = null,
        this.playbackSpeed = 1,
        this.stop = () => {
            var i, r;
            const {motionValue: n} = this.options;
            n && n.updatedAt !== vn.now() && this.tick(vn.now()),
            this.isStopped = !0,
            this.state !== "idle" && (this.teardown(),
            (r = (i = this.options).onStop) == null || r.call(i))
        }
        ,
        this.options = e,
        this.initAnimation(),
        this.play(),
        e.autoplay === !1 && this.pause()
    }
    initAnimation() {
        const {options: e} = this;
        gw(e);
        const {type: n=Pa, repeat: i=0, repeatDelay: r=0, repeatType: s, velocity: o=0} = e;
        let {keyframes: a} = e;
        const l = n || Pa;
        l !== Pa && typeof a[0] != "number" && (this.mixKeyframes = _l(cA, fw(a[0], a[1])),
        a = [0, 100]);
        const c = l({
            ...e,
            keyframes: a
        });
        s === "mirror" && (this.mirroredGenerator = l({
            ...e,
            keyframes: [...a].reverse(),
            velocity: -o
        })),
        c.calculatedDuration === null && (c.calculatedDuration = ag(c));
        const {calculatedDuration: u} = c;
        this.calculatedDuration = u,
        this.resolvedDuration = u + r,
        this.totalDuration = this.resolvedDuration * (i + 1) - r,
        this.generator = c
    }
    updateTime(e) {
        const n = Math.round(e - this.startTime) * this.playbackSpeed;
        this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n
    }
    tick(e, n=!1) {
        const {generator: i, totalDuration: r, mixKeyframes: s, mirroredGenerator: o, resolvedDuration: a, calculatedDuration: l} = this;
        if (this.startTime === null)
            return i.next(0);
        const {delay: c=0, keyframes: u, repeat: d, repeatType: h, repeatDelay: p, type: v, onUpdate: x, finalKeyframe: g} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - r / this.speed, this.startTime)),
        n ? this.currentTime = e : this.updateTime(e);
        const f = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1)
          , y = this.playbackSpeed >= 0 ? f < 0 : f > r;
        this.currentTime = Math.max(f, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = r);
        let _ = this.currentTime
          , S = i;
        if (d) {
            const P = Math.min(this.currentTime, r) / a;
            let M = Math.floor(P)
              , b = P % 1;
            !b && P >= 1 && (b = 1),
            b === 1 && M--,
            M = Math.min(M, d + 1),
            !!(M % 2) && (h === "reverse" ? (b = 1 - b,
            p && (b -= p / a)) : h === "mirror" && (S = o)),
            _ = qi(0, 1, b) * a
        }
        const T = y ? {
            done: !1,
            value: u[0]
        } : S.next(_);
        s && (T.value = s(T.value));
        let {done: A} = T;
        !y && l !== null && (A = this.playbackSpeed >= 0 ? this.currentTime >= r : this.currentTime <= 0);
        const C = this.holdTime === null && (this.state === "finished" || this.state === "running" && A);
        return C && v !== If && (T.value = lg(u, this.options, g, this.speed)),
        x && x(T.value),
        C && this.finish(),
        T
    }
    then(e, n) {
        return this.finished.then(e, n)
    }
    get duration() {
        return Gn(this.calculatedDuration)
    }
    get iterationDuration() {
        const {delay: e=0} = this.options || {};
        return this.duration + Gn(e)
    }
    get time() {
        return Gn(this.currentTime)
    }
    set time(e) {
        var n;
        e = wi(e),
        this.currentTime = e,
        this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.playbackSpeed),
        (n = this.driver) == null || n.start(!1)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(e) {
        this.updateTime(vn.now());
        const n = this.playbackSpeed !== e;
        this.playbackSpeed = e,
        n && (this.time = Gn(this.currentTime))
    }
    play() {
        var r, s;
        if (this.isStopped)
            return;
        const {driver: e=$1, startTime: n} = this.options;
        this.driver || (this.driver = e(o => this.tick(o))),
        (s = (r = this.options).onPlay) == null || s.call(r);
        const i = this.driver.now();
        this.state === "finished" ? (this.updateFinished(),
        this.startTime = i) : this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime || (this.startTime = n ?? i),
        this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration),
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        this.state = "paused",
        this.updateTime(vn.now()),
        this.holdTime = this.currentTime
    }
    complete() {
        this.state !== "running" && this.play(),
        this.state = "finished",
        this.holdTime = null
    }
    finish() {
        var e, n;
        this.notifyFinished(),
        this.teardown(),
        this.state = "finished",
        (n = (e = this.options).onComplete) == null || n.call(e)
    }
    cancel() {
        var e, n;
        this.holdTime = null,
        this.startTime = 0,
        this.tick(0),
        this.teardown(),
        (n = (e = this.options).onCancel) == null || n.call(e)
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.startTime = this.holdTime = null
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(e) {
        return this.startTime = 0,
        this.tick(e, !0)
    }
    attachTimeline(e) {
        var n;
        return this.options.allowFlatten && (this.options.type = "keyframes",
        this.options.ease = "linear",
        this.initAnimation()),
        (n = this.driver) == null || n.stop(),
        e.observe(this)
    }
}
function uA(t) {
    for (let e = 1; e < t.length; e++)
        t[e] ?? (t[e] = t[e - 1])
}
const us = t => t * 180 / Math.PI
  , kf = t => {
    const e = us(Math.atan2(t[1], t[0]));
    return Uf(e)
}
  , dA = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: t => (Math.abs(t[0]) + Math.abs(t[3])) / 2,
    rotate: kf,
    rotateZ: kf,
    skewX: t => us(Math.atan(t[1])),
    skewY: t => us(Math.atan(t[2])),
    skew: t => (Math.abs(t[1]) + Math.abs(t[2])) / 2
}
  , Uf = t => (t = t % 360,
t < 0 && (t += 360),
t)
  , fv = kf
  , pv = t => Math.sqrt(t[0] * t[0] + t[1] * t[1])
  , mv = t => Math.sqrt(t[4] * t[4] + t[5] * t[5])
  , hA = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: pv,
    scaleY: mv,
    scale: t => (pv(t) + mv(t)) / 2,
    rotateX: t => Uf(us(Math.atan2(t[6], t[5]))),
    rotateY: t => Uf(us(Math.atan2(-t[2], t[0]))),
    rotateZ: fv,
    rotate: fv,
    skewX: t => us(Math.atan(t[4])),
    skewY: t => us(Math.atan(t[1])),
    skew: t => (Math.abs(t[1]) + Math.abs(t[4])) / 2
};
function Of(t) {
    return t.includes("scale") ? 1 : 0
}
function Ff(t, e) {
    if (!t || t === "none")
        return Of(e);
    const n = t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let i, r;
    if (n)
        i = hA,
        r = n;
    else {
        const a = t.match(/^matrix\(([-\d.e\s,]+)\)$/u);
        i = dA,
        r = a
    }
    if (!r)
        return Of(e);
    const s = i[e]
      , o = r[1].split(",").map(pA);
    return typeof s == "function" ? s(o) : o[s]
}
const fA = (t, e) => {
    const {transform: n="none"} = getComputedStyle(t);
    return Ff(n, e)
}
;
function pA(t) {
    return parseFloat(t.trim())
}
const Go = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , Wo = new Set(Go)
  , gv = t => t === Ho || t === De
  , mA = new Set(["x", "y", "z"])
  , gA = Go.filter(t => !mA.has(t));
function vA(t) {
    const e = [];
    return gA.forEach(n => {
        const i = t.getValue(n);
        i !== void 0 && (e.push([n, i.get()]),
        i.set(n.startsWith("scale") ? 1 : 0))
    }
    ),
    e
}
const ms = {
    width: ({x: t}, {paddingLeft: e="0", paddingRight: n="0"}) => t.max - t.min - parseFloat(e) - parseFloat(n),
    height: ({y: t}, {paddingTop: e="0", paddingBottom: n="0"}) => t.max - t.min - parseFloat(e) - parseFloat(n),
    top: (t, {top: e}) => parseFloat(e),
    left: (t, {left: e}) => parseFloat(e),
    bottom: ({y: t}, {top: e}) => parseFloat(e) + (t.max - t.min),
    right: ({x: t}, {left: e}) => parseFloat(e) + (t.max - t.min),
    x: (t, {transform: e}) => Ff(e, "x"),
    y: (t, {transform: e}) => Ff(e, "y")
};
ms.translateX = ms.x;
ms.translateY = ms.y;
const gs = new Set;
let Bf = !1
  , zf = !1
  , Vf = !1;
function vw() {
    if (zf) {
        const t = Array.from(gs).filter(i => i.needsMeasurement)
          , e = new Set(t.map(i => i.element))
          , n = new Map;
        e.forEach(i => {
            const r = vA(i);
            r.length && (n.set(i, r),
            i.render())
        }
        ),
        t.forEach(i => i.measureInitialState()),
        e.forEach(i => {
            i.render();
            const r = n.get(i);
            r && r.forEach( ([s,o]) => {
                var a;
                (a = i.getValue(s)) == null || a.set(o)
            }
            )
        }
        ),
        t.forEach(i => i.measureEndState()),
        t.forEach(i => {
            i.suspendedScrollY !== void 0 && window.scrollTo(0, i.suspendedScrollY)
        }
        )
    }
    zf = !1,
    Bf = !1,
    gs.forEach(t => t.complete(Vf)),
    gs.clear()
}
function _w() {
    gs.forEach(t => {
        t.readKeyframes(),
        t.needsMeasurement && (zf = !0)
    }
    )
}
function _A() {
    Vf = !0,
    _w(),
    vw(),
    Vf = !1
}
class dg {
    constructor(e, n, i, r, s, o=!1) {
        this.state = "pending",
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.unresolvedKeyframes = [...e],
        this.onComplete = n,
        this.name = i,
        this.motionValue = r,
        this.element = s,
        this.isAsync = o
    }
    scheduleResolve() {
        this.state = "scheduled",
        this.isAsync ? (gs.add(this),
        Bf || (Bf = !0,
        gt.read(_w),
        gt.resolveKeyframes(vw))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: e, name: n, element: i, motionValue: r} = this;
        if (e[0] === null) {
            const s = r == null ? void 0 : r.get()
              , o = e[e.length - 1];
            if (s !== void 0)
                e[0] = s;
            else if (i && n) {
                const a = i.readValue(n, o);
                a != null && (e[0] = a)
            }
            e[0] === void 0 && (e[0] = o),
            r && s === void 0 && r.set(e[0])
        }
        uA(e)
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete(e=!1) {
        this.state = "complete",
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e),
        gs.delete(this)
    }
    cancel() {
        this.state === "scheduled" && (gs.delete(this),
        this.state = "pending")
    }
    resume() {
        this.state === "pending" && this.scheduleResolve()
    }
}
const yA = t => t.startsWith("--");
function xA(t, e, n) {
    yA(e) ? t.style.setProperty(e, n) : t.style[e] = n
}
const SA = Jm( () => window.ScrollTimeline !== void 0)
  , wA = {};
function bA(t, e) {
    const n = Jm(t);
    return () => wA[e] ?? n()
}
const yw = bA( () => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}
, "linearEasing")
  , va = ([t,e,n,i]) => `cubic-bezier(${t}, ${e}, ${n}, ${i})`
  , vv = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: va([0, .65, .55, 1]),
    circOut: va([.55, 0, 1, .45]),
    backIn: va([.31, .01, .66, -.59]),
    backOut: va([.33, 1.53, .69, .99])
};
function xw(t, e) {
    if (t)
        return typeof t == "function" ? yw() ? pw(t, e) : "ease-out" : rw(t) ? va(t) : Array.isArray(t) ? t.map(n => xw(n, e) || vv.easeOut) : vv[t]
}
function EA(t, e, n, {delay: i=0, duration: r=300, repeat: s=0, repeatType: o="loop", ease: a="easeOut", times: l}={}, c=void 0) {
    const u = {
        [e]: n
    };
    l && (u.offset = l);
    const d = xw(a, r);
    Array.isArray(d) && (u.easing = d);
    const h = {
        delay: i,
        duration: r,
        easing: Array.isArray(d) ? "linear" : d,
        fill: "both",
        iterations: s + 1,
        direction: o === "reverse" ? "alternate" : "normal"
    };
    return c && (h.pseudoElement = c),
    t.animate(u, h)
}
function Sw(t) {
    return typeof t == "function" && "applyToOptions"in t
}
function TA({type: t, ...e}) {
    return Sw(t) && yw() ? t.applyToOptions(e) : (e.duration ?? (e.duration = 300),
    e.ease ?? (e.ease = "easeOut"),
    e)
}
class MA extends cg {
    constructor(e) {
        if (super(),
        this.finishedTime = null,
        this.isStopped = !1,
        !e)
            return;
        const {element: n, name: i, keyframes: r, pseudoElement: s, allowFlatten: o=!1, finalKeyframe: a, onComplete: l} = e;
        this.isPseudoElement = !!s,
        this.allowFlatten = o,
        this.options = e,
        wu(typeof e.type != "string");
        const c = TA(e);
        this.animation = EA(n, i, r, c, s),
        c.autoplay === !1 && this.animation.pause(),
        this.animation.onfinish = () => {
            if (this.finishedTime = this.time,
            !s) {
                const u = lg(r, this.options, a, this.speed);
                this.updateMotionValue ? this.updateMotionValue(u) : xA(n, i, u),
                this.animation.cancel()
            }
            l == null || l(),
            this.notifyFinished()
        }
    }
    play() {
        this.isStopped || (this.animation.play(),
        this.state === "finished" && this.updateFinished())
    }
    pause() {
        this.animation.pause()
    }
    complete() {
        var e, n;
        (n = (e = this.animation).finish) == null || n.call(e)
    }
    cancel() {
        try {
            this.animation.cancel()
        } catch {}
    }
    stop() {
        if (this.isStopped)
            return;
        this.isStopped = !0;
        const {state: e} = this;
        e === "idle" || e === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
        this.isPseudoElement || this.cancel())
    }
    commitStyles() {
        var e, n;
        this.isPseudoElement || (n = (e = this.animation).commitStyles) == null || n.call(e)
    }
    get duration() {
        var n, i;
        const e = ((i = (n = this.animation.effect) == null ? void 0 : n.getComputedTiming) == null ? void 0 : i.call(n).duration) || 0;
        return Gn(Number(e))
    }
    get iterationDuration() {
        const {delay: e=0} = this.options || {};
        return this.duration + Gn(e)
    }
    get time() {
        return Gn(Number(this.animation.currentTime) || 0)
    }
    set time(e) {
        this.finishedTime = null,
        this.animation.currentTime = wi(e)
    }
    get speed() {
        return this.animation.playbackRate
    }
    set speed(e) {
        e < 0 && (this.finishedTime = null),
        this.animation.playbackRate = e
    }
    get state() {
        return this.finishedTime !== null ? "finished" : this.animation.playState
    }
    get startTime() {
        return Number(this.animation.startTime)
    }
    set startTime(e) {
        this.animation.startTime = e
    }
    attachTimeline({timeline: e, observe: n}) {
        var i;
        return this.allowFlatten && ((i = this.animation.effect) == null || i.updateTiming({
            easing: "linear"
        })),
        this.animation.onfinish = null,
        e && SA() ? (this.animation.timeline = e,
        $n) : n(this)
    }
}
const ww = {
    anticipate: ew,
    backInOut: QS,
    circInOut: nw
};
function AA(t) {
    return t in ww
}
function CA(t) {
    typeof t.ease == "string" && AA(t.ease) && (t.ease = ww[t.ease])
}
const _v = 10;
class RA extends MA {
    constructor(e) {
        CA(e),
        gw(e),
        super(e),
        e.startTime && (this.startTime = e.startTime),
        this.options = e
    }
    updateMotionValue(e) {
        const {motionValue: n, onUpdate: i, onComplete: r, element: s, ...o} = this.options;
        if (!n)
            return;
        if (e !== void 0) {
            n.set(e);
            return
        }
        const a = new ug({
            ...o,
            autoplay: !1
        })
          , l = wi(this.finishedTime ?? this.time);
        n.setWithVelocity(a.sample(l - _v).value, a.sample(l).value, _v),
        a.stop()
    }
}
const yv = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (Dr.test(t) || t === "0") && !t.startsWith("url("));
function PA(t) {
    const e = t[0];
    if (t.length === 1)
        return !0;
    for (let n = 0; n < t.length; n++)
        if (t[n] !== e)
            return !0
}
function NA(t, e, n, i) {
    const r = t[0];
    if (r === null)
        return !1;
    if (e === "display" || e === "visibility")
        return !0;
    const s = t[t.length - 1]
      , o = yv(r, e)
      , a = yv(s, e);
    return !o || !a ? !1 : PA(t) || (n === "spring" || Sw(n)) && i
}
function jf(t) {
    t.duration = 0,
    t.type = "keyframes"
}
const DA = new Set(["opacity", "clipPath", "filter", "transform"])
  , LA = Jm( () => Object.hasOwnProperty.call(Element.prototype, "animate"));
function IA(t) {
    var u;
    const {motionValue: e, name: n, repeatDelay: i, repeatType: r, damping: s, type: o} = t;
    if (!(((u = e == null ? void 0 : e.owner) == null ? void 0 : u.current)instanceof HTMLElement))
        return !1;
    const {onUpdate: l, transformTemplate: c} = e.owner.getProps();
    return LA() && n && DA.has(n) && (n !== "transform" || !c) && !l && !i && r !== "mirror" && s !== 0 && o !== "inertia"
}
const kA = 40;
class UA extends cg {
    constructor({autoplay: e=!0, delay: n=0, type: i="keyframes", repeat: r=0, repeatDelay: s=0, repeatType: o="loop", keyframes: a, name: l, motionValue: c, element: u, ...d}) {
        var v;
        super(),
        this.stop = () => {
            var x, g;
            this._animation && (this._animation.stop(),
            (x = this.stopTimeline) == null || x.call(this)),
            (g = this.keyframeResolver) == null || g.cancel()
        }
        ,
        this.createdAt = vn.now();
        const h = {
            autoplay: e,
            delay: n,
            type: i,
            repeat: r,
            repeatDelay: s,
            repeatType: o,
            name: l,
            motionValue: c,
            element: u,
            ...d
        }
          , p = (u == null ? void 0 : u.KeyframeResolver) || dg;
        this.keyframeResolver = new p(a, (x, g, f) => this.onKeyframesResolved(x, g, h, !f),l,c,u),
        (v = this.keyframeResolver) == null || v.scheduleResolve()
    }
    onKeyframesResolved(e, n, i, r) {
        this.keyframeResolver = void 0;
        const {name: s, type: o, velocity: a, delay: l, isHandoff: c, onUpdate: u} = i;
        this.resolvedAt = vn.now(),
        NA(e, s, o, a) || ((Ki.instantAnimations || !l) && (u == null || u(lg(e, i, n))),
        e[0] = e[e.length - 1],
        jf(i),
        i.repeat = 0);
        const h = {
            startTime: r ? this.resolvedAt ? this.resolvedAt - this.createdAt > kA ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
            finalKeyframe: n,
            ...i,
            keyframes: e
        }
          , p = !c && IA(h) ? new RA({
            ...h,
            element: h.motionValue.owner.current
        }) : new ug(h);
        p.finished.then( () => this.notifyFinished()).catch($n),
        this.pendingTimeline && (this.stopTimeline = p.attachTimeline(this.pendingTimeline),
        this.pendingTimeline = void 0),
        this._animation = p
    }
    get finished() {
        return this._animation ? this.animation.finished : this._finished
    }
    then(e, n) {
        return this.finished.finally(e).then( () => {}
        )
    }
    get animation() {
        var e;
        return this._animation || ((e = this.keyframeResolver) == null || e.resume(),
        _A()),
        this._animation
    }
    get duration() {
        return this.animation.duration
    }
    get iterationDuration() {
        return this.animation.iterationDuration
    }
    get time() {
        return this.animation.time
    }
    set time(e) {
        this.animation.time = e
    }
    get speed() {
        return this.animation.speed
    }
    get state() {
        return this.animation.state
    }
    set speed(e) {
        this.animation.speed = e
    }
    get startTime() {
        return this.animation.startTime
    }
    attachTimeline(e) {
        return this._animation ? this.stopTimeline = this.animation.attachTimeline(e) : this.pendingTimeline = e,
        () => this.stop()
    }
    play() {
        this.animation.play()
    }
    pause() {
        this.animation.pause()
    }
    complete() {
        this.animation.complete()
    }
    cancel() {
        var e;
        this._animation && this.animation.cancel(),
        (e = this.keyframeResolver) == null || e.cancel()
    }
}
const OA = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function FA(t) {
    const e = OA.exec(t);
    if (!e)
        return [, ];
    const [,n,i,r] = e;
    return [`--${n ?? i}`, r]
}
function bw(t, e, n=1) {
    const [i,r] = FA(t);
    if (!i)
        return;
    const s = window.getComputedStyle(e).getPropertyValue(i);
    if (s) {
        const o = s.trim();
        return WS(o) ? parseFloat(o) : o
    }
    return ig(r) ? bw(r, e, n + 1) : r
}
function hg(t, e) {
    return (t == null ? void 0 : t[e]) ?? (t == null ? void 0 : t.default) ?? t
}
const Ew = new Set(["width", "height", "top", "left", "right", "bottom", ...Go])
  , BA = {
    test: t => t === "auto",
    parse: t => t
}
  , Tw = t => e => e.test(t)
  , Mw = [Ho, De, bi, cr, P1, R1, BA]
  , xv = t => Mw.find(Tw(t));
function zA(t) {
    return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || XS(t) : !0
}
const VA = new Set(["brightness", "contrast", "saturate", "opacity"]);
function jA(t) {
    const [e,n] = t.slice(0, -1).split("(");
    if (e === "drop-shadow")
        return t;
    const [i] = n.match(rg) || [];
    if (!i)
        return t;
    const r = n.replace(i, "");
    let s = VA.has(e) ? 1 : 0;
    return i !== n && (s *= 100),
    e + "(" + s + r + ")"
}
const HA = /\b([a-z-]*)\(.*?\)/gu
  , Hf = {
    ...Dr,
    getAnimatableNone: t => {
        const e = t.match(HA);
        return e ? e.map(jA).join(" ") : t
    }
}
  , Sv = {
    ...Ho,
    transform: Math.round
}
  , GA = {
    rotate: cr,
    rotateX: cr,
    rotateY: cr,
    rotateZ: cr,
    scale: Ql,
    scaleX: Ql,
    scaleY: Ql,
    scaleZ: Ql,
    skew: cr,
    skewX: cr,
    skewY: cr,
    distance: De,
    translateX: De,
    translateY: De,
    translateZ: De,
    x: De,
    y: De,
    z: De,
    perspective: De,
    transformPerspective: De,
    opacity: tl,
    originX: lv,
    originY: lv,
    originZ: De
}
  , fg = {
    borderWidth: De,
    borderTopWidth: De,
    borderRightWidth: De,
    borderBottomWidth: De,
    borderLeftWidth: De,
    borderRadius: De,
    radius: De,
    borderTopLeftRadius: De,
    borderTopRightRadius: De,
    borderBottomRightRadius: De,
    borderBottomLeftRadius: De,
    width: De,
    maxWidth: De,
    height: De,
    maxHeight: De,
    top: De,
    right: De,
    bottom: De,
    left: De,
    padding: De,
    paddingTop: De,
    paddingRight: De,
    paddingBottom: De,
    paddingLeft: De,
    margin: De,
    marginTop: De,
    marginRight: De,
    marginBottom: De,
    marginLeft: De,
    backgroundPositionX: De,
    backgroundPositionY: De,
    ...GA,
    zIndex: Sv,
    fillOpacity: tl,
    strokeOpacity: tl,
    numOctaves: Sv
}
  , WA = {
    ...fg,
    color: Nt,
    backgroundColor: Nt,
    outlineColor: Nt,
    fill: Nt,
    stroke: Nt,
    borderColor: Nt,
    borderTopColor: Nt,
    borderRightColor: Nt,
    borderBottomColor: Nt,
    borderLeftColor: Nt,
    filter: Hf,
    WebkitFilter: Hf
}
  , Aw = t => WA[t];
function Cw(t, e) {
    let n = Aw(t);
    return n !== Hf && (n = Dr),
    n.getAnimatableNone ? n.getAnimatableNone(e) : void 0
}
const $A = new Set(["auto", "none", "0"]);
function XA(t, e, n) {
    let i = 0, r;
    for (; i < t.length && !r; ) {
        const s = t[i];
        typeof s == "string" && !$A.has(s) && nl(s).values.length && (r = t[i]),
        i++
    }
    if (r && n)
        for (const s of e)
            t[s] = Cw(n, r)
}
class qA extends dg {
    constructor(e, n, i, r, s) {
        super(e, n, i, r, s, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: e, element: n, name: i} = this;
        if (!n || !n.current)
            return;
        super.readKeyframes();
        for (let l = 0; l < e.length; l++) {
            let c = e[l];
            if (typeof c == "string" && (c = c.trim(),
            ig(c))) {
                const u = bw(c, n.current);
                u !== void 0 && (e[l] = u),
                l === e.length - 1 && (this.finalKeyframe = c)
            }
        }
        if (this.resolveNoneKeyframes(),
        !Ew.has(i) || e.length !== 2)
            return;
        const [r,s] = e
          , o = xv(r)
          , a = xv(s);
        if (o !== a)
            if (gv(o) && gv(a))
                for (let l = 0; l < e.length; l++) {
                    const c = e[l];
                    typeof c == "string" && (e[l] = parseFloat(c))
                }
            else
                ms[i] && (this.needsMeasurement = !0)
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: e, name: n} = this
          , i = [];
        for (let r = 0; r < e.length; r++)
            (e[r] === null || zA(e[r])) && i.push(r);
        i.length && XA(e, i, n)
    }
    measureInitialState() {
        const {element: e, unresolvedKeyframes: n, name: i} = this;
        if (!e || !e.current)
            return;
        i === "height" && (this.suspendedScrollY = window.pageYOffset),
        this.measuredOrigin = ms[i](e.measureViewportBox(), window.getComputedStyle(e.current)),
        n[0] = this.measuredOrigin;
        const r = n[n.length - 1];
        r !== void 0 && e.getValue(i, r).jump(r, !1)
    }
    measureEndState() {
        var a;
        const {element: e, name: n, unresolvedKeyframes: i} = this;
        if (!e || !e.current)
            return;
        const r = e.getValue(n);
        r && r.jump(this.measuredOrigin, !1);
        const s = i.length - 1
          , o = i[s];
        i[s] = ms[n](e.measureViewportBox(), window.getComputedStyle(e.current)),
        o !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = o),
        (a = this.removedTransforms) != null && a.length && this.removedTransforms.forEach( ([l,c]) => {
            e.getValue(l).set(c)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
function KA(t, e, n) {
    if (t instanceof EventTarget)
        return [t];
    if (typeof t == "string") {
        const r = document.querySelectorAll(t);
        return r ? Array.from(r) : []
    }
    return Array.from(t)
}
const Rw = (t, e) => e && typeof t == "number" ? e.transform(t) : t;
function YA(t) {
    return $S(t) && "offsetHeight"in t
}
const wv = 30
  , ZA = t => !isNaN(parseFloat(t));
class JA {
    constructor(e, n={}) {
        this.canTrackVelocity = null,
        this.events = {},
        this.updateAndNotify = i => {
            var s;
            const r = vn.now();
            if (this.updatedAt !== r && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(i),
            this.current !== this.prev && ((s = this.events.change) == null || s.notify(this.current),
            this.dependents))
                for (const o of this.dependents)
                    o.dirty()
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(e),
        this.owner = n.owner
    }
    setCurrent(e) {
        this.current = e,
        this.updatedAt = vn.now(),
        this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = ZA(this.current))
    }
    setPrevFrameValue(e=this.current) {
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, n) {
        this.events[e] || (this.events[e] = new Qm);
        const i = this.events[e].add(n);
        return e === "change" ? () => {
            i(),
            gt.read( () => {
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : i
    }
    clearListeners() {
        for (const e in this.events)
            this.events[e].clear()
    }
    attach(e, n) {
        this.passiveEffect = e,
        this.stopPassiveEffect = n
    }
    set(e) {
        this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e)
    }
    setWithVelocity(e, n, i) {
        this.set(n),
        this.prev = void 0,
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt - i
    }
    jump(e, n=!0) {
        this.updateAndNotify(e),
        this.prev = e,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        n && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    dirty() {
        var e;
        (e = this.events.change) == null || e.notify(this.current)
    }
    addDependent(e) {
        this.dependents || (this.dependents = new Set),
        this.dependents.add(e)
    }
    removeDependent(e) {
        this.dependents && this.dependents.delete(e)
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const e = vn.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > wv)
            return 0;
        const n = Math.min(this.updatedAt - this.prevUpdatedAt, wv);
        return qS(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
    }
    start(e) {
        return this.stop(),
        new Promise(n => {
            this.hasAnimated = !0,
            this.animation = e(n),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then( () => {
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        var e, n;
        (e = this.dependents) == null || e.clear(),
        (n = this.events.destroy) == null || n.notify(),
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function Do(t, e) {
    return new JA(t,e)
}
const {schedule: pg, cancel: wO} = sw(queueMicrotask, !1)
  , ti = {
    x: !1,
    y: !1
};
function Pw() {
    return ti.x || ti.y
}
function QA(t) {
    return t === "x" || t === "y" ? ti[t] ? null : (ti[t] = !0,
    () => {
        ti[t] = !1
    }
    ) : ti.x || ti.y ? null : (ti.x = ti.y = !0,
    () => {
        ti.x = ti.y = !1
    }
    )
}
function Nw(t, e) {
    const n = KA(t)
      , i = new AbortController
      , r = {
        passive: !0,
        ...e,
        signal: i.signal
    };
    return [n, r, () => i.abort()]
}
function bv(t) {
    return !(t.pointerType === "touch" || Pw())
}
function eC(t, e, n={}) {
    const [i,r,s] = Nw(t, n)
      , o = a => {
        if (!bv(a))
            return;
        const {target: l} = a
          , c = e(l, a);
        if (typeof c != "function" || !l)
            return;
        const u = d => {
            bv(d) && (c(d),
            l.removeEventListener("pointerleave", u))
        }
        ;
        l.addEventListener("pointerleave", u, r)
    }
    ;
    return i.forEach(a => {
        a.addEventListener("pointerenter", o, r)
    }
    ),
    s
}
const Dw = (t, e) => e ? t === e ? !0 : Dw(t, e.parentElement) : !1
  , mg = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1
  , tC = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function nC(t) {
    return tC.has(t.tagName) || t.tabIndex !== -1
}
const jc = new WeakSet;
function Ev(t) {
    return e => {
        e.key === "Enter" && t(e)
    }
}
function Hd(t, e) {
    t.dispatchEvent(new PointerEvent("pointer" + e,{
        isPrimary: !0,
        bubbles: !0
    }))
}
const iC = (t, e) => {
    const n = t.currentTarget;
    if (!n)
        return;
    const i = Ev( () => {
        if (jc.has(n))
            return;
        Hd(n, "down");
        const r = Ev( () => {
            Hd(n, "up")
        }
        )
          , s = () => Hd(n, "cancel");
        n.addEventListener("keyup", r, e),
        n.addEventListener("blur", s, e)
    }
    );
    n.addEventListener("keydown", i, e),
    n.addEventListener("blur", () => n.removeEventListener("keydown", i), e)
}
;
function Tv(t) {
    return mg(t) && !Pw()
}
function rC(t, e, n={}) {
    const [i,r,s] = Nw(t, n)
      , o = a => {
        const l = a.currentTarget;
        if (!Tv(a))
            return;
        jc.add(l);
        const c = e(l, a)
          , u = (p, v) => {
            window.removeEventListener("pointerup", d),
            window.removeEventListener("pointercancel", h),
            jc.has(l) && jc.delete(l),
            Tv(p) && typeof c == "function" && c(p, {
                success: v
            })
        }
          , d = p => {
            u(p, l === window || l === document || n.useGlobalTarget || Dw(l, p.target))
        }
          , h = p => {
            u(p, !1)
        }
        ;
        window.addEventListener("pointerup", d, r),
        window.addEventListener("pointercancel", h, r)
    }
    ;
    return i.forEach(a => {
        (n.useGlobalTarget ? window : a).addEventListener("pointerdown", o, r),
        YA(a) && (a.addEventListener("focus", c => iC(c, r)),
        !nC(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0))
    }
    ),
    s
}
function Lw(t) {
    return $S(t) && "ownerSVGElement"in t
}
function sC(t) {
    return Lw(t) && t.tagName === "svg"
}
const tn = t => !!(t && t.getVelocity)
  , oC = [...Mw, Nt, Dr]
  , aC = t => oC.find(Tw(t))
  , Iw = oe.createContext({
    transformPagePoint: t => t,
    isStatic: !1,
    reducedMotion: "never"
});
function lC(t=!0) {
    const e = oe.useContext(Km);
    if (e === null)
        return [!0, null];
    const {isPresent: n, onExitComplete: i, register: r} = e
      , s = oe.useId();
    oe.useEffect( () => {
        if (t)
            return r(s)
    }
    , [t]);
    const o = oe.useCallback( () => t && i && i(s), [s, i, t]);
    return !n && i ? [!1, o] : [!0]
}
const kw = oe.createContext({
    strict: !1
})
  , Mv = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , Lo = {};
for (const t in Mv)
    Lo[t] = {
        isEnabled: e => Mv[t].some(n => !!e[n])
    };
function cC(t) {
    for (const e in t)
        Lo[e] = {
            ...Lo[e],
            ...t[e]
        }
}
const uC = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function Mu(t) {
    return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || uC.has(t)
}
let Uw = t => !Mu(t);
function dC(t) {
    typeof t == "function" && (Uw = e => e.startsWith("on") ? !Mu(e) : t(e))
}
try {
    dC(require("@emotion/is-prop-valid").default)
} catch {}
function hC(t, e, n) {
    const i = {};
    for (const r in t)
        r === "values" && typeof t.values == "object" || (Uw(r) || n === !0 && Mu(r) || !e && !Mu(r) || t.draggable && r.startsWith("onDrag")) && (i[r] = t[r]);
    return i
}
const Ku = oe.createContext({});
function Yu(t) {
    return t !== null && typeof t == "object" && typeof t.start == "function"
}
function il(t) {
    return typeof t == "string" || Array.isArray(t)
}
const gg = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , vg = ["initial", ...gg];
function Zu(t) {
    return Yu(t.animate) || vg.some(e => il(t[e]))
}
function Ow(t) {
    return !!(Zu(t) || t.variants)
}
function fC(t, e) {
    if (Zu(t)) {
        const {initial: n, animate: i} = t;
        return {
            initial: n === !1 || il(n) ? n : void 0,
            animate: il(i) ? i : void 0
        }
    }
    return t.inherit !== !1 ? e : {}
}
function pC(t) {
    const {initial: e, animate: n} = fC(t, oe.useContext(Ku));
    return oe.useMemo( () => ({
        initial: e,
        animate: n
    }), [Av(e), Av(n)])
}
function Av(t) {
    return Array.isArray(t) ? t.join(" ") : t
}
const rl = {};
function mC(t) {
    for (const e in t)
        rl[e] = t[e],
        ng(e) && (rl[e].isCSSVariable = !0)
}
function Fw(t, {layout: e, layoutId: n}) {
    return Wo.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!rl[t] || t === "opacity")
}
const gC = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , vC = Go.length;
function _C(t, e, n) {
    let i = ""
      , r = !0;
    for (let s = 0; s < vC; s++) {
        const o = Go[s]
          , a = t[o];
        if (a === void 0)
            continue;
        let l = !0;
        if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0,
        !l || n) {
            const c = Rw(a, fg[o]);
            if (!l) {
                r = !1;
                const u = gC[o] || o;
                i += `${u}(${c}) `
            }
            n && (e[o] = c)
        }
    }
    return i = i.trim(),
    n ? i = n(e, r ? "" : i) : r && (i = "none"),
    i
}
function _g(t, e, n) {
    const {style: i, vars: r, transformOrigin: s} = t;
    let o = !1
      , a = !1;
    for (const l in e) {
        const c = e[l];
        if (Wo.has(l)) {
            o = !0;
            continue
        } else if (ng(l)) {
            r[l] = c;
            continue
        } else {
            const u = Rw(c, fg[l]);
            l.startsWith("origin") ? (a = !0,
            s[l] = u) : i[l] = u
        }
    }
    if (e.transform || (o || n ? i.transform = _C(e, t.transform, n) : i.transform && (i.transform = "none")),
    a) {
        const {originX: l="50%", originY: c="50%", originZ: u=0} = s;
        i.transformOrigin = `${l} ${c} ${u}`
    }
}
const yg = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function Bw(t, e, n) {
    for (const i in e)
        !tn(e[i]) && !Fw(i, n) && (t[i] = e[i])
}
function yC({transformTemplate: t}, e) {
    return oe.useMemo( () => {
        const n = yg();
        return _g(n, e, t),
        Object.assign({}, n.vars, n.style)
    }
    , [e])
}
function xC(t, e) {
    const n = t.style || {}
      , i = {};
    return Bw(i, n, t),
    Object.assign(i, yC(t, e)),
    i
}
function SC(t, e) {
    const n = {}
      , i = xC(t, e);
    return t.drag && t.dragListener !== !1 && (n.draggable = !1,
    i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none",
    i.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`),
    t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0),
    n.style = i,
    n
}
const wC = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , bC = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function EC(t, e, n=1, i=0, r=!0) {
    t.pathLength = 1;
    const s = r ? wC : bC;
    t[s.offset] = De.transform(-i);
    const o = De.transform(e)
      , a = De.transform(n);
    t[s.array] = `${o} ${a}`
}
function zw(t, {attrX: e, attrY: n, attrScale: i, pathLength: r, pathSpacing: s=1, pathOffset: o=0, ...a}, l, c, u) {
    if (_g(t, a, c),
    l) {
        t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
        return
    }
    t.attrs = t.style,
    t.style = {};
    const {attrs: d, style: h} = t;
    d.transform && (h.transform = d.transform,
    delete d.transform),
    (h.transform || d.transformOrigin) && (h.transformOrigin = d.transformOrigin ?? "50% 50%",
    delete d.transformOrigin),
    h.transform && (h.transformBox = (u == null ? void 0 : u.transformBox) ?? "fill-box",
    delete d.transformBox),
    e !== void 0 && (d.x = e),
    n !== void 0 && (d.y = n),
    i !== void 0 && (d.scale = i),
    r !== void 0 && EC(d, r, s, o, !1)
}
const Vw = () => ({
    ...yg(),
    attrs: {}
})
  , jw = t => typeof t == "string" && t.toLowerCase() === "svg";
function TC(t, e, n, i) {
    const r = oe.useMemo( () => {
        const s = Vw();
        return zw(s, e, jw(i), t.transformTemplate, t.style),
        {
            ...s.attrs,
            style: {
                ...s.style
            }
        }
    }
    , [e]);
    if (t.style) {
        const s = {};
        Bw(s, t.style, t),
        r.style = {
            ...s,
            ...r.style
        }
    }
    return r
}
const MC = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function xg(t) {
    return typeof t != "string" || t.includes("-") ? !1 : !!(MC.indexOf(t) > -1 || /[A-Z]/u.test(t))
}
function AC(t, e, n, {latestValues: i}, r, s=!1) {
    const a = (xg(t) ? TC : SC)(e, i, r, t)
      , l = hC(e, typeof t == "string", s)
      , c = t !== oe.Fragment ? {
        ...l,
        ...a,
        ref: n
    } : {}
      , {children: u} = e
      , d = oe.useMemo( () => tn(u) ? u.get() : u, [u]);
    return oe.createElement(t, {
        ...c,
        children: d
    })
}
function Cv(t) {
    const e = [{}, {}];
    return t == null || t.values.forEach( (n, i) => {
        e[0][i] = n.get(),
        e[1][i] = n.getVelocity()
    }
    ),
    e
}
function Sg(t, e, n, i) {
    if (typeof e == "function") {
        const [r,s] = Cv(i);
        e = e(n !== void 0 ? n : t.custom, r, s)
    }
    if (typeof e == "string" && (e = t.variants && t.variants[e]),
    typeof e == "function") {
        const [r,s] = Cv(i);
        e = e(n !== void 0 ? n : t.custom, r, s)
    }
    return e
}
function Hc(t) {
    return tn(t) ? t.get() : t
}
function CC({scrapeMotionValuesFromProps: t, createRenderState: e}, n, i, r) {
    return {
        latestValues: RC(n, i, r, t),
        renderState: e()
    }
}
function RC(t, e, n, i) {
    const r = {}
      , s = i(t, {});
    for (const h in s)
        r[h] = Hc(s[h]);
    let {initial: o, animate: a} = t;
    const l = Zu(t)
      , c = Ow(t);
    e && c && !l && t.inherit !== !1 && (o === void 0 && (o = e.initial),
    a === void 0 && (a = e.animate));
    let u = n ? n.initial === !1 : !1;
    u = u || o === !1;
    const d = u ? a : o;
    if (d && typeof d != "boolean" && !Yu(d)) {
        const h = Array.isArray(d) ? d : [d];
        for (let p = 0; p < h.length; p++) {
            const v = Sg(t, h[p]);
            if (v) {
                const {transitionEnd: x, transition: g, ...f} = v;
                for (const y in f) {
                    let _ = f[y];
                    if (Array.isArray(_)) {
                        const S = u ? _.length - 1 : 0;
                        _ = _[S]
                    }
                    _ !== null && (r[y] = _)
                }
                for (const y in x)
                    r[y] = x[y]
            }
        }
    }
    return r
}
const Hw = t => (e, n) => {
    const i = oe.useContext(Ku)
      , r = oe.useContext(Km)
      , s = () => CC(t, e, i, r);
    return n ? s() : u1(s)
}
;
function wg(t, e, n) {
    var s;
    const {style: i} = t
      , r = {};
    for (const o in i)
        (tn(i[o]) || e.style && tn(e.style[o]) || Fw(o, t) || ((s = n == null ? void 0 : n.getValue(o)) == null ? void 0 : s.liveStyle) !== void 0) && (r[o] = i[o]);
    return r
}
const PC = Hw({
    scrapeMotionValuesFromProps: wg,
    createRenderState: yg
});
function Gw(t, e, n) {
    const i = wg(t, e, n);
    for (const r in t)
        if (tn(t[r]) || tn(e[r])) {
            const s = Go.indexOf(r) !== -1 ? "attr" + r.charAt(0).toUpperCase() + r.substring(1) : r;
            i[s] = t[r]
        }
    return i
}
const NC = Hw({
    scrapeMotionValuesFromProps: Gw,
    createRenderState: Vw
})
  , DC = Symbol.for("motionComponentSymbol");
function uo(t) {
    return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current")
}
function LC(t, e, n) {
    return oe.useCallback(i => {
        i && t.onMount && t.onMount(i),
        e && (i ? e.mount(i) : e.unmount()),
        n && (typeof n == "function" ? n(i) : uo(n) && (n.current = i))
    }
    , [e])
}
const bg = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , IC = "framerAppearId"
  , Ww = "data-" + bg(IC)
  , $w = oe.createContext({});
function kC(t, e, n, i, r) {
    var x, g;
    const {visualElement: s} = oe.useContext(Ku)
      , o = oe.useContext(kw)
      , a = oe.useContext(Km)
      , l = oe.useContext(Iw).reducedMotion
      , c = oe.useRef(null);
    i = i || o.renderer,
    !c.current && i && (c.current = i(t, {
        visualState: e,
        parent: s,
        props: n,
        presenceContext: a,
        blockInitialAnimation: a ? a.initial === !1 : !1,
        reducedMotionConfig: l
    }));
    const u = c.current
      , d = oe.useContext($w);
    u && !u.projection && r && (u.type === "html" || u.type === "svg") && UC(c.current, n, r, d);
    const h = oe.useRef(!1);
    oe.useInsertionEffect( () => {
        u && h.current && u.update(n, a)
    }
    );
    const p = n[Ww]
      , v = oe.useRef(!!p && !((x = window.MotionHandoffIsComplete) != null && x.call(window, p)) && ((g = window.MotionHasOptimisedAnimation) == null ? void 0 : g.call(window, p)));
    return d1( () => {
        u && (h.current = !0,
        window.MotionIsMounted = !0,
        u.updateFeatures(),
        u.scheduleRenderMicrotask(),
        v.current && u.animationState && u.animationState.animateChanges())
    }
    ),
    oe.useEffect( () => {
        u && (!v.current && u.animationState && u.animationState.animateChanges(),
        v.current && (queueMicrotask( () => {
            var f;
            (f = window.MotionHandoffMarkAsComplete) == null || f.call(window, p)
        }
        ),
        v.current = !1),
        u.enteringChildren = void 0)
    }
    ),
    u
}
function UC(t, e, n, i) {
    const {layoutId: r, layout: s, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: c, layoutCrossfade: u} = e;
    t.projection = new n(t.latestValues,e["data-framer-portal-id"] ? void 0 : Xw(t.parent)),
    t.projection.setOptions({
        layoutId: r,
        layout: s,
        alwaysMeasureLayout: !!o || a && uo(a),
        visualElement: t,
        animationType: typeof s == "string" ? s : "both",
        initialPromotionConfig: i,
        crossfade: u,
        layoutScroll: l,
        layoutRoot: c
    })
}
function Xw(t) {
    if (t)
        return t.options.allowProjection !== !1 ? t.projection : Xw(t.parent)
}
function Gd(t, {forwardMotionProps: e=!1}={}, n, i) {
    n && cC(n);
    const r = xg(t) ? NC : PC;
    function s(a, l) {
        let c;
        const u = {
            ...oe.useContext(Iw),
            ...a,
            layoutId: OC(a)
        }
          , {isStatic: d} = u
          , h = pC(a)
          , p = r(a, d);
        if (!d && qm) {
            FC();
            const v = BC(u);
            c = v.MeasureLayout,
            h.visualElement = kC(t, p, u, i, v.ProjectionNode)
        }
        return m.jsxs(Ku.Provider, {
            value: h,
            children: [c && h.visualElement ? m.jsx(c, {
                visualElement: h.visualElement,
                ...u
            }) : null, AC(t, a, LC(p, h.visualElement, l), p, d, e)]
        })
    }
    s.displayName = `motion.${typeof t == "string" ? t : `create(${t.displayName ?? t.name ?? ""})`}`;
    const o = oe.forwardRef(s);
    return o[DC] = t,
    o
}
function OC({layoutId: t}) {
    const e = oe.useContext(GS).id;
    return e && t !== void 0 ? e + "-" + t : t
}
function FC(t, e) {
    oe.useContext(kw).strict
}
function BC(t) {
    const {drag: e, layout: n} = Lo;
    if (!e && !n)
        return {};
    const i = {
        ...e,
        ...n
    };
    return {
        MeasureLayout: e != null && e.isEnabled(t) || n != null && n.isEnabled(t) ? i.MeasureLayout : void 0,
        ProjectionNode: i.ProjectionNode
    }
}
function zC(t, e) {
    if (typeof Proxy > "u")
        return Gd;
    const n = new Map
      , i = (s, o) => Gd(s, o, t, e)
      , r = (s, o) => i(s, o);
    return new Proxy(r,{
        get: (s, o) => o === "create" ? i : (n.has(o) || n.set(o, Gd(o, void 0, t, e)),
        n.get(o))
    })
}
function qw({top: t, left: e, right: n, bottom: i}) {
    return {
        x: {
            min: e,
            max: n
        },
        y: {
            min: t,
            max: i
        }
    }
}
function VC({x: t, y: e}) {
    return {
        top: e.min,
        right: t.max,
        bottom: e.max,
        left: t.min
    }
}
function jC(t, e) {
    if (!e)
        return t;
    const n = e({
        x: t.left,
        y: t.top
    })
      , i = e({
        x: t.right,
        y: t.bottom
    });
    return {
        top: n.y,
        left: n.x,
        bottom: i.y,
        right: i.x
    }
}
function Wd(t) {
    return t === void 0 || t === 1
}
function Gf({scale: t, scaleX: e, scaleY: n}) {
    return !Wd(t) || !Wd(e) || !Wd(n)
}
function Qr(t) {
    return Gf(t) || Kw(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY
}
function Kw(t) {
    return Rv(t.x) || Rv(t.y)
}
function Rv(t) {
    return t && t !== "0%"
}
function Au(t, e, n) {
    const i = t - n
      , r = e * i;
    return n + r
}
function Pv(t, e, n, i, r) {
    return r !== void 0 && (t = Au(t, r, i)),
    Au(t, n, i) + e
}
function Wf(t, e=0, n=1, i, r) {
    t.min = Pv(t.min, e, n, i, r),
    t.max = Pv(t.max, e, n, i, r)
}
function Yw(t, {x: e, y: n}) {
    Wf(t.x, e.translate, e.scale, e.originPoint),
    Wf(t.y, n.translate, n.scale, n.originPoint)
}
const Nv = .999999999999
  , Dv = 1.0000000000001;
function HC(t, e, n, i=!1) {
    const r = n.length;
    if (!r)
        return;
    e.x = e.y = 1;
    let s, o;
    for (let a = 0; a < r; a++) {
        s = n[a],
        o = s.projectionDelta;
        const {visualElement: l} = s.options;
        l && l.props.style && l.props.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && fo(t, {
            x: -s.scroll.offset.x,
            y: -s.scroll.offset.y
        }),
        o && (e.x *= o.x.scale,
        e.y *= o.y.scale,
        Yw(t, o)),
        i && Qr(s.latestValues) && fo(t, s.latestValues))
    }
    e.x < Dv && e.x > Nv && (e.x = 1),
    e.y < Dv && e.y > Nv && (e.y = 1)
}
function ho(t, e) {
    t.min = t.min + e,
    t.max = t.max + e
}
function Lv(t, e, n, i, r=.5) {
    const s = xt(t.min, t.max, r);
    Wf(t, e, n, s, i)
}
function fo(t, e) {
    Lv(t.x, e.x, e.scaleX, e.scale, e.originX),
    Lv(t.y, e.y, e.scaleY, e.scale, e.originY)
}
function Zw(t, e) {
    return qw(jC(t.getBoundingClientRect(), e))
}
function GC(t, e, n) {
    const i = Zw(t, n)
      , {scroll: r} = e;
    return r && (ho(i.x, r.offset.x),
    ho(i.y, r.offset.y)),
    i
}
const Iv = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , po = () => ({
    x: Iv(),
    y: Iv()
})
  , kv = () => ({
    min: 0,
    max: 0
})
  , At = () => ({
    x: kv(),
    y: kv()
})
  , $f = {
    current: null
}
  , Jw = {
    current: !1
};
function WC() {
    if (Jw.current = !0,
    !!qm)
        if (window.matchMedia) {
            const t = window.matchMedia("(prefers-reduced-motion)")
              , e = () => $f.current = t.matches;
            t.addEventListener("change", e),
            e()
        } else
            $f.current = !1
}
const $C = new WeakMap;
function XC(t, e, n) {
    for (const i in e) {
        const r = e[i]
          , s = n[i];
        if (tn(r))
            t.addValue(i, r);
        else if (tn(s))
            t.addValue(i, Do(r, {
                owner: t
            }));
        else if (s !== r)
            if (t.hasValue(i)) {
                const o = t.getValue(i);
                o.liveStyle === !0 ? o.jump(r) : o.hasAnimated || o.set(r)
            } else {
                const o = t.getStaticValue(i);
                t.addValue(i, Do(o !== void 0 ? o : r, {
                    owner: t
                }))
            }
    }
    for (const i in n)
        e[i] === void 0 && t.removeValue(i);
    return e
}
const Uv = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class qC {
    scrapeMotionValuesFromProps(e, n, i) {
        return {}
    }
    constructor({parent: e, props: n, presenceContext: i, reducedMotionConfig: r, blockInitialAnimation: s, visualState: o}, a={}) {
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = dg,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = () => this.notify("Update", this.latestValues),
        this.render = () => {
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.renderScheduledAt = 0,
        this.scheduleRender = () => {
            const h = vn.now();
            this.renderScheduledAt < h && (this.renderScheduledAt = h,
            gt.render(this.render, !1, !0))
        }
        ;
        const {latestValues: l, renderState: c} = o;
        this.latestValues = l,
        this.baseTarget = {
            ...l
        },
        this.initialValues = n.initial ? {
            ...l
        } : {},
        this.renderState = c,
        this.parent = e,
        this.props = n,
        this.presenceContext = i,
        this.depth = e ? e.depth + 1 : 0,
        this.reducedMotionConfig = r,
        this.options = a,
        this.blockInitialAnimation = !!s,
        this.isControllingVariants = Zu(n),
        this.isVariantNode = Ow(n),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(e && e.current);
        const {willChange: u, ...d} = this.scrapeMotionValuesFromProps(n, {}, this);
        for (const h in d) {
            const p = d[h];
            l[h] !== void 0 && tn(p) && p.set(l[h])
        }
    }
    mount(e) {
        var n;
        this.current = e,
        $C.set(e, this),
        this.projection && !this.projection.instance && this.projection.mount(e),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach( (i, r) => this.bindToMotionValue(r, i)),
        Jw.current || WC(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : $f.current,
        (n = this.parent) == null || n.addChild(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        var e;
        this.projection && this.projection.unmount(),
        Nr(this.notifyUpdate),
        Nr(this.render),
        this.valueSubscriptions.forEach(n => n()),
        this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        (e = this.parent) == null || e.removeChild(this);
        for (const n in this.events)
            this.events[n].clear();
        for (const n in this.features) {
            const i = this.features[n];
            i && (i.unmount(),
            i.isMounted = !1)
        }
        this.current = null
    }
    addChild(e) {
        this.children.add(e),
        this.enteringChildren ?? (this.enteringChildren = new Set),
        this.enteringChildren.add(e)
    }
    removeChild(e) {
        this.children.delete(e),
        this.enteringChildren && this.enteringChildren.delete(e)
    }
    bindToMotionValue(e, n) {
        this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
        const i = Wo.has(e);
        i && this.onBindTransform && this.onBindTransform();
        const r = n.on("change", o => {
            this.latestValues[e] = o,
            this.props.onUpdate && gt.preRender(this.notifyUpdate),
            i && this.projection && (this.projection.isTransformDirty = !0),
            this.scheduleRender()
        }
        );
        let s;
        window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, e, n)),
        this.valueSubscriptions.set(e, () => {
            r(),
            s && s(),
            n.owner && n.stop()
        }
        )
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    updateFeatures() {
        let e = "animation";
        for (e in Lo) {
            const n = Lo[e];
            if (!n)
                continue;
            const {isEnabled: i, Feature: r} = n;
            if (!this.features[e] && r && i(this.props) && (this.features[e] = new r(this)),
            this.features[e]) {
                const s = this.features[e];
                s.isMounted ? s.update() : (s.mount(),
                s.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : At()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, n) {
        this.latestValues[e] = n
    }
    update(e, n) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = e,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = n;
        for (let i = 0; i < Uv.length; i++) {
            const r = Uv[i];
            this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](),
            delete this.propEventSubscriptions[r]);
            const s = "on" + r
              , o = e[s];
            o && (this.propEventSubscriptions[r] = this.on(r, o))
        }
        this.prevMotionValues = XC(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(e) {
        const n = this.getClosestVariantNode();
        if (n)
            return n.variantChildren && n.variantChildren.add(e),
            () => n.variantChildren.delete(e)
    }
    addValue(e, n) {
        const i = this.values.get(e);
        n !== i && (i && this.removeValue(e),
        this.bindToMotionValue(e, n),
        this.values.set(e, n),
        this.latestValues[e] = n.get())
    }
    removeValue(e) {
        this.values.delete(e);
        const n = this.valueSubscriptions.get(e);
        n && (n(),
        this.valueSubscriptions.delete(e)),
        delete this.latestValues[e],
        this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, n) {
        if (this.props.values && this.props.values[e])
            return this.props.values[e];
        let i = this.values.get(e);
        return i === void 0 && n !== void 0 && (i = Do(n === null ? void 0 : n, {
            owner: this
        }),
        this.addValue(e, i)),
        i
    }
    readValue(e, n) {
        let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.getBaseTargetFromProps(this.props, e) ?? this.readValueFromInstance(this.current, e, this.options);
        return i != null && (typeof i == "string" && (WS(i) || XS(i)) ? i = parseFloat(i) : !aC(i) && Dr.test(n) && (i = Cw(e, n)),
        this.setBaseTarget(e, tn(i) ? i.get() : i)),
        tn(i) ? i.get() : i
    }
    setBaseTarget(e, n) {
        this.baseTarget[e] = n
    }
    getBaseTarget(e) {
        var s;
        const {initial: n} = this.props;
        let i;
        if (typeof n == "string" || typeof n == "object") {
            const o = Sg(this.props, n, (s = this.presenceContext) == null ? void 0 : s.custom);
            o && (i = o[e])
        }
        if (n && i !== void 0)
            return i;
        const r = this.getBaseTargetFromProps(this.props, e);
        return r !== void 0 && !tn(r) ? r : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, n) {
        return this.events[e] || (this.events[e] = new Qm),
        this.events[e].add(n)
    }
    notify(e, ...n) {
        this.events[e] && this.events[e].notify(...n)
    }
    scheduleRenderMicrotask() {
        pg.render(this.render)
    }
}
class Qw extends qC {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = qA
    }
    sortInstanceNodePosition(e, n) {
        return e.compareDocumentPosition(n) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, n) {
        return e.style ? e.style[n] : void 0
    }
    removeValueFromRenderState(e, {vars: n, style: i}) {
        delete n[e],
        delete i[e]
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: e} = this.props;
        tn(e) && (this.childSubscription = e.on("change", n => {
            this.current && (this.current.textContent = `${n}`)
        }
        ))
    }
}
function eb(t, {style: e, vars: n}, i, r) {
    const s = t.style;
    let o;
    for (o in e)
        s[o] = e[o];
    r == null || r.applyProjectionStyles(s, i);
    for (o in n)
        s.setProperty(o, n[o])
}
function KC(t) {
    return window.getComputedStyle(t)
}
class YC extends Qw {
    constructor() {
        super(...arguments),
        this.type = "html",
        this.renderInstance = eb
    }
    readValueFromInstance(e, n) {
        var i;
        if (Wo.has(n))
            return (i = this.projection) != null && i.isProjecting ? Of(n) : fA(e, n);
        {
            const r = KC(e)
              , s = (ng(n) ? r.getPropertyValue(n) : r[n]) || 0;
            return typeof s == "string" ? s.trim() : s
        }
    }
    measureInstanceViewportBox(e, {transformPagePoint: n}) {
        return Zw(e, n)
    }
    build(e, n, i) {
        _g(e, n, i.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, n, i) {
        return wg(e, n, i)
    }
}
const tb = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function ZC(t, e, n, i) {
    eb(t, e, void 0, i);
    for (const r in e.attrs)
        t.setAttribute(tb.has(r) ? r : bg(r), e.attrs[r])
}
class JC extends Qw {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1,
        this.measureInstanceViewportBox = At
    }
    getBaseTargetFromProps(e, n) {
        return e[n]
    }
    readValueFromInstance(e, n) {
        if (Wo.has(n)) {
            const i = Aw(n);
            return i && i.default || 0
        }
        return n = tb.has(n) ? n : bg(n),
        e.getAttribute(n)
    }
    scrapeMotionValuesFromProps(e, n, i) {
        return Gw(e, n, i)
    }
    build(e, n, i) {
        zw(e, n, this.isSVGTag, i.transformTemplate, i.style)
    }
    renderInstance(e, n, i, r) {
        ZC(e, n, i, r)
    }
    mount(e) {
        this.isSVGTag = jw(e.tagName),
        super.mount(e)
    }
}
const QC = (t, e) => xg(t) ? new JC(e) : new YC(e,{
    allowProjection: t !== oe.Fragment
});
function wo(t, e, n) {
    const i = t.getProps();
    return Sg(i, e, n !== void 0 ? n : i.custom, t)
}
const Xf = t => Array.isArray(t);
function eR(t, e, n) {
    t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, Do(n))
}
function tR(t) {
    return Xf(t) ? t[t.length - 1] || 0 : t
}
function nR(t, e) {
    const n = wo(t, e);
    let {transitionEnd: i={}, transition: r={}, ...s} = n || {};
    s = {
        ...s,
        ...i
    };
    for (const o in s) {
        const a = tR(s[o]);
        eR(t, o, a)
    }
}
function iR(t) {
    return !!(tn(t) && t.add)
}
function qf(t, e) {
    const n = t.getValue("willChange");
    if (iR(n))
        return n.add(e);
    if (!n && Ki.WillChange) {
        const i = new Ki.WillChange("auto");
        t.addValue("willChange", i),
        i.add(e)
    }
}
function nb(t) {
    return t.props[Ww]
}
const rR = t => t !== null;
function sR(t, {repeat: e, repeatType: n="loop"}, i) {
    const r = t.filter(rR)
      , s = e && n !== "loop" && e % 2 === 1 ? 0 : r.length - 1;
    return !s || i === void 0 ? r[s] : i
}
const oR = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , aR = t => ({
    type: "spring",
    stiffness: 550,
    damping: t === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , lR = {
    type: "keyframes",
    duration: .8
}
  , cR = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , uR = (t, {keyframes: e}) => e.length > 2 ? lR : Wo.has(t) ? t.startsWith("scale") ? aR(e[1]) : oR : cR;
function dR({when: t, delay: e, delayChildren: n, staggerChildren: i, staggerDirection: r, repeat: s, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...u}) {
    return !!Object.keys(u).length
}
const Eg = (t, e, n, i={}, r, s) => o => {
    const a = hg(i, t) || {}
      , l = a.delay || i.delay || 0;
    let {elapsed: c=0} = i;
    c = c - wi(l);
    const u = {
        keyframes: Array.isArray(n) ? n : [null, n],
        ease: "easeOut",
        velocity: e.getVelocity(),
        ...a,
        delay: -c,
        onUpdate: h => {
            e.set(h),
            a.onUpdate && a.onUpdate(h)
        }
        ,
        onComplete: () => {
            o(),
            a.onComplete && a.onComplete()
        }
        ,
        name: t,
        motionValue: e,
        element: s ? void 0 : r
    };
    dR(a) || Object.assign(u, uR(t, u)),
    u.duration && (u.duration = wi(u.duration)),
    u.repeatDelay && (u.repeatDelay = wi(u.repeatDelay)),
    u.from !== void 0 && (u.keyframes[0] = u.from);
    let d = !1;
    if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (jf(u),
    u.delay === 0 && (d = !0)),
    (Ki.instantAnimations || Ki.skipAnimations) && (d = !0,
    jf(u),
    u.delay = 0),
    u.allowFlatten = !a.type && !a.ease,
    d && !s && e.get() !== void 0) {
        const h = sR(u.keyframes, a);
        if (h !== void 0) {
            gt.update( () => {
                u.onUpdate(h),
                u.onComplete()
            }
            );
            return
        }
    }
    return a.isSync ? new ug(u) : new UA(u)
}
;
function hR({protectedKeys: t, needsAnimating: e}, n) {
    const i = t.hasOwnProperty(n) && e[n] !== !0;
    return e[n] = !1,
    i
}
function ib(t, e, {delay: n=0, transitionOverride: i, type: r}={}) {
    let {transition: s=t.getDefaultTransition(), transitionEnd: o, ...a} = e;
    i && (s = i);
    const l = []
      , c = r && t.animationState && t.animationState.getState()[r];
    for (const u in a) {
        const d = t.getValue(u, t.latestValues[u] ?? null)
          , h = a[u];
        if (h === void 0 || c && hR(c, u))
            continue;
        const p = {
            delay: n,
            ...hg(s || {}, u)
        }
          , v = d.get();
        if (v !== void 0 && !d.isAnimating && !Array.isArray(h) && h === v && !p.velocity)
            continue;
        let x = !1;
        if (window.MotionHandoffAnimation) {
            const f = nb(t);
            if (f) {
                const y = window.MotionHandoffAnimation(f, u, gt);
                y !== null && (p.startTime = y,
                x = !0)
            }
        }
        qf(t, u),
        d.start(Eg(u, d, h, t.shouldReduceMotion && Ew.has(u) ? {
            type: !1
        } : p, t, x));
        const g = d.animation;
        g && l.push(g)
    }
    return o && Promise.all(l).then( () => {
        gt.update( () => {
            o && nR(t, o)
        }
        )
    }
    ),
    l
}
function rb(t, e, n, i=0, r=1) {
    const s = Array.from(t).sort( (c, u) => c.sortNodePosition(u)).indexOf(e)
      , o = t.size
      , a = (o - 1) * i;
    return typeof n == "function" ? n(s, o) : r === 1 ? s * i : a - s * i
}
function Kf(t, e, n={}) {
    var l;
    const i = wo(t, e, n.type === "exit" ? (l = t.presenceContext) == null ? void 0 : l.custom : void 0);
    let {transition: r=t.getDefaultTransition() || {}} = i || {};
    n.transitionOverride && (r = n.transitionOverride);
    const s = i ? () => Promise.all(ib(t, i, n)) : () => Promise.resolve()
      , o = t.variantChildren && t.variantChildren.size ? (c=0) => {
        const {delayChildren: u=0, staggerChildren: d, staggerDirection: h} = r;
        return fR(t, e, c, u, d, h, n)
    }
    : () => Promise.resolve()
      , {when: a} = r;
    if (a) {
        const [c,u] = a === "beforeChildren" ? [s, o] : [o, s];
        return c().then( () => u())
    } else
        return Promise.all([s(), o(n.delay)])
}
function fR(t, e, n=0, i=0, r=0, s=1, o) {
    const a = [];
    for (const l of t.variantChildren)
        l.notify("AnimationStart", e),
        a.push(Kf(l, e, {
            ...o,
            delay: n + (typeof i == "function" ? 0 : i) + rb(t.variantChildren, l, i, r, s)
        }).then( () => l.notify("AnimationComplete", e)));
    return Promise.all(a)
}
function pR(t, e, n={}) {
    t.notify("AnimationStart", e);
    let i;
    if (Array.isArray(e)) {
        const r = e.map(s => Kf(t, s, n));
        i = Promise.all(r)
    } else if (typeof e == "string")
        i = Kf(t, e, n);
    else {
        const r = typeof e == "function" ? wo(t, e, n.custom) : e;
        i = Promise.all(ib(t, r, n))
    }
    return i.then( () => {
        t.notify("AnimationComplete", e)
    }
    )
}
function sb(t, e) {
    if (!Array.isArray(e))
        return !1;
    const n = e.length;
    if (n !== t.length)
        return !1;
    for (let i = 0; i < n; i++)
        if (e[i] !== t[i])
            return !1;
    return !0
}
const mR = vg.length;
function ob(t) {
    if (!t)
        return;
    if (!t.isControllingVariants) {
        const n = t.parent ? ob(t.parent) || {} : {};
        return t.props.initial !== void 0 && (n.initial = t.props.initial),
        n
    }
    const e = {};
    for (let n = 0; n < mR; n++) {
        const i = vg[n]
          , r = t.props[i];
        (il(r) || r === !1) && (e[i] = r)
    }
    return e
}
const gR = [...gg].reverse()
  , vR = gg.length;
function _R(t) {
    return e => Promise.all(e.map( ({animation: n, options: i}) => pR(t, n, i)))
}
function yR(t) {
    let e = _R(t)
      , n = Ov()
      , i = !0;
    const r = l => (c, u) => {
        var h;
        const d = wo(t, u, l === "exit" ? (h = t.presenceContext) == null ? void 0 : h.custom : void 0);
        if (d) {
            const {transition: p, transitionEnd: v, ...x} = d;
            c = {
                ...c,
                ...x,
                ...v
            }
        }
        return c
    }
    ;
    function s(l) {
        e = l(t)
    }
    function o(l) {
        const {props: c} = t
          , u = ob(t.parent) || {}
          , d = []
          , h = new Set;
        let p = {}
          , v = 1 / 0;
        for (let g = 0; g < vR; g++) {
            const f = gR[g]
              , y = n[f]
              , _ = c[f] !== void 0 ? c[f] : u[f]
              , S = il(_)
              , T = f === l ? y.isActive : null;
            T === !1 && (v = g);
            let A = _ === u[f] && _ !== c[f] && S;
            if (A && i && t.manuallyAnimateOnMount && (A = !1),
            y.protectedKeys = {
                ...p
            },
            !y.isActive && T === null || !_ && !y.prevProp || Yu(_) || typeof _ == "boolean")
                continue;
            const C = xR(y.prevProp, _);
            let P = C || f === l && y.isActive && !A && S || g > v && S
              , M = !1;
            const b = Array.isArray(_) ? _ : [_];
            let L = b.reduce(r(f), {});
            T === !1 && (L = {});
            const {prevResolvedValues: F={}} = y
              , H = {
                ...F,
                ...L
            }
              , Z = B => {
                P = !0,
                h.has(B) && (M = !0,
                h.delete(B)),
                y.needsAnimating[B] = !0;
                const D = t.getValue(B);
                D && (D.liveStyle = !1)
            }
            ;
            for (const B in H) {
                const D = L[B]
                  , G = F[B];
                if (p.hasOwnProperty(B))
                    continue;
                let Y = !1;
                Xf(D) && Xf(G) ? Y = !sb(D, G) : Y = D !== G,
                Y ? D != null ? Z(B) : h.add(B) : D !== void 0 && h.has(B) ? Z(B) : y.protectedKeys[B] = !0
            }
            y.prevProp = _,
            y.prevResolvedValues = L,
            y.isActive && (p = {
                ...p,
                ...L
            }),
            i && t.blockInitialAnimation && (P = !1);
            const $ = A && C;
            P && (!$ || M) && d.push(...b.map(B => {
                const D = {
                    type: f
                };
                if (typeof B == "string" && i && !$ && t.manuallyAnimateOnMount && t.parent) {
                    const {parent: G} = t
                      , Y = wo(G, B);
                    if (G.enteringChildren && Y) {
                        const {delayChildren: le} = Y.transition || {};
                        D.delay = rb(G.enteringChildren, t, le)
                    }
                }
                return {
                    animation: B,
                    options: D
                }
            }
            ))
        }
        if (h.size) {
            const g = {};
            if (typeof c.initial != "boolean") {
                const f = wo(t, Array.isArray(c.initial) ? c.initial[0] : c.initial);
                f && f.transition && (g.transition = f.transition)
            }
            h.forEach(f => {
                const y = t.getBaseTarget(f)
                  , _ = t.getValue(f);
                _ && (_.liveStyle = !0),
                g[f] = y ?? null
            }
            ),
            d.push({
                animation: g
            })
        }
        let x = !!d.length;
        return i && (c.initial === !1 || c.initial === c.animate) && !t.manuallyAnimateOnMount && (x = !1),
        i = !1,
        x ? e(d) : Promise.resolve()
    }
    function a(l, c) {
        var d;
        if (n[l].isActive === c)
            return Promise.resolve();
        (d = t.variantChildren) == null || d.forEach(h => {
            var p;
            return (p = h.animationState) == null ? void 0 : p.setActive(l, c)
        }
        ),
        n[l].isActive = c;
        const u = o(l);
        for (const h in n)
            n[h].protectedKeys = {};
        return u
    }
    return {
        animateChanges: o,
        setActive: a,
        setAnimateFunction: s,
        getState: () => n,
        reset: () => {
            n = Ov()
        }
    }
}
function xR(t, e) {
    return typeof e == "string" ? e !== t : Array.isArray(e) ? !sb(e, t) : !1
}
function jr(t=!1) {
    return {
        isActive: t,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function Ov() {
    return {
        animate: jr(!0),
        whileInView: jr(),
        whileHover: jr(),
        whileTap: jr(),
        whileDrag: jr(),
        whileFocus: jr(),
        exit: jr()
    }
}
class Fr {
    constructor(e) {
        this.isMounted = !1,
        this.node = e
    }
    update() {}
}
class SR extends Fr {
    constructor(e) {
        super(e),
        e.animationState || (e.animationState = yR(e))
    }
    updateAnimationControlsSubscription() {
        const {animate: e} = this.node.getProps();
        Yu(e) && (this.unmountControls = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: e} = this.node.getProps()
          , {animate: n} = this.node.prevProps || {};
        e !== n && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var e;
        this.node.animationState.reset(),
        (e = this.unmountControls) == null || e.call(this)
    }
}
let wR = 0;
class bR extends Fr {
    constructor() {
        super(...arguments),
        this.id = wR++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: e, onExitComplete: n} = this.node.presenceContext
          , {isPresent: i} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === i)
            return;
        const r = this.node.animationState.setActive("exit", !e);
        n && !e && r.then( () => {
            n(this.id)
        }
        )
    }
    mount() {
        const {register: e, onExitComplete: n} = this.node.presenceContext || {};
        n && n(this.id),
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
const ER = {
    animation: {
        Feature: SR
    },
    exit: {
        Feature: bR
    }
};
function sl(t, e, n, i={
    passive: !0
}) {
    return t.addEventListener(e, n, i),
    () => t.removeEventListener(e, n)
}
function Sl(t) {
    return {
        point: {
            x: t.pageX,
            y: t.pageY
        }
    }
}
const TR = t => e => mg(e) && t(e, Sl(e));
function Na(t, e, n, i) {
    return sl(t, e, TR(n), i)
}
const ab = 1e-4
  , MR = 1 - ab
  , AR = 1 + ab
  , lb = .01
  , CR = 0 - lb
  , RR = 0 + lb;
function ln(t) {
    return t.max - t.min
}
function PR(t, e, n) {
    return Math.abs(t - e) <= n
}
function Fv(t, e, n, i=.5) {
    t.origin = i,
    t.originPoint = xt(e.min, e.max, t.origin),
    t.scale = ln(n) / ln(e),
    t.translate = xt(n.min, n.max, t.origin) - t.originPoint,
    (t.scale >= MR && t.scale <= AR || isNaN(t.scale)) && (t.scale = 1),
    (t.translate >= CR && t.translate <= RR || isNaN(t.translate)) && (t.translate = 0)
}
function Da(t, e, n, i) {
    Fv(t.x, e.x, n.x, i ? i.originX : void 0),
    Fv(t.y, e.y, n.y, i ? i.originY : void 0)
}
function Bv(t, e, n) {
    t.min = n.min + e.min,
    t.max = t.min + ln(e)
}
function NR(t, e, n) {
    Bv(t.x, e.x, n.x),
    Bv(t.y, e.y, n.y)
}
function zv(t, e, n) {
    t.min = e.min - n.min,
    t.max = t.min + ln(e)
}
function La(t, e, n) {
    zv(t.x, e.x, n.x),
    zv(t.y, e.y, n.y)
}
function Fn(t) {
    return [t("x"), t("y")]
}
const cb = ({current: t}) => t ? t.ownerDocument.defaultView : null
  , Vv = (t, e) => Math.abs(t - e);
function DR(t, e) {
    const n = Vv(t.x, e.x)
      , i = Vv(t.y, e.y);
    return Math.sqrt(n ** 2 + i ** 2)
}
class ub {
    constructor(e, n, {transformPagePoint: i, contextWindow: r=window, dragSnapToOrigin: s=!1, distanceThreshold: o=3}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const h = Xd(this.lastMoveEventInfo, this.history)
              , p = this.startEvent !== null
              , v = DR(h.offset, {
                x: 0,
                y: 0
            }) >= this.distanceThreshold;
            if (!p && !v)
                return;
            const {point: x} = h
              , {timestamp: g} = $t;
            this.history.push({
                ...x,
                timestamp: g
            });
            const {onStart: f, onMove: y} = this.handlers;
            p || (f && f(this.lastMoveEvent, h),
            this.startEvent = this.lastMoveEvent),
            y && y(this.lastMoveEvent, h)
        }
        ,
        this.handlePointerMove = (h, p) => {
            this.lastMoveEvent = h,
            this.lastMoveEventInfo = $d(p, this.transformPagePoint),
            gt.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (h, p) => {
            this.end();
            const {onEnd: v, onSessionEnd: x, resumeAnimation: g} = this.handlers;
            if (this.dragSnapToOrigin && g && g(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const f = Xd(h.type === "pointercancel" ? this.lastMoveEventInfo : $d(p, this.transformPagePoint), this.history);
            this.startEvent && v && v(h, f),
            x && x(h, f)
        }
        ,
        !mg(e))
            return;
        this.dragSnapToOrigin = s,
        this.handlers = n,
        this.transformPagePoint = i,
        this.distanceThreshold = o,
        this.contextWindow = r || window;
        const a = Sl(e)
          , l = $d(a, this.transformPagePoint)
          , {point: c} = l
          , {timestamp: u} = $t;
        this.history = [{
            ...c,
            timestamp: u
        }];
        const {onSessionStart: d} = n;
        d && d(e, Xd(l, this.history)),
        this.removeListeners = _l(Na(this.contextWindow, "pointermove", this.handlePointerMove), Na(this.contextWindow, "pointerup", this.handlePointerUp), Na(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(),
        Nr(this.updatePoint)
    }
}
function $d(t, e) {
    return e ? {
        point: e(t.point)
    } : t
}
function jv(t, e) {
    return {
        x: t.x - e.x,
        y: t.y - e.y
    }
}
function Xd({point: t}, e) {
    return {
        point: t,
        delta: jv(t, db(e)),
        offset: jv(t, LR(e)),
        velocity: IR(e, .1)
    }
}
function LR(t) {
    return t[0]
}
function db(t) {
    return t[t.length - 1]
}
function IR(t, e) {
    if (t.length < 2)
        return {
            x: 0,
            y: 0
        };
    let n = t.length - 1
      , i = null;
    const r = db(t);
    for (; n >= 0 && (i = t[n],
    !(r.timestamp - i.timestamp > wi(e))); )
        n--;
    if (!i)
        return {
            x: 0,
            y: 0
        };
    const s = Gn(r.timestamp - i.timestamp);
    if (s === 0)
        return {
            x: 0,
            y: 0
        };
    const o = {
        x: (r.x - i.x) / s,
        y: (r.y - i.y) / s
    };
    return o.x === 1 / 0 && (o.x = 0),
    o.y === 1 / 0 && (o.y = 0),
    o
}
function kR(t, {min: e, max: n}, i) {
    return e !== void 0 && t < e ? t = i ? xt(e, t, i.min) : Math.max(t, e) : n !== void 0 && t > n && (t = i ? xt(n, t, i.max) : Math.min(t, n)),
    t
}
function Hv(t, e, n) {
    return {
        min: e !== void 0 ? t.min + e : void 0,
        max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
    }
}
function UR(t, {top: e, left: n, bottom: i, right: r}) {
    return {
        x: Hv(t.x, n, r),
        y: Hv(t.y, e, i)
    }
}
function Gv(t, e) {
    let n = e.min - t.min
      , i = e.max - t.max;
    return e.max - e.min < t.max - t.min && ([n,i] = [i, n]),
    {
        min: n,
        max: i
    }
}
function OR(t, e) {
    return {
        x: Gv(t.x, e.x),
        y: Gv(t.y, e.y)
    }
}
function FR(t, e) {
    let n = .5;
    const i = ln(t)
      , r = ln(e);
    return r > i ? n = el(e.min, e.max - i, t.min) : i > r && (n = el(t.min, t.max - r, e.min)),
    qi(0, 1, n)
}
function BR(t, e) {
    const n = {};
    return e.min !== void 0 && (n.min = e.min - t.min),
    e.max !== void 0 && (n.max = e.max - t.min),
    n
}
const Yf = .35;
function zR(t=Yf) {
    return t === !1 ? t = 0 : t === !0 && (t = Yf),
    {
        x: Wv(t, "left", "right"),
        y: Wv(t, "top", "bottom")
    }
}
function Wv(t, e, n) {
    return {
        min: $v(t, e),
        max: $v(t, n)
    }
}
function $v(t, e) {
    return typeof t == "number" ? t : t[e] || 0
}
const VR = new WeakMap;
class jR {
    constructor(e) {
        this.openDragLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = At(),
        this.latestPointerEvent = null,
        this.latestPanInfo = null,
        this.visualElement = e
    }
    start(e, {snapToCursor: n=!1, distanceThreshold: i}={}) {
        const {presenceContext: r} = this.visualElement;
        if (r && r.isPresent === !1)
            return;
        const s = d => {
            const {dragSnapToOrigin: h} = this.getProps();
            h ? this.pauseAnimation() : this.stopAnimation(),
            n && this.snapToCursor(Sl(d).point)
        }
          , o = (d, h) => {
            const {drag: p, dragPropagation: v, onDragStart: x} = this.getProps();
            if (p && !v && (this.openDragLock && this.openDragLock(),
            this.openDragLock = QA(p),
            !this.openDragLock))
                return;
            this.latestPointerEvent = d,
            this.latestPanInfo = h,
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            Fn(f => {
                let y = this.getAxisMotionValue(f).get() || 0;
                if (bi.test(y)) {
                    const {projection: _} = this.visualElement;
                    if (_ && _.layout) {
                        const S = _.layout.layoutBox[f];
                        S && (y = ln(S) * (parseFloat(y) / 100))
                    }
                }
                this.originPoint[f] = y
            }
            ),
            x && gt.postRender( () => x(d, h)),
            qf(this.visualElement, "transform");
            const {animationState: g} = this.visualElement;
            g && g.setActive("whileDrag", !0)
        }
          , a = (d, h) => {
            this.latestPointerEvent = d,
            this.latestPanInfo = h;
            const {dragPropagation: p, dragDirectionLock: v, onDirectionLock: x, onDrag: g} = this.getProps();
            if (!p && !this.openDragLock)
                return;
            const {offset: f} = h;
            if (v && this.currentDirection === null) {
                this.currentDirection = HR(f),
                this.currentDirection !== null && x && x(this.currentDirection);
                return
            }
            this.updateAxis("x", h.point, f),
            this.updateAxis("y", h.point, f),
            this.visualElement.render(),
            g && g(d, h)
        }
          , l = (d, h) => {
            this.latestPointerEvent = d,
            this.latestPanInfo = h,
            this.stop(d, h),
            this.latestPointerEvent = null,
            this.latestPanInfo = null
        }
          , c = () => Fn(d => {
            var h;
            return this.getAnimationState(d) === "paused" && ((h = this.getAxisMotionValue(d).animation) == null ? void 0 : h.play())
        }
        )
          , {dragSnapToOrigin: u} = this.getProps();
        this.panSession = new ub(e,{
            onSessionStart: s,
            onStart: o,
            onMove: a,
            onSessionEnd: l,
            resumeAnimation: c
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: u,
            distanceThreshold: i,
            contextWindow: cb(this.visualElement)
        })
    }
    stop(e, n) {
        const i = e || this.latestPointerEvent
          , r = n || this.latestPanInfo
          , s = this.isDragging;
        if (this.cancel(),
        !s || !r || !i)
            return;
        const {velocity: o} = r;
        this.startAnimation(o);
        const {onDragEnd: a} = this.getProps();
        a && gt.postRender( () => a(i, r))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: e, animationState: n} = this.visualElement;
        e && (e.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: i} = this.getProps();
        !i && this.openDragLock && (this.openDragLock(),
        this.openDragLock = null),
        n && n.setActive("whileDrag", !1)
    }
    updateAxis(e, n, i) {
        const {drag: r} = this.getProps();
        if (!i || !ec(e, r, this.currentDirection))
            return;
        const s = this.getAxisMotionValue(e);
        let o = this.originPoint[e] + i[e];
        this.constraints && this.constraints[e] && (o = kR(o, this.constraints[e], this.elastic[e])),
        s.set(o)
    }
    resolveConstraints() {
        var s;
        const {dragConstraints: e, dragElastic: n} = this.getProps()
          , i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (s = this.visualElement.projection) == null ? void 0 : s.layout
          , r = this.constraints;
        e && uo(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && i ? this.constraints = UR(i.layoutBox, e) : this.constraints = !1,
        this.elastic = zR(n),
        r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Fn(o => {
            this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = BR(i.layoutBox[o], this.constraints[o]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: e, onMeasureDragConstraints: n} = this.getProps();
        if (!e || !uo(e))
            return !1;
        const i = e.current
          , {projection: r} = this.visualElement;
        if (!r || !r.layout)
            return !1;
        const s = GC(i, r.root, this.visualElement.getTransformPagePoint());
        let o = OR(r.layout.layoutBox, s);
        if (n) {
            const a = n(VC(o));
            this.hasMutatedConstraints = !!a,
            a && (o = qw(a))
        }
        return o
    }
    startAnimation(e) {
        const {drag: n, dragMomentum: i, dragElastic: r, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a} = this.getProps()
          , l = this.constraints || {}
          , c = Fn(u => {
            if (!ec(u, n, this.currentDirection))
                return;
            let d = l && l[u] || {};
            o && (d = {
                min: 0,
                max: 0
            });
            const h = r ? 200 : 1e6
              , p = r ? 40 : 1e7
              , v = {
                type: "inertia",
                velocity: i ? e[u] : 0,
                bounceStiffness: h,
                bounceDamping: p,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...s,
                ...d
            };
            return this.startAxisValueAnimation(u, v)
        }
        );
        return Promise.all(c).then(a)
    }
    startAxisValueAnimation(e, n) {
        const i = this.getAxisMotionValue(e);
        return qf(this.visualElement, e),
        i.start(Eg(e, i, 0, n, this.visualElement, !1))
    }
    stopAnimation() {
        Fn(e => this.getAxisMotionValue(e).stop())
    }
    pauseAnimation() {
        Fn(e => {
            var n;
            return (n = this.getAxisMotionValue(e).animation) == null ? void 0 : n.pause()
        }
        )
    }
    getAnimationState(e) {
        var n;
        return (n = this.getAxisMotionValue(e).animation) == null ? void 0 : n.state
    }
    getAxisMotionValue(e) {
        const n = `_drag${e.toUpperCase()}`
          , i = this.visualElement.getProps()
          , r = i[n];
        return r || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        Fn(n => {
            const {drag: i} = this.getProps();
            if (!ec(n, i, this.currentDirection))
                return;
            const {projection: r} = this.visualElement
              , s = this.getAxisMotionValue(n);
            if (r && r.layout) {
                const {min: o, max: a} = r.layout.layoutBox[n];
                s.set(e[n] - xt(o, a, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: e, dragConstraints: n} = this.getProps()
          , {projection: i} = this.visualElement;
        if (!uo(n) || !i || !this.constraints)
            return;
        this.stopAnimation();
        const r = {
            x: 0,
            y: 0
        };
        Fn(o => {
            const a = this.getAxisMotionValue(o);
            if (a && this.constraints !== !1) {
                const l = a.get();
                r[o] = FR({
                    min: l,
                    max: l
                }, this.constraints[o])
            }
        }
        );
        const {transformTemplate: s} = this.visualElement.getProps();
        this.visualElement.current.style.transform = s ? s({}, "") : "none",
        i.root && i.root.updateScroll(),
        i.updateLayout(),
        this.resolveConstraints(),
        Fn(o => {
            if (!ec(o, e, null))
                return;
            const a = this.getAxisMotionValue(o)
              , {min: l, max: c} = this.constraints[o];
            a.set(xt(l, c, r[o]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        VR.set(this.visualElement, this);
        const e = this.visualElement.current
          , n = Na(e, "pointerdown", l => {
            const {drag: c, dragListener: u=!0} = this.getProps();
            c && u && this.start(l)
        }
        )
          , i = () => {
            const {dragConstraints: l} = this.getProps();
            uo(l) && l.current && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: r} = this.visualElement
          , s = r.addEventListener("measure", i);
        r && !r.layout && (r.root && r.root.updateScroll(),
        r.updateLayout()),
        gt.read(i);
        const o = sl(window, "resize", () => this.scalePositionWithinConstraints())
          , a = r.addEventListener("didUpdate", ({delta: l, hasLayoutChanged: c}) => {
            this.isDragging && c && (Fn(u => {
                const d = this.getAxisMotionValue(u);
                d && (this.originPoint[u] += l[u].translate,
                d.set(d.get() + l[u].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return () => {
            o(),
            n(),
            s(),
            a && a()
        }
    }
    getProps() {
        const e = this.visualElement.getProps()
          , {drag: n=!1, dragDirectionLock: i=!1, dragPropagation: r=!1, dragConstraints: s=!1, dragElastic: o=Yf, dragMomentum: a=!0} = e;
        return {
            ...e,
            drag: n,
            dragDirectionLock: i,
            dragPropagation: r,
            dragConstraints: s,
            dragElastic: o,
            dragMomentum: a
        }
    }
}
function ec(t, e, n) {
    return (e === !0 || e === t) && (n === null || n === t)
}
function HR(t, e=10) {
    let n = null;
    return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"),
    n
}
class GR extends Fr {
    constructor(e) {
        super(e),
        this.removeGroupControls = $n,
        this.removeListeners = $n,
        this.controls = new jR(e)
    }
    mount() {
        const {dragControls: e} = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || $n
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const Xv = t => (e, n) => {
    t && gt.postRender( () => t(e, n))
}
;
class WR extends Fr {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = $n
    }
    onPointerDown(e) {
        this.session = new ub(e,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: cb(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: e, onPanStart: n, onPan: i, onPanEnd: r} = this.node.getProps();
        return {
            onSessionStart: Xv(e),
            onStart: Xv(n),
            onMove: i,
            onEnd: (s, o) => {
                delete this.session,
                r && gt.postRender( () => r(s, o))
            }
        }
    }
    mount() {
        this.removePointerDownListener = Na(this.node.current, "pointerdown", e => this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
const Gc = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function qv(t, e) {
    return e.max === e.min ? 0 : t / (e.max - e.min) * 100
}
const oa = {
    correct: (t, e) => {
        if (!e.target)
            return t;
        if (typeof t == "string")
            if (De.test(t))
                t = parseFloat(t);
            else
                return t;
        const n = qv(t, e.target.x)
          , i = qv(t, e.target.y);
        return `${n}% ${i}%`
    }
}
  , $R = {
    correct: (t, {treeScale: e, projectionDelta: n}) => {
        const i = t
          , r = Dr.parse(t);
        if (r.length > 5)
            return i;
        const s = Dr.createTransformer(t)
          , o = typeof r[0] != "number" ? 1 : 0
          , a = n.x.scale * e.x
          , l = n.y.scale * e.y;
        r[0 + o] /= a,
        r[1 + o] /= l;
        const c = xt(a, l, .5);
        return typeof r[2 + o] == "number" && (r[2 + o] /= c),
        typeof r[3 + o] == "number" && (r[3 + o] /= c),
        s(r)
    }
};
let qd = !1;
class XR extends oe.Component {
    componentDidMount() {
        const {visualElement: e, layoutGroup: n, switchLayoutGroup: i, layoutId: r} = this.props
          , {projection: s} = e;
        mC(qR),
        s && (n.group && n.group.add(s),
        i && i.register && r && i.register(s),
        qd && s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }
        ),
        s.setOptions({
            ...s.options,
            onExitComplete: () => this.safeToRemove()
        })),
        Gc.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        const {layoutDependency: n, visualElement: i, drag: r, isPresent: s} = this.props
          , {projection: o} = i;
        return o && (o.isPresent = s,
        qd = !0,
        r || e.layoutDependency !== n || n === void 0 || e.isPresent !== s ? o.willUpdate() : this.safeToRemove(),
        e.isPresent !== s && (s ? o.promote() : o.relegate() || gt.postRender( () => {
            const a = o.getStack();
            (!a || !a.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: e} = this.props.visualElement;
        e && (e.root.didUpdate(),
        pg.postRender( () => {
            !e.currentAnimation && e.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: e, layoutGroup: n, switchLayoutGroup: i} = this.props
          , {projection: r} = e;
        qd = !0,
        r && (r.scheduleCheckAfterUnmount(),
        n && n.group && n.group.remove(r),
        i && i.deregister && i.deregister(r))
    }
    safeToRemove() {
        const {safeToRemove: e} = this.props;
        e && e()
    }
    render() {
        return null
    }
}
function hb(t) {
    const [e,n] = lC()
      , i = oe.useContext(GS);
    return m.jsx(XR, {
        ...t,
        layoutGroup: i,
        switchLayoutGroup: oe.useContext($w),
        isPresent: e,
        safeToRemove: n
    })
}
const qR = {
    borderRadius: {
        ...oa,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: oa,
    borderTopRightRadius: oa,
    borderBottomLeftRadius: oa,
    borderBottomRightRadius: oa,
    boxShadow: $R
};
function KR(t, e, n) {
    const i = tn(t) ? t : Do(t);
    return i.start(Eg("", i, e, n)),
    i.animation
}
const YR = (t, e) => t.depth - e.depth;
class ZR {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(e) {
        Ym(this.children, e),
        this.isDirty = !0
    }
    remove(e) {
        Zm(this.children, e),
        this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(YR),
        this.isDirty = !1,
        this.children.forEach(e)
    }
}
function JR(t, e) {
    const n = vn.now()
      , i = ({timestamp: r}) => {
        const s = r - n;
        s >= e && (Nr(i),
        t(s - e))
    }
    ;
    return gt.setup(i, !0),
    () => Nr(i)
}
const fb = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , QR = fb.length
  , Kv = t => typeof t == "string" ? parseFloat(t) : t
  , Yv = t => typeof t == "number" || De.test(t);
function eP(t, e, n, i, r, s) {
    r ? (t.opacity = xt(0, n.opacity ?? 1, tP(i)),
    t.opacityExit = xt(e.opacity ?? 1, 0, nP(i))) : s && (t.opacity = xt(e.opacity ?? 1, n.opacity ?? 1, i));
    for (let o = 0; o < QR; o++) {
        const a = `border${fb[o]}Radius`;
        let l = Zv(e, a)
          , c = Zv(n, a);
        if (l === void 0 && c === void 0)
            continue;
        l || (l = 0),
        c || (c = 0),
        l === 0 || c === 0 || Yv(l) === Yv(c) ? (t[a] = Math.max(xt(Kv(l), Kv(c), i), 0),
        (bi.test(c) || bi.test(l)) && (t[a] += "%")) : t[a] = c
    }
    (e.rotate || n.rotate) && (t.rotate = xt(e.rotate || 0, n.rotate || 0, i))
}
function Zv(t, e) {
    return t[e] !== void 0 ? t[e] : t.borderRadius
}
const tP = pb(0, .5, tw)
  , nP = pb(.5, .95, $n);
function pb(t, e, n) {
    return i => i < t ? 0 : i > e ? 1 : n(el(t, e, i))
}
function Jv(t, e) {
    t.min = e.min,
    t.max = e.max
}
function Un(t, e) {
    Jv(t.x, e.x),
    Jv(t.y, e.y)
}
function Qv(t, e) {
    t.translate = e.translate,
    t.scale = e.scale,
    t.originPoint = e.originPoint,
    t.origin = e.origin
}
function e_(t, e, n, i, r) {
    return t -= e,
    t = Au(t, 1 / n, i),
    r !== void 0 && (t = Au(t, 1 / r, i)),
    t
}
function iP(t, e=0, n=1, i=.5, r, s=t, o=t) {
    if (bi.test(e) && (e = parseFloat(e),
    e = xt(o.min, o.max, e / 100) - o.min),
    typeof e != "number")
        return;
    let a = xt(s.min, s.max, i);
    t === s && (a -= e),
    t.min = e_(t.min, e, n, a, r),
    t.max = e_(t.max, e, n, a, r)
}
function t_(t, e, [n,i,r], s, o) {
    iP(t, e[n], e[i], e[r], e.scale, s, o)
}
const rP = ["x", "scaleX", "originX"]
  , sP = ["y", "scaleY", "originY"];
function n_(t, e, n, i) {
    t_(t.x, e, rP, n ? n.x : void 0, i ? i.x : void 0),
    t_(t.y, e, sP, n ? n.y : void 0, i ? i.y : void 0)
}
function i_(t) {
    return t.translate === 0 && t.scale === 1
}
function mb(t) {
    return i_(t.x) && i_(t.y)
}
function r_(t, e) {
    return t.min === e.min && t.max === e.max
}
function oP(t, e) {
    return r_(t.x, e.x) && r_(t.y, e.y)
}
function s_(t, e) {
    return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max)
}
function gb(t, e) {
    return s_(t.x, e.x) && s_(t.y, e.y)
}
function o_(t) {
    return ln(t.x) / ln(t.y)
}
function a_(t, e) {
    return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint
}
class aP {
    constructor() {
        this.members = []
    }
    add(e) {
        Ym(this.members, e),
        e.scheduleRender()
    }
    remove(e) {
        if (Zm(this.members, e),
        e === this.prevLead && (this.prevLead = void 0),
        e === this.lead) {
            const n = this.members[this.members.length - 1];
            n && this.promote(n)
        }
    }
    relegate(e) {
        const n = this.members.findIndex(r => e === r);
        if (n === 0)
            return !1;
        let i;
        for (let r = n; r >= 0; r--) {
            const s = this.members[r];
            if (s.isPresent !== !1) {
                i = s;
                break
            }
        }
        return i ? (this.promote(i),
        !0) : !1
    }
    promote(e, n) {
        const i = this.lead;
        if (e !== i && (this.prevLead = i,
        this.lead = e,
        e.show(),
        i)) {
            i.instance && i.scheduleRender(),
            e.scheduleRender(),
            e.resumeFrom = i,
            n && (e.resumeFrom.preserveOpacity = !0),
            i.snapshot && (e.snapshot = i.snapshot,
            e.snapshot.latestValues = i.animationValues || i.latestValues),
            e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {crossfade: r} = e.options;
            r === !1 && i.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e => {
            const {options: n, resumingFrom: i} = e;
            n.onExitComplete && n.onExitComplete(),
            i && i.options.onExitComplete && i.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function lP(t, e, n) {
    let i = "";
    const r = t.x.translate / e.x
      , s = t.y.translate / e.y
      , o = (n == null ? void 0 : n.z) || 0;
    if ((r || s || o) && (i = `translate3d(${r}px, ${s}px, ${o}px) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    n) {
        const {transformPerspective: c, rotate: u, rotateX: d, rotateY: h, skewX: p, skewY: v} = n;
        c && (i = `perspective(${c}px) ${i}`),
        u && (i += `rotate(${u}deg) `),
        d && (i += `rotateX(${d}deg) `),
        h && (i += `rotateY(${h}deg) `),
        p && (i += `skewX(${p}deg) `),
        v && (i += `skewY(${v}deg) `)
    }
    const a = t.x.scale * e.x
      , l = t.y.scale * e.y;
    return (a !== 1 || l !== 1) && (i += `scale(${a}, ${l})`),
    i || "none"
}
const Kd = ["", "X", "Y", "Z"]
  , cP = 1e3;
let uP = 0;
function Yd(t, e, n, i) {
    const {latestValues: r} = e;
    r[t] && (n[t] = r[t],
    e.setStaticValue(t, 0),
    i && (i[t] = 0))
}
function vb(t) {
    if (t.hasCheckedOptimisedAppear = !0,
    t.root === t)
        return;
    const {visualElement: e} = t.options;
    if (!e)
        return;
    const n = nb(e);
    if (window.MotionHasOptimisedAnimation(n, "transform")) {
        const {layout: r, layoutId: s} = t.options;
        window.MotionCancelOptimisedAnimation(n, "transform", gt, !(r || s))
    }
    const {parent: i} = t;
    i && !i.hasCheckedOptimisedAppear && vb(i)
}
function _b({attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: i, resetTransform: r}) {
    return class {
        constructor(o={}, a=e == null ? void 0 : e()) {
            this.id = uP++,
            this.animationId = 0,
            this.animationCommitId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.hasCheckedOptimisedAppear = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.scheduleUpdate = () => this.update(),
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
                this.projectionUpdateScheduled = !1,
                this.nodes.forEach(fP),
                this.nodes.forEach(vP),
                this.nodes.forEach(_P),
                this.nodes.forEach(pP)
            }
            ,
            this.resolvedRelativeTargetAt = 0,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = o,
            this.root = a ? a.root || a : this,
            this.path = a ? [...a.path, a] : [],
            this.parent = a,
            this.depth = a ? a.depth + 1 : 0;
            for (let l = 0; l < this.path.length; l++)
                this.path[l].shouldResetTransform = !0;
            this.root === this && (this.nodes = new ZR)
        }
        addEventListener(o, a) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Qm),
            this.eventHandlers.get(o).add(a)
        }
        notifyListeners(o, ...a) {
            const l = this.eventHandlers.get(o);
            l && l.notify(...a)
        }
        hasListeners(o) {
            return this.eventHandlers.has(o)
        }
        mount(o) {
            if (this.instance)
                return;
            this.isSVG = Lw(o) && !sC(o),
            this.instance = o;
            const {layoutId: a, layout: l, visualElement: c} = this.options;
            if (c && !c.current && c.mount(o),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0),
            t) {
                let u, d = 0;
                const h = () => this.root.updateBlockedByResize = !1;
                gt.read( () => {
                    d = window.innerWidth
                }
                ),
                t(o, () => {
                    const p = window.innerWidth;
                    p !== d && (d = p,
                    this.root.updateBlockedByResize = !0,
                    u && u(),
                    u = JR(h, 250),
                    Gc.hasAnimatedSinceResize && (Gc.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(u_)))
                }
                )
            }
            a && this.root.registerSharedNode(a, this),
            this.options.animate !== !1 && c && (a || l) && this.addEventListener("didUpdate", ({delta: u, hasLayoutChanged: d, hasRelativeLayoutChanged: h, layout: p}) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const v = this.options.transition || c.getDefaultTransition() || bP
                  , {onLayoutAnimationStart: x, onLayoutAnimationComplete: g} = c.getProps()
                  , f = !this.targetLayout || !gb(this.targetLayout, p)
                  , y = !d && h;
                if (this.options.layoutRoot || this.resumeFrom || y || d && (f || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0);
                    const _ = {
                        ...hg(v, "layout"),
                        onPlay: x,
                        onComplete: g
                    };
                    (c.shouldReduceMotion || this.options.layoutRoot) && (_.delay = 0,
                    _.type = !1),
                    this.startAnimation(_),
                    this.setAnimationOrigin(u, y)
                } else
                    d || u_(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = p
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            this.eventHandlers.clear(),
            Nr(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(yP),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: o} = this.options;
            return o && o.getProps().transformTemplate
        }
        willUpdate(o=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && vb(this),
            !this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let u = 0; u < this.path.length; u++) {
                const d = this.path[u];
                d.shouldResetTransform = !0,
                d.updateScroll("snapshot"),
                d.options.layoutRoot && d.willUpdate(!1)
            }
            const {layoutId: a, layout: l} = this.options;
            if (a === void 0 && !l)
                return;
            const c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            o && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(l_);
                return
            }
            if (this.animationId <= this.animationCommitId) {
                this.nodes.forEach(c_);
                return
            }
            this.animationCommitId = this.animationId,
            this.isUpdating ? (this.isUpdating = !1,
            this.nodes.forEach(gP),
            this.nodes.forEach(dP),
            this.nodes.forEach(hP)) : this.nodes.forEach(c_),
            this.clearAllSnapshots();
            const a = vn.now();
            $t.delta = qi(0, 1e3 / 60, a - $t.timestamp),
            $t.timestamp = a,
            $t.isProcessing = !0,
            Fd.update.process($t),
            Fd.preRender.process($t),
            Fd.render.process($t),
            $t.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            pg.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(mP),
            this.sharedNodes.forEach(xP)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            gt.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            gt.postRender( () => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure(),
            this.snapshot && !ln(this.snapshot.measuredBox.x) && !ln(this.snapshot.measuredBox.y) && (this.snapshot = void 0))
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let l = 0; l < this.path.length; l++)
                    this.path[l].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = At(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: a} = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
        }
        updateScroll(o="measure") {
            let a = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1),
            a && this.instance) {
                const l = i(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: o,
                    isRoot: l,
                    offset: n(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : l
                }
            }
        }
        resetTransform() {
            if (!r)
                return;
            const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
              , a = this.projectionDelta && !mb(this.projectionDelta)
              , l = this.getTransformTemplate()
              , c = l ? l(this.latestValues, "") : void 0
              , u = c !== this.prevTransformTemplateValue;
            o && this.instance && (a || Qr(this.latestValues) || u) && (r(this.instance, c),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(o=!0) {
            const a = this.measurePageBox();
            let l = this.removeElementScroll(a);
            return o && (l = this.removeTransform(l)),
            EP(l),
            {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var c;
            const {visualElement: o} = this.options;
            if (!o)
                return At();
            const a = o.measureViewportBox();
            if (!(((c = this.scroll) == null ? void 0 : c.wasRoot) || this.path.some(TP))) {
                const {scroll: u} = this.root;
                u && (ho(a.x, u.offset.x),
                ho(a.y, u.offset.y))
            }
            return a
        }
        removeElementScroll(o) {
            var l;
            const a = At();
            if (Un(a, o),
            (l = this.scroll) != null && l.wasRoot)
                return a;
            for (let c = 0; c < this.path.length; c++) {
                const u = this.path[c]
                  , {scroll: d, options: h} = u;
                u !== this.root && d && h.layoutScroll && (d.wasRoot && Un(a, o),
                ho(a.x, d.offset.x),
                ho(a.y, d.offset.y))
            }
            return a
        }
        applyTransform(o, a=!1) {
            const l = At();
            Un(l, o);
            for (let c = 0; c < this.path.length; c++) {
                const u = this.path[c];
                !a && u.options.layoutScroll && u.scroll && u !== u.root && fo(l, {
                    x: -u.scroll.offset.x,
                    y: -u.scroll.offset.y
                }),
                Qr(u.latestValues) && fo(l, u.latestValues)
            }
            return Qr(this.latestValues) && fo(l, this.latestValues),
            l
        }
        removeTransform(o) {
            const a = At();
            Un(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l];
                if (!c.instance || !Qr(c.latestValues))
                    continue;
                Gf(c.latestValues) && c.updateSnapshot();
                const u = At()
                  , d = c.measurePageBox();
                Un(u, d),
                n_(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u)
            }
            return Qr(this.latestValues) && n_(a, this.latestValues),
            a
        }
        setTargetDelta(o) {
            this.targetDelta = o,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(o) {
            this.options = {
                ...this.options,
                ...o,
                crossfade: o.crossfade !== void 0 ? o.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== $t.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(o=!1) {
            var h;
            const a = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty);
            const l = !!this.resumingFrom || this !== a;
            if (!(o || l && this.isSharedProjectionDirty || this.isProjectionDirty || (h = this.parent) != null && h.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
                return;
            const {layout: u, layoutId: d} = this.options;
            if (!(!this.layout || !(u || d))) {
                if (this.resolvedRelativeTargetAt = $t.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const p = this.getClosestProjectingParent();
                    p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = At(),
                    this.relativeTargetOrigin = At(),
                    La(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox),
                    Un(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = At(),
                this.targetWithTransforms = At()),
                this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                NR(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Un(this.target, this.layout.layoutBox),
                Yw(this.target, this.targetDelta)) : Un(this.target, this.layout.layoutBox),
                this.attemptToResolveRelativeTarget)) {
                    this.attemptToResolveRelativeTarget = !1;
                    const p = this.getClosestProjectingParent();
                    p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = At(),
                    this.relativeTargetOrigin = At(),
                    La(this.relativeTargetOrigin, this.target, p.target),
                    Un(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || Gf(this.parent.latestValues) || Kw(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var v;
            const o = this.getLead()
              , a = !!this.resumingFrom || this !== o;
            let l = !0;
            if ((this.isProjectionDirty || (v = this.parent) != null && v.isProjectionDirty) && (l = !1),
            a && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1),
            this.resolvedRelativeTargetAt === $t.timestamp && (l = !1),
            l)
                return;
            const {layout: c, layoutId: u} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(c || u))
                return;
            Un(this.layoutCorrected, this.layout.layoutBox);
            const d = this.treeScale.x
              , h = this.treeScale.y;
            HC(this.layoutCorrected, this.treeScale, this.path, a),
            o.layout && !o.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (o.target = o.layout.layoutBox,
            o.targetWithTransforms = At());
            const {target: p} = o;
            if (!p) {
                this.prevProjectionDelta && (this.createProjectionDeltas(),
                this.scheduleRender());
                return
            }
            !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Qv(this.prevProjectionDelta.x, this.projectionDelta.x),
            Qv(this.prevProjectionDelta.y, this.projectionDelta.y)),
            Da(this.projectionDelta, this.layoutCorrected, p, this.latestValues),
            (this.treeScale.x !== d || this.treeScale.y !== h || !a_(this.projectionDelta.x, this.prevProjectionDelta.x) || !a_(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", p))
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(o=!0) {
            var a;
            if ((a = this.options.visualElement) == null || a.scheduleRender(),
            o) {
                const l = this.getStack();
                l && l.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = po(),
            this.projectionDelta = po(),
            this.projectionDeltaWithTransform = po()
        }
        setAnimationOrigin(o, a=!1) {
            const l = this.snapshot
              , c = l ? l.latestValues : {}
              , u = {
                ...this.latestValues
            }
              , d = po();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !a;
            const h = At()
              , p = l ? l.source : void 0
              , v = this.layout ? this.layout.source : void 0
              , x = p !== v
              , g = this.getStack()
              , f = !g || g.members.length <= 1
              , y = !!(x && !f && this.options.crossfade === !0 && !this.path.some(wP));
            this.animationProgress = 0;
            let _;
            this.mixTargetDelta = S => {
                const T = S / 1e3;
                d_(d.x, o.x, T),
                d_(d.y, o.y, T),
                this.setTargetDelta(d),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (La(h, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                SP(this.relativeTarget, this.relativeTargetOrigin, h, T),
                _ && oP(this.relativeTarget, _) && (this.isProjectionDirty = !1),
                _ || (_ = At()),
                Un(_, this.relativeTarget)),
                x && (this.animationValues = u,
                eP(u, c, this.latestValues, T, y, f)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = T
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(o) {
            var a, l, c;
            this.notifyListeners("animationStart"),
            (a = this.currentAnimation) == null || a.stop(),
            (c = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) == null || c.stop(),
            this.pendingAnimation && (Nr(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = gt.update( () => {
                Gc.hasAnimatedSinceResize = !0,
                this.motionValue || (this.motionValue = Do(0)),
                this.currentAnimation = KR(this.motionValue, [0, 1e3], {
                    ...o,
                    velocity: 0,
                    isSync: !0,
                    onUpdate: u => {
                        this.mixTargetDelta(u),
                        o.onUpdate && o.onUpdate(u)
                    }
                    ,
                    onStop: () => {}
                    ,
                    onComplete: () => {
                        o.onComplete && o.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(cP),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const o = this.getLead();
            let {targetWithTransforms: a, target: l, layout: c, latestValues: u} = o;
            if (!(!a || !l || !c)) {
                if (this !== o && this.layout && c && yb(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    l = this.target || At();
                    const d = ln(this.layout.layoutBox.x);
                    l.x.min = o.target.x.min,
                    l.x.max = l.x.min + d;
                    const h = ln(this.layout.layoutBox.y);
                    l.y.min = o.target.y.min,
                    l.y.max = l.y.min + h
                }
                Un(a, l),
                fo(a, u),
                Da(this.projectionDeltaWithTransform, this.layoutCorrected, a, u)
            }
        }
        registerSharedNode(o, a) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new aP),
            this.sharedNodes.get(o).add(a);
            const c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
        }
        getLead() {
            var a;
            const {layoutId: o} = this.options;
            return o ? ((a = this.getStack()) == null ? void 0 : a.lead) || this : this
        }
        getPrevLead() {
            var a;
            const {layoutId: o} = this.options;
            return o ? (a = this.getStack()) == null ? void 0 : a.prevLead : void 0
        }
        getStack() {
            const {layoutId: o} = this.options;
            if (o)
                return this.root.sharedNodes.get(o)
        }
        promote({needsReset: o, transition: a, preserveFollowOpacity: l}={}) {
            const c = this.getStack();
            c && c.promote(this, l),
            o && (this.projectionDelta = void 0,
            this.needsReset = !0),
            a && this.setOptions({
                transition: a
            })
        }
        relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: o} = this.options;
            if (!o)
                return;
            let a = !1;
            const {latestValues: l} = o;
            if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0),
            !a)
                return;
            const c = {};
            l.z && Yd("z", o, c, this.animationValues);
            for (let u = 0; u < Kd.length; u++)
                Yd(`rotate${Kd[u]}`, o, c, this.animationValues),
                Yd(`skew${Kd[u]}`, o, c, this.animationValues);
            o.render();
            for (const u in c)
                o.setStaticValue(u, c[u]),
                this.animationValues && (this.animationValues[u] = c[u]);
            o.scheduleRender()
        }
        applyProjectionStyles(o, a) {
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible) {
                o.visibility = "hidden";
                return
            }
            const l = this.getTransformTemplate();
            if (this.needsReset) {
                this.needsReset = !1,
                o.visibility = "",
                o.opacity = "",
                o.pointerEvents = Hc(a == null ? void 0 : a.pointerEvents) || "",
                o.transform = l ? l(this.latestValues, "") : "none";
                return
            }
            const c = this.getLead();
            if (!this.projectionDelta || !this.layout || !c.target) {
                this.options.layoutId && (o.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                o.pointerEvents = Hc(a == null ? void 0 : a.pointerEvents) || ""),
                this.hasProjected && !Qr(this.latestValues) && (o.transform = l ? l({}, "") : "none",
                this.hasProjected = !1);
                return
            }
            o.visibility = "";
            const u = c.animationValues || c.latestValues;
            this.applyTransformsToTarget();
            let d = lP(this.projectionDeltaWithTransform, this.treeScale, u);
            l && (d = l(u, d)),
            o.transform = d;
            const {x: h, y: p} = this.projectionDelta;
            o.transformOrigin = `${h.origin * 100}% ${p.origin * 100}% 0`,
            c.animationValues ? o.opacity = c === this ? u.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : u.opacityExit : o.opacity = c === this ? u.opacity !== void 0 ? u.opacity : "" : u.opacityExit !== void 0 ? u.opacityExit : 0;
            for (const v in rl) {
                if (u[v] === void 0)
                    continue;
                const {correct: x, applyTo: g, isCSSVariable: f} = rl[v]
                  , y = d === "none" ? u[v] : x(u[v], c);
                if (g) {
                    const _ = g.length;
                    for (let S = 0; S < _; S++)
                        o[g[S]] = y
                } else
                    f ? this.options.visualElement.renderState.vars[v] = y : o[v] = y
            }
            this.options.layoutId && (o.pointerEvents = c === this ? Hc(a == null ? void 0 : a.pointerEvents) || "" : "none")
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(o => {
                var a;
                return (a = o.currentAnimation) == null ? void 0 : a.stop()
            }
            ),
            this.root.nodes.forEach(l_),
            this.root.sharedNodes.clear()
        }
    }
}
function dP(t) {
    t.updateLayout()
}
function hP(t) {
    var n;
    const e = ((n = t.resumeFrom) == null ? void 0 : n.snapshot) || t.snapshot;
    if (t.isLead() && t.layout && e && t.hasListeners("didUpdate")) {
        const {layoutBox: i, measuredBox: r} = t.layout
          , {animationType: s} = t.options
          , o = e.source !== t.layout.source;
        s === "size" ? Fn(d => {
            const h = o ? e.measuredBox[d] : e.layoutBox[d]
              , p = ln(h);
            h.min = i[d].min,
            h.max = h.min + p
        }
        ) : yb(s, e.layoutBox, i) && Fn(d => {
            const h = o ? e.measuredBox[d] : e.layoutBox[d]
              , p = ln(i[d]);
            h.max = h.min + p,
            t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0,
            t.relativeTarget[d].max = t.relativeTarget[d].min + p)
        }
        );
        const a = po();
        Da(a, i, e.layoutBox);
        const l = po();
        o ? Da(l, t.applyTransform(r, !0), e.measuredBox) : Da(l, i, e.layoutBox);
        const c = !mb(a);
        let u = !1;
        if (!t.resumeFrom) {
            const d = t.getClosestProjectingParent();
            if (d && !d.resumeFrom) {
                const {snapshot: h, layout: p} = d;
                if (h && p) {
                    const v = At();
                    La(v, e.layoutBox, h.layoutBox);
                    const x = At();
                    La(x, i, p.layoutBox),
                    gb(v, x) || (u = !0),
                    d.options.layoutRoot && (t.relativeTarget = x,
                    t.relativeTargetOrigin = v,
                    t.relativeParent = d)
                }
            }
        }
        t.notifyListeners("didUpdate", {
            layout: i,
            snapshot: e,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeLayoutChanged: u
        })
    } else if (t.isLead()) {
        const {onExitComplete: i} = t.options;
        i && i()
    }
    t.options.transition = void 0
}
function fP(t) {
    t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty),
    t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)),
    t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty))
}
function pP(t) {
    t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
}
function mP(t) {
    t.clearSnapshot()
}
function l_(t) {
    t.clearMeasurements()
}
function c_(t) {
    t.isLayoutDirty = !1
}
function gP(t) {
    const {visualElement: e} = t.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    t.resetTransform()
}
function u_(t) {
    t.finishAnimation(),
    t.targetDelta = t.relativeTarget = t.target = void 0,
    t.isProjectionDirty = !0
}
function vP(t) {
    t.resolveTargetDelta()
}
function _P(t) {
    t.calcProjection()
}
function yP(t) {
    t.resetSkewAndRotation()
}
function xP(t) {
    t.removeLeadSnapshot()
}
function d_(t, e, n) {
    t.translate = xt(e.translate, 0, n),
    t.scale = xt(e.scale, 1, n),
    t.origin = e.origin,
    t.originPoint = e.originPoint
}
function h_(t, e, n, i) {
    t.min = xt(e.min, n.min, i),
    t.max = xt(e.max, n.max, i)
}
function SP(t, e, n, i) {
    h_(t.x, e.x, n.x, i),
    h_(t.y, e.y, n.y, i)
}
function wP(t) {
    return t.animationValues && t.animationValues.opacityExit !== void 0
}
const bP = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , f_ = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t)
  , p_ = f_("applewebkit/") && !f_("chrome/") ? Math.round : $n;
function m_(t) {
    t.min = p_(t.min),
    t.max = p_(t.max)
}
function EP(t) {
    m_(t.x),
    m_(t.y)
}
function yb(t, e, n) {
    return t === "position" || t === "preserve-aspect" && !PR(o_(e), o_(n), .2)
}
function TP(t) {
    var e;
    return t !== t.root && ((e = t.scroll) == null ? void 0 : e.wasRoot)
}
const MP = _b({
    attachResizeListener: (t, e) => sl(t, "resize", e),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
  , Zd = {
    current: void 0
}
  , xb = _b({
    measureScroll: t => ({
        x: t.scrollLeft,
        y: t.scrollTop
    }),
    defaultParent: () => {
        if (!Zd.current) {
            const t = new MP({});
            t.mount(window),
            t.setOptions({
                layoutScroll: !0
            }),
            Zd.current = t
        }
        return Zd.current
    }
    ,
    resetTransform: (t, e) => {
        t.style.transform = e !== void 0 ? e : "none"
    }
    ,
    checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed"
})
  , AP = {
    pan: {
        Feature: WR
    },
    drag: {
        Feature: GR,
        ProjectionNode: xb,
        MeasureLayout: hb
    }
};
function g_(t, e, n) {
    const {props: i} = t;
    t.animationState && i.whileHover && t.animationState.setActive("whileHover", n === "Start");
    const r = "onHover" + n
      , s = i[r];
    s && gt.postRender( () => s(e, Sl(e)))
}
class CP extends Fr {
    mount() {
        const {current: e} = this.node;
        e && (this.unmount = eC(e, (n, i) => (g_(this.node, i, "Start"),
        r => g_(this.node, r, "End"))))
    }
    unmount() {}
}
class RP extends Fr {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }
        !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = _l(sl(this.node.current, "focus", () => this.onFocus()), sl(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
function v_(t, e, n) {
    const {props: i} = t;
    if (t.current instanceof HTMLButtonElement && t.current.disabled)
        return;
    t.animationState && i.whileTap && t.animationState.setActive("whileTap", n === "Start");
    const r = "onTap" + (n === "End" ? "" : n)
      , s = i[r];
    s && gt.postRender( () => s(e, Sl(e)))
}
class PP extends Fr {
    mount() {
        const {current: e} = this.node;
        e && (this.unmount = rC(e, (n, i) => (v_(this.node, i, "Start"),
        (r, {success: s}) => v_(this.node, r, s ? "End" : "Cancel")), {
            useGlobalTarget: this.node.props.globalTapTarget
        }))
    }
    unmount() {}
}
const Zf = new WeakMap
  , Jd = new WeakMap
  , NP = t => {
    const e = Zf.get(t.target);
    e && e(t)
}
  , DP = t => {
    t.forEach(NP)
}
;
function LP({root: t, ...e}) {
    const n = t || document;
    Jd.has(n) || Jd.set(n, {});
    const i = Jd.get(n)
      , r = JSON.stringify(e);
    return i[r] || (i[r] = new IntersectionObserver(DP,{
        root: t,
        ...e
    })),
    i[r]
}
function IP(t, e, n) {
    const i = LP(e);
    return Zf.set(t, n),
    i.observe(t),
    () => {
        Zf.delete(t),
        i.unobserve(t)
    }
}
const kP = {
    some: 0,
    all: 1
};
class UP extends Fr {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: e={}} = this.node.getProps()
          , {root: n, margin: i, amount: r="some", once: s} = e
          , o = {
            root: n ? n.current : void 0,
            rootMargin: i,
            threshold: typeof r == "number" ? r : kP[r]
        }
          , a = l => {
            const {isIntersecting: c} = l;
            if (this.isInView === c || (this.isInView = c,
            s && !c && this.hasEnteredView))
                return;
            c && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", c);
            const {onViewportEnter: u, onViewportLeave: d} = this.node.getProps()
              , h = c ? u : d;
            h && h(l)
        }
        ;
        return IP(this.node.current, o, a)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: e, prevProps: n} = this.node;
        ["amount", "margin", "root"].some(OP(e, n)) && this.startObserver()
    }
    unmount() {}
}
function OP({viewport: t={}}, {viewport: e={}}={}) {
    return n => t[n] !== e[n]
}
const FP = {
    inView: {
        Feature: UP
    },
    tap: {
        Feature: PP
    },
    focus: {
        Feature: RP
    },
    hover: {
        Feature: CP
    }
}
  , BP = {
    layout: {
        ProjectionNode: xb,
        MeasureLayout: hb
    }
}
  , zP = {
    ...ER,
    ...FP,
    ...AP,
    ...BP
}
  , Rs = zC(zP, QC)
  , VP = "modulepreload"
  , jP = function(t) {
    return "/" + t
}
  , __ = {}
  , wl = function(e, n, i) {
    let r = Promise.resolve();
    if (n && n.length > 0) {
        document.getElementsByTagName("link");
        const o = document.querySelector("meta[property=csp-nonce]")
          , a = (o == null ? void 0 : o.nonce) || (o == null ? void 0 : o.getAttribute("nonce"));
        r = Promise.allSettled(n.map(l => {
            if (l = jP(l),
            l in __)
                return;
            __[l] = !0;
            const c = l.endsWith(".css")
              , u = c ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${l}"]${u}`))
                return;
            const d = document.createElement("link");
            if (d.rel = c ? "stylesheet" : VP,
            c || (d.as = "script"),
            d.crossOrigin = "",
            d.href = l,
            a && d.setAttribute("nonce", a),
            document.head.appendChild(d),
            c)
                return new Promise( (h, p) => {
                    d.addEventListener("load", h),
                    d.addEventListener("error", () => p(new Error(`Unable to preload CSS for ${l}`)))
                }
                )
        }
        ))
    }
    function s(o) {
        const a = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (a.payload = o,
        window.dispatchEvent(a),
        !a.defaultPrevented)
            throw o
    }
    return r.then(o => {
        for (const a of o || [])
            a.status === "rejected" && s(a.reason);
        return e().catch(s)
    }
    )
}
  , HP = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = (...n) => wl(async () => {
        const {default: i} = await Promise.resolve().then( () => $o);
        return {
            default: i
        }
    }
    , void 0).then( ({default: i}) => i(...n)) : e = fetch,
    (...n) => e(...n)
}
;
class Tg extends Error {
    constructor(e, n="FunctionsError", i) {
        super(e),
        this.name = n,
        this.context = i
    }
}
class GP extends Tg {
    constructor(e) {
        super("Failed to send a request to the Edge Function", "FunctionsFetchError", e)
    }
}
class y_ extends Tg {
    constructor(e) {
        super("Relay Error invoking the Edge Function", "FunctionsRelayError", e)
    }
}
class x_ extends Tg {
    constructor(e) {
        super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e)
    }
}
var Jf;
(function(t) {
    t.Any = "any",
    t.ApNortheast1 = "ap-northeast-1",
    t.ApNortheast2 = "ap-northeast-2",
    t.ApSouth1 = "ap-south-1",
    t.ApSoutheast1 = "ap-southeast-1",
    t.ApSoutheast2 = "ap-southeast-2",
    t.CaCentral1 = "ca-central-1",
    t.EuCentral1 = "eu-central-1",
    t.EuWest1 = "eu-west-1",
    t.EuWest2 = "eu-west-2",
    t.EuWest3 = "eu-west-3",
    t.SaEast1 = "sa-east-1",
    t.UsEast1 = "us-east-1",
    t.UsWest1 = "us-west-1",
    t.UsWest2 = "us-west-2"
}
)(Jf || (Jf = {}));
var WP = function(t, e, n, i) {
    function r(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(i.next(u))
            } catch (d) {
                o(d)
            }
        }
        function l(u) {
            try {
                c(i.throw(u))
            } catch (d) {
                o(d)
            }
        }
        function c(u) {
            u.done ? s(u.value) : r(u.value).then(a, l)
        }
        c((i = i.apply(t, e || [])).next())
    }
    )
};
class $P {
    constructor(e, {headers: n={}, customFetch: i, region: r=Jf.Any}={}) {
        this.url = e,
        this.headers = n,
        this.region = r,
        this.fetch = HP(i)
    }
    setAuth(e) {
        this.headers.Authorization = `Bearer ${e}`
    }
    invoke(e, n={}) {
        var i;
        return WP(this, void 0, void 0, function*() {
            try {
                const {headers: r, method: s, body: o} = n;
                let a = {}
                  , {region: l} = n;
                l || (l = this.region);
                const c = new URL(`${this.url}/${e}`);
                l && l !== "any" && (a["x-region"] = l,
                c.searchParams.set("forceFunctionRegion", l));
                let u;
                o && (r && !Object.prototype.hasOwnProperty.call(r, "Content-Type") || !r) && (typeof Blob < "u" && o instanceof Blob || o instanceof ArrayBuffer ? (a["Content-Type"] = "application/octet-stream",
                u = o) : typeof o == "string" ? (a["Content-Type"] = "text/plain",
                u = o) : typeof FormData < "u" && o instanceof FormData ? u = o : (a["Content-Type"] = "application/json",
                u = JSON.stringify(o)));
                const d = yield this.fetch(c.toString(), {
                    method: s || "POST",
                    headers: Object.assign(Object.assign(Object.assign({}, a), this.headers), r),
                    body: u
                }).catch(x => {
                    throw new GP(x)
                }
                )
                  , h = d.headers.get("x-relay-error");
                if (h && h === "true")
                    throw new y_(d);
                if (!d.ok)
                    throw new x_(d);
                let p = ((i = d.headers.get("Content-Type")) !== null && i !== void 0 ? i : "text/plain").split(";")[0].trim(), v;
                return p === "application/json" ? v = yield d.json() : p === "application/octet-stream" ? v = yield d.blob() : p === "text/event-stream" ? v = d : p === "multipart/form-data" ? v = yield d.formData() : v = yield d.text(),
                {
                    data: v,
                    error: null,
                    response: d
                }
            } catch (r) {
                return {
                    data: null,
                    error: r,
                    response: r instanceof x_ || r instanceof y_ ? r.context : void 0
                }
            }
        })
    }
}
var mn = {}
  , Mg = {}
  , Ju = {}
  , bl = {}
  , Qu = {}
  , ed = {}
  , XP = function() {
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("unable to locate global object")
}
  , Io = XP();
const qP = Io.fetch
  , Sb = Io.fetch.bind(Io)
  , wb = Io.Headers
  , KP = Io.Request
  , YP = Io.Response
  , $o = Object.freeze(Object.defineProperty({
    __proto__: null,
    Headers: wb,
    Request: KP,
    Response: YP,
    default: Sb,
    fetch: qP
}, Symbol.toStringTag, {
    value: "Module"
}))
  , ZP = RE($o);
var td = {};
Object.defineProperty(td, "__esModule", {
    value: !0
});
let JP = class extends Error {
    constructor(e) {
        super(e.message),
        this.name = "PostgrestError",
        this.details = e.details,
        this.hint = e.hint,
        this.code = e.code
    }
}
;
td.default = JP;
var bb = Xn && Xn.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(ed, "__esModule", {
    value: !0
});
const QP = bb(ZP)
  , e2 = bb(td);
let t2 = class {
    constructor(e) {
        var n, i;
        this.shouldThrowOnError = !1,
        this.method = e.method,
        this.url = e.url,
        this.headers = new Headers(e.headers),
        this.schema = e.schema,
        this.body = e.body,
        this.shouldThrowOnError = (n = e.shouldThrowOnError) !== null && n !== void 0 ? n : !1,
        this.signal = e.signal,
        this.isMaybeSingle = (i = e.isMaybeSingle) !== null && i !== void 0 ? i : !1,
        e.fetch ? this.fetch = e.fetch : typeof fetch > "u" ? this.fetch = QP.default : this.fetch = fetch
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    setHeader(e, n) {
        return this.headers = new Headers(this.headers),
        this.headers.set(e, n),
        this
    }
    then(e, n) {
        this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)),
        this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json");
        const i = this.fetch;
        let r = i(this.url.toString(), {
            method: this.method,
            headers: this.headers,
            body: JSON.stringify(this.body),
            signal: this.signal
        }).then(async s => {
            var o, a, l, c;
            let u = null
              , d = null
              , h = null
              , p = s.status
              , v = s.statusText;
            if (s.ok) {
                if (this.method !== "HEAD") {
                    const y = await s.text();
                    y === "" || (this.headers.get("Accept") === "text/csv" || this.headers.get("Accept") && (!((o = this.headers.get("Accept")) === null || o === void 0) && o.includes("application/vnd.pgrst.plan+text")) ? d = y : d = JSON.parse(y))
                }
                const g = (a = this.headers.get("Prefer")) === null || a === void 0 ? void 0 : a.match(/count=(exact|planned|estimated)/)
                  , f = (l = s.headers.get("content-range")) === null || l === void 0 ? void 0 : l.split("/");
                g && f && f.length > 1 && (h = parseInt(f[1])),
                this.isMaybeSingle && this.method === "GET" && Array.isArray(d) && (d.length > 1 ? (u = {
                    code: "PGRST116",
                    details: `Results contain ${d.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                    hint: null,
                    message: "JSON object requested, multiple (or no) rows returned"
                },
                d = null,
                h = null,
                p = 406,
                v = "Not Acceptable") : d.length === 1 ? d = d[0] : d = null)
            } else {
                const g = await s.text();
                try {
                    u = JSON.parse(g),
                    Array.isArray(u) && s.status === 404 && (d = [],
                    u = null,
                    p = 200,
                    v = "OK")
                } catch {
                    s.status === 404 && g === "" ? (p = 204,
                    v = "No Content") : u = {
                        message: g
                    }
                }
                if (u && this.isMaybeSingle && (!((c = u == null ? void 0 : u.details) === null || c === void 0) && c.includes("0 rows")) && (u = null,
                p = 200,
                v = "OK"),
                u && this.shouldThrowOnError)
                    throw new e2.default(u)
            }
            return {
                error: u,
                data: d,
                count: h,
                status: p,
                statusText: v
            }
        }
        );
        return this.shouldThrowOnError || (r = r.catch(s => {
            var o, a, l;
            return {
                error: {
                    message: `${(o = s == null ? void 0 : s.name) !== null && o !== void 0 ? o : "FetchError"}: ${s == null ? void 0 : s.message}`,
                    details: `${(a = s == null ? void 0 : s.stack) !== null && a !== void 0 ? a : ""}`,
                    hint: "",
                    code: `${(l = s == null ? void 0 : s.code) !== null && l !== void 0 ? l : ""}`
                },
                data: null,
                count: null,
                status: 0,
                statusText: ""
            }
        }
        )),
        r.then(e, n)
    }
    returns() {
        return this
    }
    overrideTypes() {
        return this
    }
}
;
ed.default = t2;
var n2 = Xn && Xn.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(Qu, "__esModule", {
    value: !0
});
const i2 = n2(ed);
let r2 = class extends i2.default {
    select(e) {
        let n = !1;
        const i = (e ?? "*").split("").map(r => /\s/.test(r) && !n ? "" : (r === '"' && (n = !n),
        r)).join("");
        return this.url.searchParams.set("select", i),
        this.headers.append("Prefer", "return=representation"),
        this
    }
    order(e, {ascending: n=!0, nullsFirst: i, foreignTable: r, referencedTable: s=r}={}) {
        const o = s ? `${s}.order` : "order"
          , a = this.url.searchParams.get(o);
        return this.url.searchParams.set(o, `${a ? `${a},` : ""}${e}.${n ? "asc" : "desc"}${i === void 0 ? "" : i ? ".nullsfirst" : ".nullslast"}`),
        this
    }
    limit(e, {foreignTable: n, referencedTable: i=n}={}) {
        const r = typeof i > "u" ? "limit" : `${i}.limit`;
        return this.url.searchParams.set(r, `${e}`),
        this
    }
    range(e, n, {foreignTable: i, referencedTable: r=i}={}) {
        const s = typeof r > "u" ? "offset" : `${r}.offset`
          , o = typeof r > "u" ? "limit" : `${r}.limit`;
        return this.url.searchParams.set(s, `${e}`),
        this.url.searchParams.set(o, `${n - e + 1}`),
        this
    }
    abortSignal(e) {
        return this.signal = e,
        this
    }
    single() {
        return this.headers.set("Accept", "application/vnd.pgrst.object+json"),
        this
    }
    maybeSingle() {
        return this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"),
        this.isMaybeSingle = !0,
        this
    }
    csv() {
        return this.headers.set("Accept", "text/csv"),
        this
    }
    geojson() {
        return this.headers.set("Accept", "application/geo+json"),
        this
    }
    explain({analyze: e=!1, verbose: n=!1, settings: i=!1, buffers: r=!1, wal: s=!1, format: o="text"}={}) {
        var a;
        const l = [e ? "analyze" : null, n ? "verbose" : null, i ? "settings" : null, r ? "buffers" : null, s ? "wal" : null].filter(Boolean).join("|")
          , c = (a = this.headers.get("Accept")) !== null && a !== void 0 ? a : "application/json";
        return this.headers.set("Accept", `application/vnd.pgrst.plan+${o}; for="${c}"; options=${l};`),
        o === "json" ? this : this
    }
    rollback() {
        return this.headers.append("Prefer", "tx=rollback"),
        this
    }
    returns() {
        return this
    }
    maxAffected(e) {
        return this.headers.append("Prefer", "handling=strict"),
        this.headers.append("Prefer", `max-affected=${e}`),
        this
    }
}
;
Qu.default = r2;
var s2 = Xn && Xn.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(bl, "__esModule", {
    value: !0
});
const o2 = s2(Qu);
let a2 = class extends o2.default {
    eq(e, n) {
        return this.url.searchParams.append(e, `eq.${n}`),
        this
    }
    neq(e, n) {
        return this.url.searchParams.append(e, `neq.${n}`),
        this
    }
    gt(e, n) {
        return this.url.searchParams.append(e, `gt.${n}`),
        this
    }
    gte(e, n) {
        return this.url.searchParams.append(e, `gte.${n}`),
        this
    }
    lt(e, n) {
        return this.url.searchParams.append(e, `lt.${n}`),
        this
    }
    lte(e, n) {
        return this.url.searchParams.append(e, `lte.${n}`),
        this
    }
    like(e, n) {
        return this.url.searchParams.append(e, `like.${n}`),
        this
    }
    likeAllOf(e, n) {
        return this.url.searchParams.append(e, `like(all).{${n.join(",")}}`),
        this
    }
    likeAnyOf(e, n) {
        return this.url.searchParams.append(e, `like(any).{${n.join(",")}}`),
        this
    }
    ilike(e, n) {
        return this.url.searchParams.append(e, `ilike.${n}`),
        this
    }
    ilikeAllOf(e, n) {
        return this.url.searchParams.append(e, `ilike(all).{${n.join(",")}}`),
        this
    }
    ilikeAnyOf(e, n) {
        return this.url.searchParams.append(e, `ilike(any).{${n.join(",")}}`),
        this
    }
    is(e, n) {
        return this.url.searchParams.append(e, `is.${n}`),
        this
    }
    in(e, n) {
        const i = Array.from(new Set(n)).map(r => typeof r == "string" && new RegExp("[,()]").test(r) ? `"${r}"` : `${r}`).join(",");
        return this.url.searchParams.append(e, `in.(${i})`),
        this
    }
    contains(e, n) {
        return typeof n == "string" ? this.url.searchParams.append(e, `cs.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cs.{${n.join(",")}}`) : this.url.searchParams.append(e, `cs.${JSON.stringify(n)}`),
        this
    }
    containedBy(e, n) {
        return typeof n == "string" ? this.url.searchParams.append(e, `cd.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cd.{${n.join(",")}}`) : this.url.searchParams.append(e, `cd.${JSON.stringify(n)}`),
        this
    }
    rangeGt(e, n) {
        return this.url.searchParams.append(e, `sr.${n}`),
        this
    }
    rangeGte(e, n) {
        return this.url.searchParams.append(e, `nxl.${n}`),
        this
    }
    rangeLt(e, n) {
        return this.url.searchParams.append(e, `sl.${n}`),
        this
    }
    rangeLte(e, n) {
        return this.url.searchParams.append(e, `nxr.${n}`),
        this
    }
    rangeAdjacent(e, n) {
        return this.url.searchParams.append(e, `adj.${n}`),
        this
    }
    overlaps(e, n) {
        return typeof n == "string" ? this.url.searchParams.append(e, `ov.${n}`) : this.url.searchParams.append(e, `ov.{${n.join(",")}}`),
        this
    }
    textSearch(e, n, {config: i, type: r}={}) {
        let s = "";
        r === "plain" ? s = "pl" : r === "phrase" ? s = "ph" : r === "websearch" && (s = "w");
        const o = i === void 0 ? "" : `(${i})`;
        return this.url.searchParams.append(e, `${s}fts${o}.${n}`),
        this
    }
    match(e) {
        return Object.entries(e).forEach( ([n,i]) => {
            this.url.searchParams.append(n, `eq.${i}`)
        }
        ),
        this
    }
    not(e, n, i) {
        return this.url.searchParams.append(e, `not.${n}.${i}`),
        this
    }
    or(e, {foreignTable: n, referencedTable: i=n}={}) {
        const r = i ? `${i}.or` : "or";
        return this.url.searchParams.append(r, `(${e})`),
        this
    }
    filter(e, n, i) {
        return this.url.searchParams.append(e, `${n}.${i}`),
        this
    }
}
;
bl.default = a2;
var l2 = Xn && Xn.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(Ju, "__esModule", {
    value: !0
});
const aa = l2(bl);
let c2 = class {
    constructor(e, {headers: n={}, schema: i, fetch: r}) {
        this.url = e,
        this.headers = new Headers(n),
        this.schema = i,
        this.fetch = r
    }
    select(e, {head: n=!1, count: i}={}) {
        const r = n ? "HEAD" : "GET";
        let s = !1;
        const o = (e ?? "*").split("").map(a => /\s/.test(a) && !s ? "" : (a === '"' && (s = !s),
        a)).join("");
        return this.url.searchParams.set("select", o),
        i && this.headers.append("Prefer", `count=${i}`),
        new aa.default({
            method: r,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            fetch: this.fetch
        })
    }
    insert(e, {count: n, defaultToNull: i=!0}={}) {
        var r;
        const s = "POST";
        if (n && this.headers.append("Prefer", `count=${n}`),
        i || this.headers.append("Prefer", "missing=default"),
        Array.isArray(e)) {
            const o = e.reduce( (a, l) => a.concat(Object.keys(l)), []);
            if (o.length > 0) {
                const a = [...new Set(o)].map(l => `"${l}"`);
                this.url.searchParams.set("columns", a.join(","))
            }
        }
        return new aa.default({
            method: s,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: e,
            fetch: (r = this.fetch) !== null && r !== void 0 ? r : fetch
        })
    }
    upsert(e, {onConflict: n, ignoreDuplicates: i=!1, count: r, defaultToNull: s=!0}={}) {
        var o;
        const a = "POST";
        if (this.headers.append("Prefer", `resolution=${i ? "ignore" : "merge"}-duplicates`),
        n !== void 0 && this.url.searchParams.set("on_conflict", n),
        r && this.headers.append("Prefer", `count=${r}`),
        s || this.headers.append("Prefer", "missing=default"),
        Array.isArray(e)) {
            const l = e.reduce( (c, u) => c.concat(Object.keys(u)), []);
            if (l.length > 0) {
                const c = [...new Set(l)].map(u => `"${u}"`);
                this.url.searchParams.set("columns", c.join(","))
            }
        }
        return new aa.default({
            method: a,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: e,
            fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch
        })
    }
    update(e, {count: n}={}) {
        var i;
        const r = "PATCH";
        return n && this.headers.append("Prefer", `count=${n}`),
        new aa.default({
            method: r,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            body: e,
            fetch: (i = this.fetch) !== null && i !== void 0 ? i : fetch
        })
    }
    delete({count: e}={}) {
        var n;
        const i = "DELETE";
        return e && this.headers.append("Prefer", `count=${e}`),
        new aa.default({
            method: i,
            url: this.url,
            headers: this.headers,
            schema: this.schema,
            fetch: (n = this.fetch) !== null && n !== void 0 ? n : fetch
        })
    }
}
;
Ju.default = c2;
var Eb = Xn && Xn.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(Mg, "__esModule", {
    value: !0
});
const u2 = Eb(Ju)
  , d2 = Eb(bl);
let h2 = class Tb {
    constructor(e, {headers: n={}, schema: i, fetch: r}={}) {
        this.url = e,
        this.headers = new Headers(n),
        this.schemaName = i,
        this.fetch = r
    }
    from(e) {
        const n = new URL(`${this.url}/${e}`);
        return new u2.default(n,{
            headers: new Headers(this.headers),
            schema: this.schemaName,
            fetch: this.fetch
        })
    }
    schema(e) {
        return new Tb(this.url,{
            headers: this.headers,
            schema: e,
            fetch: this.fetch
        })
    }
    rpc(e, n={}, {head: i=!1, get: r=!1, count: s}={}) {
        var o;
        let a;
        const l = new URL(`${this.url}/rpc/${e}`);
        let c;
        i || r ? (a = i ? "HEAD" : "GET",
        Object.entries(n).filter( ([d,h]) => h !== void 0).map( ([d,h]) => [d, Array.isArray(h) ? `{${h.join(",")}}` : `${h}`]).forEach( ([d,h]) => {
            l.searchParams.append(d, h)
        }
        )) : (a = "POST",
        c = n);
        const u = new Headers(this.headers);
        return s && u.set("Prefer", `count=${s}`),
        new d2.default({
            method: a,
            url: l,
            headers: u,
            schema: this.schemaName,
            body: c,
            fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch
        })
    }
}
;
Mg.default = h2;
var Xo = Xn && Xn.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
;
Object.defineProperty(mn, "__esModule", {
    value: !0
});
mn.PostgrestError = mn.PostgrestBuilder = mn.PostgrestTransformBuilder = mn.PostgrestFilterBuilder = mn.PostgrestQueryBuilder = mn.PostgrestClient = void 0;
const Mb = Xo(Mg);
mn.PostgrestClient = Mb.default;
const Ab = Xo(Ju);
mn.PostgrestQueryBuilder = Ab.default;
const Cb = Xo(bl);
mn.PostgrestFilterBuilder = Cb.default;
const Rb = Xo(Qu);
mn.PostgrestTransformBuilder = Rb.default;
const Pb = Xo(ed);
mn.PostgrestBuilder = Pb.default;
const Nb = Xo(td);
mn.PostgrestError = Nb.default;
var f2 = mn.default = {
    PostgrestClient: Mb.default,
    PostgrestQueryBuilder: Ab.default,
    PostgrestFilterBuilder: Cb.default,
    PostgrestTransformBuilder: Rb.default,
    PostgrestBuilder: Pb.default,
    PostgrestError: Nb.default
};
const {PostgrestClient: p2, PostgrestQueryBuilder: RO, PostgrestFilterBuilder: PO, PostgrestTransformBuilder: NO, PostgrestBuilder: DO, PostgrestError: LO} = f2;
class m2 {
    static detectEnvironment() {
        var e;
        if (typeof WebSocket < "u")
            return {
                type: "native",
                constructor: WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u")
            return {
                type: "native",
                constructor: globalThis.WebSocket
            };
        if (typeof global < "u" && typeof global.WebSocket < "u")
            return {
                type: "native",
                constructor: global.WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocketPair < "u" && typeof globalThis.WebSocket > "u")
            return {
                type: "cloudflare",
                error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
                workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
            };
        if (typeof globalThis < "u" && globalThis.EdgeRuntime || typeof navigator < "u" && (!((e = navigator.userAgent) === null || e === void 0) && e.includes("Vercel-Edge")))
            return {
                type: "unsupported",
                error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
                workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
            };
        if (typeof process < "u") {
            const n = process.versions;
            if (n && n.node) {
                const i = n.node
                  , r = parseInt(i.replace(/^v/, "").split(".")[0]);
                return r >= 22 ? typeof globalThis.WebSocket < "u" ? {
                    type: "native",
                    constructor: globalThis.WebSocket
                } : {
                    type: "unsupported",
                    error: `Node.js ${r} detected but native WebSocket not found.`,
                    workaround: "Provide a WebSocket implementation via the transport option."
                } : {
                    type: "unsupported",
                    error: `Node.js ${r} detected without native WebSocket support.`,
                    workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`
                }
            }
        }
        return {
            type: "unsupported",
            error: "Unknown JavaScript runtime without WebSocket support.",
            workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
        }
    }
    static getWebSocketConstructor() {
        const e = this.detectEnvironment();
        if (e.constructor)
            return e.constructor;
        let n = e.error || "WebSocket not supported in this environment.";
        throw e.workaround && (n += `

Suggested solution: ${e.workaround}`),
        new Error(n)
    }
    static createWebSocket(e, n) {
        const i = this.getWebSocketConstructor();
        return new i(e,n)
    }
    static isWebSocketSupported() {
        try {
            const e = this.detectEnvironment();
            return e.type === "native" || e.type === "ws"
        } catch {
            return !1
        }
    }
}
const g2 = "2.15.5"
  , v2 = `realtime-js/${g2}`
  , _2 = "1.0.0"
  , Qf = 1e4
  , y2 = 1e3
  , x2 = 100;
var Ia;
(function(t) {
    t[t.connecting = 0] = "connecting",
    t[t.open = 1] = "open",
    t[t.closing = 2] = "closing",
    t[t.closed = 3] = "closed"
}
)(Ia || (Ia = {}));
var kt;
(function(t) {
    t.closed = "closed",
    t.errored = "errored",
    t.joined = "joined",
    t.joining = "joining",
    t.leaving = "leaving"
}
)(kt || (kt = {}));
var ri;
(function(t) {
    t.close = "phx_close",
    t.error = "phx_error",
    t.join = "phx_join",
    t.reply = "phx_reply",
    t.leave = "phx_leave",
    t.access_token = "access_token"
}
)(ri || (ri = {}));
var ep;
(function(t) {
    t.websocket = "websocket"
}
)(ep || (ep = {}));
var is;
(function(t) {
    t.Connecting = "connecting",
    t.Open = "open",
    t.Closing = "closing",
    t.Closed = "closed"
}
)(is || (is = {}));
class S2 {
    constructor() {
        this.HEADER_LENGTH = 1
    }
    decode(e, n) {
        return e.constructor === ArrayBuffer ? n(this._binaryDecode(e)) : n(typeof e == "string" ? JSON.parse(e) : {})
    }
    _binaryDecode(e) {
        const n = new DataView(e)
          , i = new TextDecoder;
        return this._decodeBroadcast(e, n, i)
    }
    _decodeBroadcast(e, n, i) {
        const r = n.getUint8(1)
          , s = n.getUint8(2);
        let o = this.HEADER_LENGTH + 2;
        const a = i.decode(e.slice(o, o + r));
        o = o + r;
        const l = i.decode(e.slice(o, o + s));
        o = o + s;
        const c = JSON.parse(i.decode(e.slice(o, e.byteLength)));
        return {
            ref: null,
            topic: a,
            event: l,
            payload: c
        }
    }
}
class Db {
    constructor(e, n) {
        this.callback = e,
        this.timerCalc = n,
        this.timer = void 0,
        this.tries = 0,
        this.callback = e,
        this.timerCalc = n
    }
    reset() {
        this.tries = 0,
        clearTimeout(this.timer),
        this.timer = void 0
    }
    scheduleTimeout() {
        clearTimeout(this.timer),
        this.timer = setTimeout( () => {
            this.tries = this.tries + 1,
            this.callback()
        }
        , this.timerCalc(this.tries + 1))
    }
}
var lt;
(function(t) {
    t.abstime = "abstime",
    t.bool = "bool",
    t.date = "date",
    t.daterange = "daterange",
    t.float4 = "float4",
    t.float8 = "float8",
    t.int2 = "int2",
    t.int4 = "int4",
    t.int4range = "int4range",
    t.int8 = "int8",
    t.int8range = "int8range",
    t.json = "json",
    t.jsonb = "jsonb",
    t.money = "money",
    t.numeric = "numeric",
    t.oid = "oid",
    t.reltime = "reltime",
    t.text = "text",
    t.time = "time",
    t.timestamp = "timestamp",
    t.timestamptz = "timestamptz",
    t.timetz = "timetz",
    t.tsrange = "tsrange",
    t.tstzrange = "tstzrange"
}
)(lt || (lt = {}));
const S_ = (t, e, n={}) => {
    var i;
    const r = (i = n.skipTypes) !== null && i !== void 0 ? i : [];
    return Object.keys(e).reduce( (s, o) => (s[o] = w2(o, t, e, r),
    s), {})
}
  , w2 = (t, e, n, i) => {
    const r = e.find(a => a.name === t)
      , s = r == null ? void 0 : r.type
      , o = n[t];
    return s && !i.includes(s) ? Lb(s, o) : tp(o)
}
  , Lb = (t, e) => {
    if (t.charAt(0) === "_") {
        const n = t.slice(1, t.length);
        return M2(e, n)
    }
    switch (t) {
    case lt.bool:
        return b2(e);
    case lt.float4:
    case lt.float8:
    case lt.int2:
    case lt.int4:
    case lt.int8:
    case lt.numeric:
    case lt.oid:
        return E2(e);
    case lt.json:
    case lt.jsonb:
        return T2(e);
    case lt.timestamp:
        return A2(e);
    case lt.abstime:
    case lt.date:
    case lt.daterange:
    case lt.int4range:
    case lt.int8range:
    case lt.money:
    case lt.reltime:
    case lt.text:
    case lt.time:
    case lt.timestamptz:
    case lt.timetz:
    case lt.tsrange:
    case lt.tstzrange:
        return tp(e);
    default:
        return tp(e)
    }
}
  , tp = t => t
  , b2 = t => {
    switch (t) {
    case "t":
        return !0;
    case "f":
        return !1;
    default:
        return t
    }
}
  , E2 = t => {
    if (typeof t == "string") {
        const e = parseFloat(t);
        if (!Number.isNaN(e))
            return e
    }
    return t
}
  , T2 = t => {
    if (typeof t == "string")
        try {
            return JSON.parse(t)
        } catch (e) {
            return console.log(`JSON parse error: ${e}`),
            t
        }
    return t
}
  , M2 = (t, e) => {
    if (typeof t != "string")
        return t;
    const n = t.length - 1
      , i = t[n];
    if (t[0] === "{" && i === "}") {
        let s;
        const o = t.slice(1, n);
        try {
            s = JSON.parse("[" + o + "]")
        } catch {
            s = o ? o.split(",") : []
        }
        return s.map(a => Lb(e, a))
    }
    return t
}
  , A2 = t => typeof t == "string" ? t.replace(" ", "T") : t
  , Ib = t => {
    let e = t;
    return e = e.replace(/^ws/i, "http"),
    e = e.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, ""),
    e.replace(/\/+$/, "") + "/api/broadcast"
}
;
class Qd {
    constructor(e, n, i={}, r=Qf) {
        this.channel = e,
        this.event = n,
        this.payload = i,
        this.timeout = r,
        this.sent = !1,
        this.timeoutTimer = void 0,
        this.ref = "",
        this.receivedResp = null,
        this.recHooks = [],
        this.refEvent = null
    }
    resend(e) {
        this.timeout = e,
        this._cancelRefEvent(),
        this.ref = "",
        this.refEvent = null,
        this.receivedResp = null,
        this.sent = !1,
        this.send()
    }
    send() {
        this._hasReceived("timeout") || (this.startTimeout(),
        this.sent = !0,
        this.channel.socket.push({
            topic: this.channel.topic,
            event: this.event,
            payload: this.payload,
            ref: this.ref,
            join_ref: this.channel._joinRef()
        }))
    }
    updatePayload(e) {
        this.payload = Object.assign(Object.assign({}, this.payload), e)
    }
    receive(e, n) {
        var i;
        return this._hasReceived(e) && n((i = this.receivedResp) === null || i === void 0 ? void 0 : i.response),
        this.recHooks.push({
            status: e,
            callback: n
        }),
        this
    }
    startTimeout() {
        if (this.timeoutTimer)
            return;
        this.ref = this.channel.socket._makeRef(),
        this.refEvent = this.channel._replyEventName(this.ref);
        const e = n => {
            this._cancelRefEvent(),
            this._cancelTimeout(),
            this.receivedResp = n,
            this._matchReceive(n)
        }
        ;
        this.channel._on(this.refEvent, {}, e),
        this.timeoutTimer = setTimeout( () => {
            this.trigger("timeout", {})
        }
        , this.timeout)
    }
    trigger(e, n) {
        this.refEvent && this.channel._trigger(this.refEvent, {
            status: e,
            response: n
        })
    }
    destroy() {
        this._cancelRefEvent(),
        this._cancelTimeout()
    }
    _cancelRefEvent() {
        this.refEvent && this.channel._off(this.refEvent, {})
    }
    _cancelTimeout() {
        clearTimeout(this.timeoutTimer),
        this.timeoutTimer = void 0
    }
    _matchReceive({status: e, response: n}) {
        this.recHooks.filter(i => i.status === e).forEach(i => i.callback(n))
    }
    _hasReceived(e) {
        return this.receivedResp && this.receivedResp.status === e
    }
}
var w_;
(function(t) {
    t.SYNC = "sync",
    t.JOIN = "join",
    t.LEAVE = "leave"
}
)(w_ || (w_ = {}));
class ka {
    constructor(e, n) {
        this.channel = e,
        this.state = {},
        this.pendingDiffs = [],
        this.joinRef = null,
        this.enabled = !1,
        this.caller = {
            onJoin: () => {}
            ,
            onLeave: () => {}
            ,
            onSync: () => {}
        };
        const i = (n == null ? void 0 : n.events) || {
            state: "presence_state",
            diff: "presence_diff"
        };
        this.channel._on(i.state, {}, r => {
            const {onJoin: s, onLeave: o, onSync: a} = this.caller;
            this.joinRef = this.channel._joinRef(),
            this.state = ka.syncState(this.state, r, s, o),
            this.pendingDiffs.forEach(l => {
                this.state = ka.syncDiff(this.state, l, s, o)
            }
            ),
            this.pendingDiffs = [],
            a()
        }
        ),
        this.channel._on(i.diff, {}, r => {
            const {onJoin: s, onLeave: o, onSync: a} = this.caller;
            this.inPendingSyncState() ? this.pendingDiffs.push(r) : (this.state = ka.syncDiff(this.state, r, s, o),
            a())
        }
        ),
        this.onJoin( (r, s, o) => {
            this.channel._trigger("presence", {
                event: "join",
                key: r,
                currentPresences: s,
                newPresences: o
            })
        }
        ),
        this.onLeave( (r, s, o) => {
            this.channel._trigger("presence", {
                event: "leave",
                key: r,
                currentPresences: s,
                leftPresences: o
            })
        }
        ),
        this.onSync( () => {
            this.channel._trigger("presence", {
                event: "sync"
            })
        }
        )
    }
    static syncState(e, n, i, r) {
        const s = this.cloneDeep(e)
          , o = this.transformState(n)
          , a = {}
          , l = {};
        return this.map(s, (c, u) => {
            o[c] || (l[c] = u)
        }
        ),
        this.map(o, (c, u) => {
            const d = s[c];
            if (d) {
                const h = u.map(g => g.presence_ref)
                  , p = d.map(g => g.presence_ref)
                  , v = u.filter(g => p.indexOf(g.presence_ref) < 0)
                  , x = d.filter(g => h.indexOf(g.presence_ref) < 0);
                v.length > 0 && (a[c] = v),
                x.length > 0 && (l[c] = x)
            } else
                a[c] = u
        }
        ),
        this.syncDiff(s, {
            joins: a,
            leaves: l
        }, i, r)
    }
    static syncDiff(e, n, i, r) {
        const {joins: s, leaves: o} = {
            joins: this.transformState(n.joins),
            leaves: this.transformState(n.leaves)
        };
        return i || (i = () => {}
        ),
        r || (r = () => {}
        ),
        this.map(s, (a, l) => {
            var c;
            const u = (c = e[a]) !== null && c !== void 0 ? c : [];
            if (e[a] = this.cloneDeep(l),
            u.length > 0) {
                const d = e[a].map(p => p.presence_ref)
                  , h = u.filter(p => d.indexOf(p.presence_ref) < 0);
                e[a].unshift(...h)
            }
            i(a, u, l)
        }
        ),
        this.map(o, (a, l) => {
            let c = e[a];
            if (!c)
                return;
            const u = l.map(d => d.presence_ref);
            c = c.filter(d => u.indexOf(d.presence_ref) < 0),
            e[a] = c,
            r(a, c, l),
            c.length === 0 && delete e[a]
        }
        ),
        e
    }
    static map(e, n) {
        return Object.getOwnPropertyNames(e).map(i => n(i, e[i]))
    }
    static transformState(e) {
        return e = this.cloneDeep(e),
        Object.getOwnPropertyNames(e).reduce( (n, i) => {
            const r = e[i];
            return "metas"in r ? n[i] = r.metas.map(s => (s.presence_ref = s.phx_ref,
            delete s.phx_ref,
            delete s.phx_ref_prev,
            s)) : n[i] = r,
            n
        }
        , {})
    }
    static cloneDeep(e) {
        return JSON.parse(JSON.stringify(e))
    }
    onJoin(e) {
        this.caller.onJoin = e
    }
    onLeave(e) {
        this.caller.onLeave = e
    }
    onSync(e) {
        this.caller.onSync = e
    }
    inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel._joinRef()
    }
}
var b_;
(function(t) {
    t.ALL = "*",
    t.INSERT = "INSERT",
    t.UPDATE = "UPDATE",
    t.DELETE = "DELETE"
}
)(b_ || (b_ = {}));
var Ua;
(function(t) {
    t.BROADCAST = "broadcast",
    t.PRESENCE = "presence",
    t.POSTGRES_CHANGES = "postgres_changes",
    t.SYSTEM = "system"
}
)(Ua || (Ua = {}));
var Ii;
(function(t) {
    t.SUBSCRIBED = "SUBSCRIBED",
    t.TIMED_OUT = "TIMED_OUT",
    t.CLOSED = "CLOSED",
    t.CHANNEL_ERROR = "CHANNEL_ERROR"
}
)(Ii || (Ii = {}));
class Ag {
    constructor(e, n={
        config: {}
    }, i) {
        this.topic = e,
        this.params = n,
        this.socket = i,
        this.bindings = {},
        this.state = kt.closed,
        this.joinedOnce = !1,
        this.pushBuffer = [],
        this.subTopic = e.replace(/^realtime:/i, ""),
        this.params.config = Object.assign({
            broadcast: {
                ack: !1,
                self: !1
            },
            presence: {
                key: "",
                enabled: !1
            },
            private: !1
        }, n.config),
        this.timeout = this.socket.timeout,
        this.joinPush = new Qd(this,ri.join,this.params,this.timeout),
        this.rejoinTimer = new Db( () => this._rejoinUntilConnected(),this.socket.reconnectAfterMs),
        this.joinPush.receive("ok", () => {
            this.state = kt.joined,
            this.rejoinTimer.reset(),
            this.pushBuffer.forEach(r => r.send()),
            this.pushBuffer = []
        }
        ),
        this._onClose( () => {
            this.rejoinTimer.reset(),
            this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
            this.state = kt.closed,
            this.socket._remove(this)
        }
        ),
        this._onError(r => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, r),
            this.state = kt.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("timeout", () => {
            this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout),
            this.state = kt.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("error", r => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, r),
            this.state = kt.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this._on(ri.reply, {}, (r, s) => {
            this._trigger(this._replyEventName(s), r)
        }
        ),
        this.presence = new ka(this),
        this.broadcastEndpointURL = Ib(this.socket.endPoint),
        this.private = this.params.config.private || !1
    }
    subscribe(e, n=this.timeout) {
        var i, r, s;
        if (this.socket.isConnected() || this.socket.connect(),
        this.state == kt.closed) {
            const {config: {broadcast: o, presence: a, private: l}} = this.params
              , c = (r = (i = this.bindings.postgres_changes) === null || i === void 0 ? void 0 : i.map(p => p.filter)) !== null && r !== void 0 ? r : []
              , u = !!this.bindings[Ua.PRESENCE] && this.bindings[Ua.PRESENCE].length > 0 || ((s = this.params.config.presence) === null || s === void 0 ? void 0 : s.enabled) === !0
              , d = {}
              , h = {
                broadcast: o,
                presence: Object.assign(Object.assign({}, a), {
                    enabled: u
                }),
                postgres_changes: c,
                private: l
            };
            this.socket.accessTokenValue && (d.access_token = this.socket.accessTokenValue),
            this._onError(p => e == null ? void 0 : e(Ii.CHANNEL_ERROR, p)),
            this._onClose( () => e == null ? void 0 : e(Ii.CLOSED)),
            this.updateJoinPayload(Object.assign({
                config: h
            }, d)),
            this.joinedOnce = !0,
            this._rejoin(n),
            this.joinPush.receive("ok", async ({postgres_changes: p}) => {
                var v;
                if (this.socket.setAuth(),
                p === void 0) {
                    e == null || e(Ii.SUBSCRIBED);
                    return
                } else {
                    const x = this.bindings.postgres_changes
                      , g = (v = x == null ? void 0 : x.length) !== null && v !== void 0 ? v : 0
                      , f = [];
                    for (let y = 0; y < g; y++) {
                        const _ = x[y]
                          , {filter: {event: S, schema: T, table: A, filter: C}} = _
                          , P = p && p[y];
                        if (P && P.event === S && P.schema === T && P.table === A && P.filter === C)
                            f.push(Object.assign(Object.assign({}, _), {
                                id: P.id
                            }));
                        else {
                            this.unsubscribe(),
                            this.state = kt.errored,
                            e == null || e(Ii.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                            return
                        }
                    }
                    this.bindings.postgres_changes = f,
                    e && e(Ii.SUBSCRIBED);
                    return
                }
            }
            ).receive("error", p => {
                this.state = kt.errored,
                e == null || e(Ii.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(p).join(", ") || "error")))
            }
            ).receive("timeout", () => {
                e == null || e(Ii.TIMED_OUT)
            }
            )
        }
        return this
    }
    presenceState() {
        return this.presence.state
    }
    async track(e, n={}) {
        return await this.send({
            type: "presence",
            event: "track",
            payload: e
        }, n.timeout || this.timeout)
    }
    async untrack(e={}) {
        return await this.send({
            type: "presence",
            event: "untrack"
        }, e)
    }
    on(e, n, i) {
        return this.state === kt.joined && e === Ua.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),
        this.unsubscribe().then( () => this.subscribe())),
        this._on(e, n, i)
    }
    async send(e, n={}) {
        var i, r;
        if (!this._canPush() && e.type === "broadcast") {
            const {event: s, payload: o} = e
              , l = {
                method: "POST",
                headers: {
                    Authorization: this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "",
                    apikey: this.socket.apiKey ? this.socket.apiKey : "",
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    messages: [{
                        topic: this.subTopic,
                        event: s,
                        payload: o,
                        private: this.private
                    }]
                })
            };
            try {
                const c = await this._fetchWithTimeout(this.broadcastEndpointURL, l, (i = n.timeout) !== null && i !== void 0 ? i : this.timeout);
                return await ((r = c.body) === null || r === void 0 ? void 0 : r.cancel()),
                c.ok ? "ok" : "error"
            } catch (c) {
                return c.name === "AbortError" ? "timed out" : "error"
            }
        } else
            return new Promise(s => {
                var o, a, l;
                const c = this._push(e.type, e, n.timeout || this.timeout);
                e.type === "broadcast" && !(!((l = (a = (o = this.params) === null || o === void 0 ? void 0 : o.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.ack) && s("ok"),
                c.receive("ok", () => s("ok")),
                c.receive("error", () => s("error")),
                c.receive("timeout", () => s("timed out"))
            }
            )
    }
    updateJoinPayload(e) {
        this.joinPush.updatePayload(e)
    }
    unsubscribe(e=this.timeout) {
        this.state = kt.leaving;
        const n = () => {
            this.socket.log("channel", `leave ${this.topic}`),
            this._trigger(ri.close, "leave", this._joinRef())
        }
        ;
        this.joinPush.destroy();
        let i = null;
        return new Promise(r => {
            i = new Qd(this,ri.leave,{},e),
            i.receive("ok", () => {
                n(),
                r("ok")
            }
            ).receive("timeout", () => {
                n(),
                r("timed out")
            }
            ).receive("error", () => {
                r("error")
            }
            ),
            i.send(),
            this._canPush() || i.trigger("ok", {})
        }
        ).finally( () => {
            i == null || i.destroy()
        }
        )
    }
    teardown() {
        this.pushBuffer.forEach(e => e.destroy()),
        this.pushBuffer = [],
        this.rejoinTimer.reset(),
        this.joinPush.destroy(),
        this.state = kt.closed,
        this.bindings = {}
    }
    async _fetchWithTimeout(e, n, i) {
        const r = new AbortController
          , s = setTimeout( () => r.abort(), i)
          , o = await this.socket.fetch(e, Object.assign(Object.assign({}, n), {
            signal: r.signal
        }));
        return clearTimeout(s),
        o
    }
    _push(e, n, i=this.timeout) {
        if (!this.joinedOnce)
            throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        let r = new Qd(this,e,n,i);
        return this._canPush() ? r.send() : this._addToPushBuffer(r),
        r
    }
    _addToPushBuffer(e) {
        if (e.startTimeout(),
        this.pushBuffer.push(e),
        this.pushBuffer.length > x2) {
            const n = this.pushBuffer.shift();
            n && (n.destroy(),
            this.socket.log("channel", `discarded push due to buffer overflow: ${n.event}`, n.payload))
        }
    }
    _onMessage(e, n, i) {
        return n
    }
    _isMember(e) {
        return this.topic === e
    }
    _joinRef() {
        return this.joinPush.ref
    }
    _trigger(e, n, i) {
        var r, s;
        const o = e.toLocaleLowerCase()
          , {close: a, error: l, leave: c, join: u} = ri;
        if (i && [a, l, c, u].indexOf(o) >= 0 && i !== this._joinRef())
            return;
        let h = this._onMessage(o, n, i);
        if (n && !h)
            throw "channel onMessage callbacks must return the payload, modified or unmodified";
        ["insert", "update", "delete"].includes(o) ? (r = this.bindings.postgres_changes) === null || r === void 0 || r.filter(p => {
            var v, x, g;
            return ((v = p.filter) === null || v === void 0 ? void 0 : v.event) === "*" || ((g = (x = p.filter) === null || x === void 0 ? void 0 : x.event) === null || g === void 0 ? void 0 : g.toLocaleLowerCase()) === o
        }
        ).map(p => p.callback(h, i)) : (s = this.bindings[o]) === null || s === void 0 || s.filter(p => {
            var v, x, g, f, y, _;
            if (["broadcast", "presence", "postgres_changes"].includes(o))
                if ("id"in p) {
                    const S = p.id
                      , T = (v = p.filter) === null || v === void 0 ? void 0 : v.event;
                    return S && ((x = n.ids) === null || x === void 0 ? void 0 : x.includes(S)) && (T === "*" || (T == null ? void 0 : T.toLocaleLowerCase()) === ((g = n.data) === null || g === void 0 ? void 0 : g.type.toLocaleLowerCase()))
                } else {
                    const S = (y = (f = p == null ? void 0 : p.filter) === null || f === void 0 ? void 0 : f.event) === null || y === void 0 ? void 0 : y.toLocaleLowerCase();
                    return S === "*" || S === ((_ = n == null ? void 0 : n.event) === null || _ === void 0 ? void 0 : _.toLocaleLowerCase())
                }
            else
                return p.type.toLocaleLowerCase() === o
        }
        ).map(p => {
            if (typeof h == "object" && "ids"in h) {
                const v = h.data
                  , {schema: x, table: g, commit_timestamp: f, type: y, errors: _} = v;
                h = Object.assign(Object.assign({}, {
                    schema: x,
                    table: g,
                    commit_timestamp: f,
                    eventType: y,
                    new: {},
                    old: {},
                    errors: _
                }), this._getPayloadRecords(v))
            }
            p.callback(h, i)
        }
        )
    }
    _isClosed() {
        return this.state === kt.closed
    }
    _isJoined() {
        return this.state === kt.joined
    }
    _isJoining() {
        return this.state === kt.joining
    }
    _isLeaving() {
        return this.state === kt.leaving
    }
    _replyEventName(e) {
        return `chan_reply_${e}`
    }
    _on(e, n, i) {
        const r = e.toLocaleLowerCase()
          , s = {
            type: r,
            filter: n,
            callback: i
        };
        return this.bindings[r] ? this.bindings[r].push(s) : this.bindings[r] = [s],
        this
    }
    _off(e, n) {
        const i = e.toLocaleLowerCase();
        return this.bindings[i] && (this.bindings[i] = this.bindings[i].filter(r => {
            var s;
            return !(((s = r.type) === null || s === void 0 ? void 0 : s.toLocaleLowerCase()) === i && Ag.isEqual(r.filter, n))
        }
        )),
        this
    }
    static isEqual(e, n) {
        if (Object.keys(e).length !== Object.keys(n).length)
            return !1;
        for (const i in e)
            if (e[i] !== n[i])
                return !1;
        return !0
    }
    _rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout(),
        this.socket.isConnected() && this._rejoin()
    }
    _onClose(e) {
        this._on(ri.close, {}, e)
    }
    _onError(e) {
        this._on(ri.error, {}, n => e(n))
    }
    _canPush() {
        return this.socket.isConnected() && this._isJoined()
    }
    _rejoin(e=this.timeout) {
        this._isLeaving() || (this.socket._leaveOpenTopic(this.topic),
        this.state = kt.joining,
        this.joinPush.resend(e))
    }
    _getPayloadRecords(e) {
        const n = {
            new: {},
            old: {}
        };
        return (e.type === "INSERT" || e.type === "UPDATE") && (n.new = S_(e.columns, e.record)),
        (e.type === "UPDATE" || e.type === "DELETE") && (n.old = S_(e.columns, e.old_record)),
        n
    }
}
const eh = () => {}
  , tc = {
    HEARTBEAT_INTERVAL: 25e3,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100
}
  , C2 = [1e3, 2e3, 5e3, 1e4]
  , R2 = 1e4
  , P2 = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class N2 {
    constructor(e, n) {
        var i;
        if (this.accessTokenValue = null,
        this.apiKey = null,
        this.channels = new Array,
        this.endPoint = "",
        this.httpEndpoint = "",
        this.headers = {},
        this.params = {},
        this.timeout = Qf,
        this.transport = null,
        this.heartbeatIntervalMs = tc.HEARTBEAT_INTERVAL,
        this.heartbeatTimer = void 0,
        this.pendingHeartbeatRef = null,
        this.heartbeatCallback = eh,
        this.ref = 0,
        this.reconnectTimer = null,
        this.logger = eh,
        this.conn = null,
        this.sendBuffer = [],
        this.serializer = new S2,
        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: []
        },
        this.accessToken = null,
        this._connectionState = "disconnected",
        this._wasManualDisconnect = !1,
        this._authPromise = null,
        this._resolveFetch = r => {
            let s;
            return r ? s = r : typeof fetch > "u" ? s = (...o) => wl(async () => {
                const {default: a} = await Promise.resolve().then( () => $o);
                return {
                    default: a
                }
            }
            , void 0).then( ({default: a}) => a(...o)).catch(a => {
                throw new Error(`Failed to load @supabase/node-fetch: ${a.message}. This is required for HTTP requests in Node.js environments without native fetch.`)
            }
            ) : s = fetch,
            (...o) => s(...o)
        }
        ,
        !(!((i = n == null ? void 0 : n.params) === null || i === void 0) && i.apikey))
            throw new Error("API key is required to connect to Realtime");
        this.apiKey = n.params.apikey,
        this.endPoint = `${e}/${ep.websocket}`,
        this.httpEndpoint = Ib(e),
        this._initializeOptions(n),
        this._setupReconnectionTimer(),
        this.fetch = this._resolveFetch(n == null ? void 0 : n.fetch)
    }
    connect() {
        if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
            if (this._setConnectionState("connecting"),
            this._setAuthSafely("connect"),
            this.transport)
                this.conn = new this.transport(this.endpointURL());
            else
                try {
                    this.conn = m2.createWebSocket(this.endpointURL())
                } catch (e) {
                    this._setConnectionState("disconnected");
                    const n = e.message;
                    throw n.includes("Node.js") ? new Error(`${n}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`) : new Error(`WebSocket not available: ${n}`)
                }
            this._setupConnectionHandlers()
        }
    }
    endpointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, {
            vsn: _2
        }))
    }
    disconnect(e, n) {
        if (!this.isDisconnecting())
            if (this._setConnectionState("disconnecting", !0),
            this.conn) {
                const i = setTimeout( () => {
                    this._setConnectionState("disconnected")
                }
                , 100);
                this.conn.onclose = () => {
                    clearTimeout(i),
                    this._setConnectionState("disconnected")
                }
                ,
                e ? this.conn.close(e, n ?? "") : this.conn.close(),
                this._teardownConnection()
            } else
                this._setConnectionState("disconnected")
    }
    getChannels() {
        return this.channels
    }
    async removeChannel(e) {
        const n = await e.unsubscribe();
        return this.channels.length === 0 && this.disconnect(),
        n
    }
    async removeAllChannels() {
        const e = await Promise.all(this.channels.map(n => n.unsubscribe()));
        return this.channels = [],
        this.disconnect(),
        e
    }
    log(e, n, i) {
        this.logger(e, n, i)
    }
    connectionState() {
        switch (this.conn && this.conn.readyState) {
        case Ia.connecting:
            return is.Connecting;
        case Ia.open:
            return is.Open;
        case Ia.closing:
            return is.Closing;
        default:
            return is.Closed
        }
    }
    isConnected() {
        return this.connectionState() === is.Open
    }
    isConnecting() {
        return this._connectionState === "connecting"
    }
    isDisconnecting() {
        return this._connectionState === "disconnecting"
    }
    channel(e, n={
        config: {}
    }) {
        const i = `realtime:${e}`
          , r = this.getChannels().find(s => s.topic === i);
        if (r)
            return r;
        {
            const s = new Ag(`realtime:${e}`,n,this);
            return this.channels.push(s),
            s
        }
    }
    push(e) {
        const {topic: n, event: i, payload: r, ref: s} = e
          , o = () => {
            this.encode(e, a => {
                var l;
                (l = this.conn) === null || l === void 0 || l.send(a)
            }
            )
        }
        ;
        this.log("push", `${n} ${i} (${s})`, r),
        this.isConnected() ? o() : this.sendBuffer.push(o)
    }
    async setAuth(e=null) {
        this._authPromise = this._performAuth(e);
        try {
            await this._authPromise
        } finally {
            this._authPromise = null
        }
    }
    async sendHeartbeat() {
        var e;
        if (!this.isConnected()) {
            try {
                this.heartbeatCallback("disconnected")
            } catch (n) {
                this.log("error", "error in heartbeat callback", n)
            }
            return
        }
        if (this.pendingHeartbeatRef) {
            this.pendingHeartbeatRef = null,
            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
            try {
                this.heartbeatCallback("timeout")
            } catch (n) {
                this.log("error", "error in heartbeat callback", n)
            }
            this._wasManualDisconnect = !1,
            (e = this.conn) === null || e === void 0 || e.close(y2, "heartbeat timeout"),
            setTimeout( () => {
                var n;
                this.isConnected() || (n = this.reconnectTimer) === null || n === void 0 || n.scheduleTimeout()
            }
            , tc.HEARTBEAT_TIMEOUT_FALLBACK);
            return
        }
        this.pendingHeartbeatRef = this._makeRef(),
        this.push({
            topic: "phoenix",
            event: "heartbeat",
            payload: {},
            ref: this.pendingHeartbeatRef
        });
        try {
            this.heartbeatCallback("sent")
        } catch (n) {
            this.log("error", "error in heartbeat callback", n)
        }
        this._setAuthSafely("heartbeat")
    }
    onHeartbeat(e) {
        this.heartbeatCallback = e
    }
    flushSendBuffer() {
        this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()),
        this.sendBuffer = [])
    }
    _makeRef() {
        let e = this.ref + 1;
        return e === this.ref ? this.ref = 0 : this.ref = e,
        this.ref.toString()
    }
    _leaveOpenTopic(e) {
        let n = this.channels.find(i => i.topic === e && (i._isJoined() || i._isJoining()));
        n && (this.log("transport", `leaving duplicate topic "${e}"`),
        n.unsubscribe())
    }
    _remove(e) {
        this.channels = this.channels.filter(n => n.topic !== e.topic)
    }
    _onConnMessage(e) {
        this.decode(e.data, n => {
            if (n.topic === "phoenix" && n.event === "phx_reply")
                try {
                    this.heartbeatCallback(n.payload.status === "ok" ? "ok" : "error")
                } catch (c) {
                    this.log("error", "error in heartbeat callback", c)
                }
            n.ref && n.ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
            const {topic: i, event: r, payload: s, ref: o} = n
              , a = o ? `(${o})` : ""
              , l = s.status || "";
            this.log("receive", `${l} ${i} ${r} ${a}`.trim(), s),
            this.channels.filter(c => c._isMember(i)).forEach(c => c._trigger(r, s, o)),
            this._triggerStateCallbacks("message", n)
        }
        )
    }
    _clearTimer(e) {
        var n;
        e === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = void 0) : e === "reconnect" && ((n = this.reconnectTimer) === null || n === void 0 || n.reset())
    }
    _clearAllTimers() {
        this._clearTimer("heartbeat"),
        this._clearTimer("reconnect")
    }
    _setupConnectionHandlers() {
        this.conn && ("binaryType"in this.conn && (this.conn.binaryType = "arraybuffer"),
        this.conn.onopen = () => this._onConnOpen(),
        this.conn.onerror = e => this._onConnError(e),
        this.conn.onmessage = e => this._onConnMessage(e),
        this.conn.onclose = e => this._onConnClose(e))
    }
    _teardownConnection() {
        this.conn && (this.conn.onopen = null,
        this.conn.onerror = null,
        this.conn.onmessage = null,
        this.conn.onclose = null,
        this.conn = null),
        this._clearAllTimers(),
        this.channels.forEach(e => e.teardown())
    }
    _onConnOpen() {
        this._setConnectionState("connected"),
        this.log("transport", `connected to ${this.endpointURL()}`),
        this.flushSendBuffer(),
        this._clearTimer("reconnect"),
        this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(),
        this._triggerStateCallbacks("open")
    }
    _startHeartbeat() {
        this.heartbeatTimer && clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = setInterval( () => this.sendHeartbeat(), this.heartbeatIntervalMs)
    }
    _startWorkerHeartbeat() {
        this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
        const e = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(e),
        this.workerRef.onerror = n => {
            this.log("worker", "worker error", n.message),
            this.workerRef.terminate()
        }
        ,
        this.workerRef.onmessage = n => {
            n.data.event === "keepAlive" && this.sendHeartbeat()
        }
        ,
        this.workerRef.postMessage({
            event: "start",
            interval: this.heartbeatIntervalMs
        })
    }
    _onConnClose(e) {
        var n;
        this._setConnectionState("disconnected"),
        this.log("transport", "close", e),
        this._triggerChanError(),
        this._clearTimer("heartbeat"),
        this._wasManualDisconnect || (n = this.reconnectTimer) === null || n === void 0 || n.scheduleTimeout(),
        this._triggerStateCallbacks("close", e)
    }
    _onConnError(e) {
        this._setConnectionState("disconnected"),
        this.log("transport", `${e}`),
        this._triggerChanError(),
        this._triggerStateCallbacks("error", e)
    }
    _triggerChanError() {
        this.channels.forEach(e => e._trigger(ri.error))
    }
    _appendParams(e, n) {
        if (Object.keys(n).length === 0)
            return e;
        const i = e.match(/\?/) ? "&" : "?"
          , r = new URLSearchParams(n);
        return `${e}${i}${r}`
    }
    _workerObjectUrl(e) {
        let n;
        if (e)
            n = e;
        else {
            const i = new Blob([P2],{
                type: "application/javascript"
            });
            n = URL.createObjectURL(i)
        }
        return n
    }
    _setConnectionState(e, n=!1) {
        this._connectionState = e,
        e === "connecting" ? this._wasManualDisconnect = !1 : e === "disconnecting" && (this._wasManualDisconnect = n)
    }
    async _performAuth(e=null) {
        let n;
        e ? n = e : this.accessToken ? n = await this.accessToken() : n = this.accessTokenValue,
        this.accessTokenValue != n && (this.accessTokenValue = n,
        this.channels.forEach(i => {
            const r = {
                access_token: n,
                version: v2
            };
            n && i.updateJoinPayload(r),
            i.joinedOnce && i._isJoined() && i._push(ri.access_token, {
                access_token: n
            })
        }
        ))
    }
    async _waitForAuthIfNeeded() {
        this._authPromise && await this._authPromise
    }
    _setAuthSafely(e="general") {
        this.setAuth().catch(n => {
            this.log("error", `error setting auth in ${e}`, n)
        }
        )
    }
    _triggerStateCallbacks(e, n) {
        try {
            this.stateChangeCallbacks[e].forEach(i => {
                try {
                    i(n)
                } catch (r) {
                    this.log("error", `error in ${e} callback`, r)
                }
            }
            )
        } catch (i) {
            this.log("error", `error triggering ${e} callbacks`, i)
        }
    }
    _setupReconnectionTimer() {
        this.reconnectTimer = new Db(async () => {
            setTimeout(async () => {
                await this._waitForAuthIfNeeded(),
                this.isConnected() || this.connect()
            }
            , tc.RECONNECT_DELAY)
        }
        ,this.reconnectAfterMs)
    }
    _initializeOptions(e) {
        var n, i, r, s, o, a, l, c, u;
        if (this.transport = (n = e == null ? void 0 : e.transport) !== null && n !== void 0 ? n : null,
        this.timeout = (i = e == null ? void 0 : e.timeout) !== null && i !== void 0 ? i : Qf,
        this.heartbeatIntervalMs = (r = e == null ? void 0 : e.heartbeatIntervalMs) !== null && r !== void 0 ? r : tc.HEARTBEAT_INTERVAL,
        this.worker = (s = e == null ? void 0 : e.worker) !== null && s !== void 0 ? s : !1,
        this.accessToken = (o = e == null ? void 0 : e.accessToken) !== null && o !== void 0 ? o : null,
        this.heartbeatCallback = (a = e == null ? void 0 : e.heartbeatCallback) !== null && a !== void 0 ? a : eh,
        e != null && e.params && (this.params = e.params),
        e != null && e.logger && (this.logger = e.logger),
        (e != null && e.logLevel || e != null && e.log_level) && (this.logLevel = e.logLevel || e.log_level,
        this.params = Object.assign(Object.assign({}, this.params), {
            log_level: this.logLevel
        })),
        this.reconnectAfterMs = (l = e == null ? void 0 : e.reconnectAfterMs) !== null && l !== void 0 ? l : d => C2[d - 1] || R2,
        this.encode = (c = e == null ? void 0 : e.encode) !== null && c !== void 0 ? c : (d, h) => h(JSON.stringify(d)),
        this.decode = (u = e == null ? void 0 : e.decode) !== null && u !== void 0 ? u : this.serializer.decode.bind(this.serializer),
        this.worker) {
            if (typeof window < "u" && !window.Worker)
                throw new Error("Web Worker is not supported");
            this.workerUrl = e == null ? void 0 : e.workerUrl
        }
    }
}
class Cg extends Error {
    constructor(e) {
        super(e),
        this.__isStorageError = !0,
        this.name = "StorageError"
    }
}
function Ut(t) {
    return typeof t == "object" && t !== null && "__isStorageError"in t
}
class D2 extends Cg {
    constructor(e, n, i) {
        super(e),
        this.name = "StorageApiError",
        this.status = n,
        this.statusCode = i
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
class np extends Cg {
    constructor(e, n) {
        super(e),
        this.name = "StorageUnknownError",
        this.originalError = n
    }
}
var L2 = function(t, e, n, i) {
    function r(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(i.next(u))
            } catch (d) {
                o(d)
            }
        }
        function l(u) {
            try {
                c(i.throw(u))
            } catch (d) {
                o(d)
            }
        }
        function c(u) {
            u.done ? s(u.value) : r(u.value).then(a, l)
        }
        c((i = i.apply(t, e || [])).next())
    }
    )
};
const kb = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = (...n) => wl(async () => {
        const {default: i} = await Promise.resolve().then( () => $o);
        return {
            default: i
        }
    }
    , void 0).then( ({default: i}) => i(...n)) : e = fetch,
    (...n) => e(...n)
}
  , I2 = () => L2(void 0, void 0, void 0, function*() {
    return typeof Response > "u" ? (yield wl( () => Promise.resolve().then( () => $o), void 0)).Response : Response
})
  , ip = t => {
    if (Array.isArray(t))
        return t.map(n => ip(n));
    if (typeof t == "function" || t !== Object(t))
        return t;
    const e = {};
    return Object.entries(t).forEach( ([n,i]) => {
        const r = n.replace(/([-_][a-z])/gi, s => s.toUpperCase().replace(/[-_]/g, ""));
        e[r] = ip(i)
    }
    ),
    e
}
  , k2 = t => {
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
;
var Ms = function(t, e, n, i) {
    function r(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(i.next(u))
            } catch (d) {
                o(d)
            }
        }
        function l(u) {
            try {
                c(i.throw(u))
            } catch (d) {
                o(d)
            }
        }
        function c(u) {
            u.done ? s(u.value) : r(u.value).then(a, l)
        }
        c((i = i.apply(t, e || [])).next())
    }
    )
};
const th = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , U2 = (t, e, n) => Ms(void 0, void 0, void 0, function*() {
    const i = yield I2();
    t instanceof i && !(n != null && n.noResolveJson) ? t.json().then(r => {
        const s = t.status || 500
          , o = (r == null ? void 0 : r.statusCode) || s + "";
        e(new D2(th(r),s,o))
    }
    ).catch(r => {
        e(new np(th(r),r))
    }
    ) : e(new np(th(t),t))
})
  , O2 = (t, e, n, i) => {
    const r = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" || !i ? r : (k2(i) ? (r.headers = Object.assign({
        "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers),
    r.body = JSON.stringify(i)) : r.body = i,
    e != null && e.duplex && (r.duplex = e.duplex),
    Object.assign(Object.assign({}, r), n))
}
;
function El(t, e, n, i, r, s) {
    return Ms(this, void 0, void 0, function*() {
        return new Promise( (o, a) => {
            t(n, O2(e, i, r, s)).then(l => {
                if (!l.ok)
                    throw l;
                return i != null && i.noResolveJson ? l : l.json()
            }
            ).then(l => o(l)).catch(l => U2(l, a, i))
        }
        )
    })
}
function Cu(t, e, n, i) {
    return Ms(this, void 0, void 0, function*() {
        return El(t, "GET", e, n, i)
    })
}
function mi(t, e, n, i, r) {
    return Ms(this, void 0, void 0, function*() {
        return El(t, "POST", e, i, r, n)
    })
}
function rp(t, e, n, i, r) {
    return Ms(this, void 0, void 0, function*() {
        return El(t, "PUT", e, i, r, n)
    })
}
function F2(t, e, n, i) {
    return Ms(this, void 0, void 0, function*() {
        return El(t, "HEAD", e, Object.assign(Object.assign({}, n), {
            noResolveJson: !0
        }), i)
    })
}
function Ub(t, e, n, i, r) {
    return Ms(this, void 0, void 0, function*() {
        return El(t, "DELETE", e, i, r, n)
    })
}
var sn = function(t, e, n, i) {
    function r(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(i.next(u))
            } catch (d) {
                o(d)
            }
        }
        function l(u) {
            try {
                c(i.throw(u))
            } catch (d) {
                o(d)
            }
        }
        function c(u) {
            u.done ? s(u.value) : r(u.value).then(a, l)
        }
        c((i = i.apply(t, e || [])).next())
    }
    )
};
const B2 = {
    limit: 100,
    offset: 0,
    sortBy: {
        column: "name",
        order: "asc"
    }
}
  , E_ = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1
};
class z2 {
    constructor(e, n={}, i, r) {
        this.shouldThrowOnError = !1,
        this.url = e,
        this.headers = n,
        this.bucketId = i,
        this.fetch = kb(r)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    uploadOrUpdate(e, n, i, r) {
        return sn(this, void 0, void 0, function*() {
            try {
                let s;
                const o = Object.assign(Object.assign({}, E_), r);
                let a = Object.assign(Object.assign({}, this.headers), e === "POST" && {
                    "x-upsert": String(o.upsert)
                });
                const l = o.metadata;
                typeof Blob < "u" && i instanceof Blob ? (s = new FormData,
                s.append("cacheControl", o.cacheControl),
                l && s.append("metadata", this.encodeMetadata(l)),
                s.append("", i)) : typeof FormData < "u" && i instanceof FormData ? (s = i,
                s.append("cacheControl", o.cacheControl),
                l && s.append("metadata", this.encodeMetadata(l))) : (s = i,
                a["cache-control"] = `max-age=${o.cacheControl}`,
                a["content-type"] = o.contentType,
                l && (a["x-metadata"] = this.toBase64(this.encodeMetadata(l)))),
                r != null && r.headers && (a = Object.assign(Object.assign({}, a), r.headers));
                const c = this._removeEmptyFolders(n)
                  , u = this._getFinalPath(c)
                  , d = yield(e == "PUT" ? rp : mi)(this.fetch, `${this.url}/object/${u}`, s, Object.assign({
                    headers: a
                }, o != null && o.duplex ? {
                    duplex: o.duplex
                } : {}));
                return {
                    data: {
                        path: c,
                        id: d.Id,
                        fullPath: d.Key
                    },
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (Ut(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    upload(e, n, i) {
        return sn(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("POST", e, n, i)
        })
    }
    uploadToSignedUrl(e, n, i, r) {
        return sn(this, void 0, void 0, function*() {
            const s = this._removeEmptyFolders(e)
              , o = this._getFinalPath(s)
              , a = new URL(this.url + `/object/upload/sign/${o}`);
            a.searchParams.set("token", n);
            try {
                let l;
                const c = Object.assign({
                    upsert: E_.upsert
                }, r)
                  , u = Object.assign(Object.assign({}, this.headers), {
                    "x-upsert": String(c.upsert)
                });
                typeof Blob < "u" && i instanceof Blob ? (l = new FormData,
                l.append("cacheControl", c.cacheControl),
                l.append("", i)) : typeof FormData < "u" && i instanceof FormData ? (l = i,
                l.append("cacheControl", c.cacheControl)) : (l = i,
                u["cache-control"] = `max-age=${c.cacheControl}`,
                u["content-type"] = c.contentType);
                const d = yield rp(this.fetch, a.toString(), l, {
                    headers: u
                });
                return {
                    data: {
                        path: s,
                        fullPath: d.Key
                    },
                    error: null
                }
            } catch (l) {
                if (this.shouldThrowOnError)
                    throw l;
                if (Ut(l))
                    return {
                        data: null,
                        error: l
                    };
                throw l
            }
        })
    }
    createSignedUploadUrl(e, n) {
        return sn(this, void 0, void 0, function*() {
            try {
                let i = this._getFinalPath(e);
                const r = Object.assign({}, this.headers);
                n != null && n.upsert && (r["x-upsert"] = "true");
                const s = yield mi(this.fetch, `${this.url}/object/upload/sign/${i}`, {}, {
                    headers: r
                })
                  , o = new URL(this.url + s.url)
                  , a = o.searchParams.get("token");
                if (!a)
                    throw new Cg("No token returned by API");
                return {
                    data: {
                        signedUrl: o.toString(),
                        path: e,
                        token: a
                    },
                    error: null
                }
            } catch (i) {
                if (this.shouldThrowOnError)
                    throw i;
                if (Ut(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    update(e, n, i) {
        return sn(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("PUT", e, n, i)
        })
    }
    move(e, n, i) {
        return sn(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield mi(this.fetch, `${this.url}/object/move`, {
                        bucketId: this.bucketId,
                        sourceKey: e,
                        destinationKey: n,
                        destinationBucket: i == null ? void 0 : i.destinationBucket
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    copy(e, n, i) {
        return sn(this, void 0, void 0, function*() {
            try {
                return {
                    data: {
                        path: (yield mi(this.fetch, `${this.url}/object/copy`, {
                            bucketId: this.bucketId,
                            sourceKey: e,
                            destinationKey: n,
                            destinationBucket: i == null ? void 0 : i.destinationBucket
                        }, {
                            headers: this.headers
                        })).Key
                    },
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    createSignedUrl(e, n, i) {
        return sn(this, void 0, void 0, function*() {
            try {
                let r = this._getFinalPath(e)
                  , s = yield mi(this.fetch, `${this.url}/object/sign/${r}`, Object.assign({
                    expiresIn: n
                }, i != null && i.transform ? {
                    transform: i.transform
                } : {}), {
                    headers: this.headers
                });
                const o = i != null && i.download ? `&download=${i.download === !0 ? "" : i.download}` : "";
                return s = {
                    signedUrl: encodeURI(`${this.url}${s.signedURL}${o}`)
                },
                {
                    data: s,
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    createSignedUrls(e, n, i) {
        return sn(this, void 0, void 0, function*() {
            try {
                const r = yield mi(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {
                    expiresIn: n,
                    paths: e
                }, {
                    headers: this.headers
                })
                  , s = i != null && i.download ? `&download=${i.download === !0 ? "" : i.download}` : "";
                return {
                    data: r.map(o => Object.assign(Object.assign({}, o), {
                        signedUrl: o.signedURL ? encodeURI(`${this.url}${o.signedURL}${s}`) : null
                    })),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    download(e, n) {
        return sn(this, void 0, void 0, function*() {
            const r = typeof (n == null ? void 0 : n.transform) < "u" ? "render/image/authenticated" : "object"
              , s = this.transformOptsToQueryString((n == null ? void 0 : n.transform) || {})
              , o = s ? `?${s}` : "";
            try {
                const a = this._getFinalPath(e);
                return {
                    data: yield(yield Cu(this.fetch, `${this.url}/${r}/${a}${o}`, {
                        headers: this.headers,
                        noResolveJson: !0
                    })).blob(),
                    error: null
                }
            } catch (a) {
                if (this.shouldThrowOnError)
                    throw a;
                if (Ut(a))
                    return {
                        data: null,
                        error: a
                    };
                throw a
            }
        })
    }
    info(e) {
        return sn(this, void 0, void 0, function*() {
            const n = this._getFinalPath(e);
            try {
                const i = yield Cu(this.fetch, `${this.url}/object/info/${n}`, {
                    headers: this.headers
                });
                return {
                    data: ip(i),
                    error: null
                }
            } catch (i) {
                if (this.shouldThrowOnError)
                    throw i;
                if (Ut(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    exists(e) {
        return sn(this, void 0, void 0, function*() {
            const n = this._getFinalPath(e);
            try {
                return yield F2(this.fetch, `${this.url}/object/${n}`, {
                    headers: this.headers
                }),
                {
                    data: !0,
                    error: null
                }
            } catch (i) {
                if (this.shouldThrowOnError)
                    throw i;
                if (Ut(i) && i instanceof np) {
                    const r = i.originalError;
                    if ([400, 404].includes(r == null ? void 0 : r.status))
                        return {
                            data: !1,
                            error: i
                        }
                }
                throw i
            }
        })
    }
    getPublicUrl(e, n) {
        const i = this._getFinalPath(e)
          , r = []
          , s = n != null && n.download ? `download=${n.download === !0 ? "" : n.download}` : "";
        s !== "" && r.push(s);
        const a = typeof (n == null ? void 0 : n.transform) < "u" ? "render/image" : "object"
          , l = this.transformOptsToQueryString((n == null ? void 0 : n.transform) || {});
        l !== "" && r.push(l);
        let c = r.join("&");
        return c !== "" && (c = `?${c}`),
        {
            data: {
                publicUrl: encodeURI(`${this.url}/${a}/public/${i}${c}`)
            }
        }
    }
    remove(e) {
        return sn(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Ub(this.fetch, `${this.url}/object/${this.bucketId}`, {
                        prefixes: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (Ut(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    list(e, n, i) {
        return sn(this, void 0, void 0, function*() {
            try {
                const r = Object.assign(Object.assign(Object.assign({}, B2), n), {
                    prefix: e || ""
                });
                return {
                    data: yield mi(this.fetch, `${this.url}/object/list/${this.bucketId}`, r, {
                        headers: this.headers
                    }, i),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Ut(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listV2(e, n) {
        return sn(this, void 0, void 0, function*() {
            try {
                const i = Object.assign({}, e);
                return {
                    data: yield mi(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, i, {
                        headers: this.headers
                    }, n),
                    error: null
                }
            } catch (i) {
                if (this.shouldThrowOnError)
                    throw i;
                if (Ut(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    encodeMetadata(e) {
        return JSON.stringify(e)
    }
    toBase64(e) {
        return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e)
    }
    _getFinalPath(e) {
        return `${this.bucketId}/${e.replace(/^\/+/, "")}`
    }
    _removeEmptyFolders(e) {
        return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/")
    }
    transformOptsToQueryString(e) {
        const n = [];
        return e.width && n.push(`width=${e.width}`),
        e.height && n.push(`height=${e.height}`),
        e.resize && n.push(`resize=${e.resize}`),
        e.format && n.push(`format=${e.format}`),
        e.quality && n.push(`quality=${e.quality}`),
        n.join("&")
    }
}
const V2 = "2.12.1"
  , j2 = {
    "X-Client-Info": `storage-js/${V2}`
};
var Ps = function(t, e, n, i) {
    function r(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(i.next(u))
            } catch (d) {
                o(d)
            }
        }
        function l(u) {
            try {
                c(i.throw(u))
            } catch (d) {
                o(d)
            }
        }
        function c(u) {
            u.done ? s(u.value) : r(u.value).then(a, l)
        }
        c((i = i.apply(t, e || [])).next())
    }
    )
};
class H2 {
    constructor(e, n={}, i, r) {
        this.shouldThrowOnError = !1;
        const s = new URL(e);
        r != null && r.useNewHostname && /supabase\.(co|in|red)$/.test(s.hostname) && !s.hostname.includes("storage.supabase.") && (s.hostname = s.hostname.replace("supabase.", "storage.supabase.")),
        this.url = s.href,
        this.headers = Object.assign(Object.assign({}, j2), n),
        this.fetch = kb(i)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    listBuckets() {
        return Ps(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Cu(this.fetch, `${this.url}/bucket`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (e) {
                if (this.shouldThrowOnError)
                    throw e;
                if (Ut(e))
                    return {
                        data: null,
                        error: e
                    };
                throw e
            }
        })
    }
    getBucket(e) {
        return Ps(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Cu(this.fetch, `${this.url}/bucket/${e}`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (Ut(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    createBucket(e, n={
        public: !1
    }) {
        return Ps(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield mi(this.fetch, `${this.url}/bucket`, {
                        id: e,
                        name: e,
                        type: n.type,
                        public: n.public,
                        file_size_limit: n.fileSizeLimit,
                        allowed_mime_types: n.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (i) {
                if (this.shouldThrowOnError)
                    throw i;
                if (Ut(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    updateBucket(e, n) {
        return Ps(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield rp(this.fetch, `${this.url}/bucket/${e}`, {
                        id: e,
                        name: e,
                        public: n.public,
                        file_size_limit: n.fileSizeLimit,
                        allowed_mime_types: n.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (i) {
                if (this.shouldThrowOnError)
                    throw i;
                if (Ut(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    emptyBucket(e) {
        return Ps(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield mi(this.fetch, `${this.url}/bucket/${e}/empty`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (Ut(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    deleteBucket(e) {
        return Ps(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Ub(this.fetch, `${this.url}/bucket/${e}`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (Ut(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
}
class G2 extends H2 {
    constructor(e, n={}, i, r) {
        super(e, n, i, r)
    }
    from(e) {
        return new z2(this.url,this.headers,e,this.fetch)
    }
}
const W2 = "2.57.4";
let _a = "";
typeof Deno < "u" ? _a = "deno" : typeof document < "u" ? _a = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? _a = "react-native" : _a = "node";
const $2 = {
    "X-Client-Info": `supabase-js-${_a}/${W2}`
}
  , X2 = {
    headers: $2
}
  , q2 = {
    schema: "public"
}
  , K2 = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit"
}
  , Y2 = {};
var Z2 = function(t, e, n, i) {
    function r(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(i.next(u))
            } catch (d) {
                o(d)
            }
        }
        function l(u) {
            try {
                c(i.throw(u))
            } catch (d) {
                o(d)
            }
        }
        function c(u) {
            u.done ? s(u.value) : r(u.value).then(a, l)
        }
        c((i = i.apply(t, e || [])).next())
    }
    )
};
const J2 = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = Sb : e = fetch,
    (...n) => e(...n)
}
  , Q2 = () => typeof Headers > "u" ? wb : Headers
  , eN = (t, e, n) => {
    const i = J2(n)
      , r = Q2();
    return (s, o) => Z2(void 0, void 0, void 0, function*() {
        var a;
        const l = (a = yield e()) !== null && a !== void 0 ? a : t;
        let c = new r(o == null ? void 0 : o.headers);
        return c.has("apikey") || c.set("apikey", t),
        c.has("Authorization") || c.set("Authorization", `Bearer ${l}`),
        i(s, Object.assign(Object.assign({}, o), {
            headers: c
        }))
    })
}
;
var tN = function(t, e, n, i) {
    function r(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(i.next(u))
            } catch (d) {
                o(d)
            }
        }
        function l(u) {
            try {
                c(i.throw(u))
            } catch (d) {
                o(d)
            }
        }
        function c(u) {
            u.done ? s(u.value) : r(u.value).then(a, l)
        }
        c((i = i.apply(t, e || [])).next())
    }
    )
};
function nN(t) {
    return t.endsWith("/") ? t : t + "/"
}
function iN(t, e) {
    var n, i;
    const {db: r, auth: s, realtime: o, global: a} = t
      , {db: l, auth: c, realtime: u, global: d} = e
      , h = {
        db: Object.assign(Object.assign({}, l), r),
        auth: Object.assign(Object.assign({}, c), s),
        realtime: Object.assign(Object.assign({}, u), o),
        storage: {},
        global: Object.assign(Object.assign(Object.assign({}, d), a), {
            headers: Object.assign(Object.assign({}, (n = d == null ? void 0 : d.headers) !== null && n !== void 0 ? n : {}), (i = a == null ? void 0 : a.headers) !== null && i !== void 0 ? i : {})
        }),
        accessToken: () => tN(this, void 0, void 0, function*() {
            return ""
        })
    };
    return t.accessToken ? h.accessToken = t.accessToken : delete h.accessToken,
    h
}
function rN(t) {
    const e = t == null ? void 0 : t.trim();
    if (!e)
        throw new Error("supabaseUrl is required.");
    if (!e.match(/^https?:\/\//i))
        throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
    try {
        return new URL(nN(e))
    } catch {
        throw Error("Invalid supabaseUrl: Provided URL is malformed.")
    }
}
const Ob = "2.71.1"
  , Ks = 30 * 1e3
  , sp = 3
  , nh = sp * Ks
  , sN = "http://localhost:9999"
  , oN = "supabase.auth.token"
  , aN = {
    "X-Client-Info": `gotrue-js/${Ob}`
}
  , op = "X-Supabase-Api-Version"
  , Fb = {
    "2024-01-01": {
        timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
        name: "2024-01-01"
    }
}
  , lN = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i
  , cN = 10 * 60 * 1e3;
class Rg extends Error {
    constructor(e, n, i) {
        super(e),
        this.__isAuthError = !0,
        this.name = "AuthError",
        this.status = n,
        this.code = i
    }
}
function Fe(t) {
    return typeof t == "object" && t !== null && "__isAuthError"in t
}
class uN extends Rg {
    constructor(e, n, i) {
        super(e, n, i),
        this.name = "AuthApiError",
        this.status = n,
        this.code = i
    }
}
function dN(t) {
    return Fe(t) && t.name === "AuthApiError"
}
class Bb extends Rg {
    constructor(e, n) {
        super(e),
        this.name = "AuthUnknownError",
        this.originalError = n
    }
}
class Br extends Rg {
    constructor(e, n, i, r) {
        super(e, i, r),
        this.name = n,
        this.status = i
    }
}
class ur extends Br {
    constructor() {
        super("Auth session missing!", "AuthSessionMissingError", 400, void 0)
    }
}
function hN(t) {
    return Fe(t) && t.name === "AuthSessionMissingError"
}
class nc extends Br {
    constructor() {
        super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0)
    }
}
class ic extends Br {
    constructor(e) {
        super(e, "AuthInvalidCredentialsError", 400, void 0)
    }
}
class rc extends Br {
    constructor(e, n=null) {
        super(e, "AuthImplicitGrantRedirectError", 500, void 0),
        this.details = null,
        this.details = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
function fN(t) {
    return Fe(t) && t.name === "AuthImplicitGrantRedirectError"
}
class T_ extends Br {
    constructor(e, n=null) {
        super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0),
        this.details = null,
        this.details = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
class ap extends Br {
    constructor(e, n) {
        super(e, "AuthRetryableFetchError", n, void 0)
    }
}
function ih(t) {
    return Fe(t) && t.name === "AuthRetryableFetchError"
}
class M_ extends Br {
    constructor(e, n, i) {
        super(e, "AuthWeakPasswordError", n, "weak_password"),
        this.reasons = i
    }
}
class lp extends Br {
    constructor(e) {
        super(e, "AuthInvalidJwtError", 400, "invalid_jwt")
    }
}
const Ru = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("")
  , A_ = ` 	
\r=`.split("")
  , pN = ( () => {
    const t = new Array(128);
    for (let e = 0; e < t.length; e += 1)
        t[e] = -1;
    for (let e = 0; e < A_.length; e += 1)
        t[A_[e].charCodeAt(0)] = -2;
    for (let e = 0; e < Ru.length; e += 1)
        t[Ru[e].charCodeAt(0)] = e;
    return t
}
)();
function C_(t, e, n) {
    if (t !== null)
        for (e.queue = e.queue << 8 | t,
        e.queuedBits += 8; e.queuedBits >= 6; ) {
            const i = e.queue >> e.queuedBits - 6 & 63;
            n(Ru[i]),
            e.queuedBits -= 6
        }
    else if (e.queuedBits > 0)
        for (e.queue = e.queue << 6 - e.queuedBits,
        e.queuedBits = 6; e.queuedBits >= 6; ) {
            const i = e.queue >> e.queuedBits - 6 & 63;
            n(Ru[i]),
            e.queuedBits -= 6
        }
}
function zb(t, e, n) {
    const i = pN[t];
    if (i > -1)
        for (e.queue = e.queue << 6 | i,
        e.queuedBits += 6; e.queuedBits >= 8; )
            n(e.queue >> e.queuedBits - 8 & 255),
            e.queuedBits -= 8;
    else {
        if (i === -2)
            return;
        throw new Error(`Invalid Base64-URL character "${String.fromCharCode(t)}"`)
    }
}
function R_(t) {
    const e = []
      , n = o => {
        e.push(String.fromCodePoint(o))
    }
      , i = {
        utf8seq: 0,
        codepoint: 0
    }
      , r = {
        queue: 0,
        queuedBits: 0
    }
      , s = o => {
        vN(o, i, n)
    }
    ;
    for (let o = 0; o < t.length; o += 1)
        zb(t.charCodeAt(o), r, s);
    return e.join("")
}
function mN(t, e) {
    if (t <= 127) {
        e(t);
        return
    } else if (t <= 2047) {
        e(192 | t >> 6),
        e(128 | t & 63);
        return
    } else if (t <= 65535) {
        e(224 | t >> 12),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    } else if (t <= 1114111) {
        e(240 | t >> 18),
        e(128 | t >> 12 & 63),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    }
    throw new Error(`Unrecognized Unicode codepoint: ${t.toString(16)}`)
}
function gN(t, e) {
    for (let n = 0; n < t.length; n += 1) {
        let i = t.charCodeAt(n);
        if (i > 55295 && i <= 56319) {
            const r = (i - 55296) * 1024 & 65535;
            i = (t.charCodeAt(n + 1) - 56320 & 65535 | r) + 65536,
            n += 1
        }
        mN(i, e)
    }
}
function vN(t, e, n) {
    if (e.utf8seq === 0) {
        if (t <= 127) {
            n(t);
            return
        }
        for (let i = 1; i < 6; i += 1)
            if (!(t >> 7 - i & 1)) {
                e.utf8seq = i;
                break
            }
        if (e.utf8seq === 2)
            e.codepoint = t & 31;
        else if (e.utf8seq === 3)
            e.codepoint = t & 15;
        else if (e.utf8seq === 4)
            e.codepoint = t & 7;
        else
            throw new Error("Invalid UTF-8 sequence");
        e.utf8seq -= 1
    } else if (e.utf8seq > 0) {
        if (t <= 127)
            throw new Error("Invalid UTF-8 sequence");
        e.codepoint = e.codepoint << 6 | t & 63,
        e.utf8seq -= 1,
        e.utf8seq === 0 && n(e.codepoint)
    }
}
function _N(t) {
    const e = []
      , n = {
        queue: 0,
        queuedBits: 0
    }
      , i = r => {
        e.push(r)
    }
    ;
    for (let r = 0; r < t.length; r += 1)
        zb(t.charCodeAt(r), n, i);
    return new Uint8Array(e)
}
function yN(t) {
    const e = [];
    return gN(t, n => e.push(n)),
    new Uint8Array(e)
}
function xN(t) {
    const e = []
      , n = {
        queue: 0,
        queuedBits: 0
    }
      , i = r => {
        e.push(r)
    }
    ;
    return t.forEach(r => C_(r, n, i)),
    C_(null, n, i),
    e.join("")
}
function SN(t) {
    return Math.round(Date.now() / 1e3) + t
}
function wN() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
        const e = Math.random() * 16 | 0;
        return (t == "x" ? e : e & 3 | 8).toString(16)
    })
}
const ei = () => typeof window < "u" && typeof document < "u"
  , Hr = {
    tested: !1,
    writable: !1
}
  , Vb = () => {
    if (!ei())
        return !1;
    try {
        if (typeof globalThis.localStorage != "object")
            return !1
    } catch {
        return !1
    }
    if (Hr.tested)
        return Hr.writable;
    const t = `lswt-${Math.random()}${Math.random()}`;
    try {
        globalThis.localStorage.setItem(t, t),
        globalThis.localStorage.removeItem(t),
        Hr.tested = !0,
        Hr.writable = !0
    } catch {
        Hr.tested = !0,
        Hr.writable = !1
    }
    return Hr.writable
}
;
function bN(t) {
    const e = {}
      , n = new URL(t);
    if (n.hash && n.hash[0] === "#")
        try {
            new URLSearchParams(n.hash.substring(1)).forEach( (r, s) => {
                e[s] = r
            }
            )
        } catch {}
    return n.searchParams.forEach( (i, r) => {
        e[r] = i
    }
    ),
    e
}
const jb = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = (...n) => wl(async () => {
        const {default: i} = await Promise.resolve().then( () => $o);
        return {
            default: i
        }
    }
    , void 0).then( ({default: i}) => i(...n)) : e = fetch,
    (...n) => e(...n)
}
  , EN = t => typeof t == "object" && t !== null && "status"in t && "ok"in t && "json"in t && typeof t.json == "function"
  , Ys = async (t, e, n) => {
    await t.setItem(e, JSON.stringify(n))
}
  , Gr = async (t, e) => {
    const n = await t.getItem(e);
    if (!n)
        return null;
    try {
        return JSON.parse(n)
    } catch {
        return n
    }
}
  , nr = async (t, e) => {
    await t.removeItem(e)
}
;
class nd {
    constructor() {
        this.promise = new nd.promiseConstructor( (e, n) => {
            this.resolve = e,
            this.reject = n
        }
        )
    }
}
nd.promiseConstructor = Promise;
function rh(t) {
    const e = t.split(".");
    if (e.length !== 3)
        throw new lp("Invalid JWT structure");
    for (let i = 0; i < e.length; i++)
        if (!lN.test(e[i]))
            throw new lp("JWT not in base64url format");
    return {
        header: JSON.parse(R_(e[0])),
        payload: JSON.parse(R_(e[1])),
        signature: _N(e[2]),
        raw: {
            header: e[0],
            payload: e[1]
        }
    }
}
async function TN(t) {
    return await new Promise(e => {
        setTimeout( () => e(null), t)
    }
    )
}
function MN(t, e) {
    return new Promise( (i, r) => {
        (async () => {
            for (let s = 0; s < 1 / 0; s++)
                try {
                    const o = await t(s);
                    if (!e(s, null, o)) {
                        i(o);
                        return
                    }
                } catch (o) {
                    if (!e(s, o)) {
                        r(o);
                        return
                    }
                }
        }
        )()
    }
    )
}
function AN(t) {
    return ("0" + t.toString(16)).substr(-2)
}
function CN() {
    const e = new Uint32Array(56);
    if (typeof crypto > "u") {
        const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
          , i = n.length;
        let r = "";
        for (let s = 0; s < 56; s++)
            r += n.charAt(Math.floor(Math.random() * i));
        return r
    }
    return crypto.getRandomValues(e),
    Array.from(e, AN).join("")
}
async function RN(t) {
    const n = new TextEncoder().encode(t)
      , i = await crypto.subtle.digest("SHA-256", n)
      , r = new Uint8Array(i);
    return Array.from(r).map(s => String.fromCharCode(s)).join("")
}
async function PN(t) {
    if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u"))
        return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),
        t;
    const n = await RN(t);
    return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
}
async function Ns(t, e, n=!1) {
    const i = CN();
    let r = i;
    n && (r += "/PASSWORD_RECOVERY"),
    await Ys(t, `${e}-code-verifier`, r);
    const s = await PN(i);
    return [s, i === s ? "plain" : "s256"]
}
const NN = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function DN(t) {
    const e = t.headers.get(op);
    if (!e || !e.match(NN))
        return null;
    try {
        return new Date(`${e}T00:00:00.0Z`)
    } catch {
        return null
    }
}
function LN(t) {
    if (!t)
        throw new Error("Missing exp claim");
    const e = Math.floor(Date.now() / 1e3);
    if (t <= e)
        throw new Error("JWT has expired")
}
function IN(t) {
    switch (t) {
    case "RS256":
        return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        };
    case "ES256":
        return {
            name: "ECDSA",
            namedCurve: "P-256",
            hash: {
                name: "SHA-256"
            }
        };
    default:
        throw new Error("Invalid alg claim")
    }
}
const kN = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function Ds(t) {
    if (!kN.test(t))
        throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")
}
function sh() {
    const t = {};
    return new Proxy(t,{
        get: (e, n) => {
            if (n === "__isUserNotAvailableProxy")
                return !0;
            if (typeof n == "symbol") {
                const i = n.toString();
                if (i === "Symbol(Symbol.toPrimitive)" || i === "Symbol(Symbol.toStringTag)" || i === "Symbol(util.inspect.custom)")
                    return
            }
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${n}" property of the session object is not supported. Please use getUser() instead.`)
        }
        ,
        set: (e, n) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${n}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
        ,
        deleteProperty: (e, n) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${n}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
    })
}
function P_(t) {
    return JSON.parse(JSON.stringify(t))
}
var UN = function(t, e) {
    var n = {};
    for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)
            e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]);
    return n
};
const es = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , ON = [502, 503, 504];
async function N_(t) {
    var e;
    if (!EN(t))
        throw new ap(es(t),0);
    if (ON.includes(t.status))
        throw new ap(es(t),t.status);
    let n;
    try {
        n = await t.json()
    } catch (s) {
        throw new Bb(es(s),s)
    }
    let i;
    const r = DN(t);
    if (r && r.getTime() >= Fb["2024-01-01"].timestamp && typeof n == "object" && n && typeof n.code == "string" ? i = n.code : typeof n == "object" && n && typeof n.error_code == "string" && (i = n.error_code),
    i) {
        if (i === "weak_password")
            throw new M_(es(n),t.status,((e = n.weak_password) === null || e === void 0 ? void 0 : e.reasons) || []);
        if (i === "session_not_found")
            throw new ur
    } else if (typeof n == "object" && n && typeof n.weak_password == "object" && n.weak_password && Array.isArray(n.weak_password.reasons) && n.weak_password.reasons.length && n.weak_password.reasons.reduce( (s, o) => s && typeof o == "string", !0))
        throw new M_(es(n),t.status,n.weak_password.reasons);
    throw new uN(es(n),t.status || 500,i)
}
const FN = (t, e, n, i) => {
    const r = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" ? r : (r.headers = Object.assign({
        "Content-Type": "application/json;charset=UTF-8"
    }, e == null ? void 0 : e.headers),
    r.body = JSON.stringify(i),
    Object.assign(Object.assign({}, r), n))
}
;
async function He(t, e, n, i) {
    var r;
    const s = Object.assign({}, i == null ? void 0 : i.headers);
    s[op] || (s[op] = Fb["2024-01-01"].name),
    i != null && i.jwt && (s.Authorization = `Bearer ${i.jwt}`);
    const o = (r = i == null ? void 0 : i.query) !== null && r !== void 0 ? r : {};
    i != null && i.redirectTo && (o.redirect_to = i.redirectTo);
    const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : ""
      , l = await BN(t, e, n + a, {
        headers: s,
        noResolveJson: i == null ? void 0 : i.noResolveJson
    }, {}, i == null ? void 0 : i.body);
    return i != null && i.xform ? i == null ? void 0 : i.xform(l) : {
        data: Object.assign({}, l),
        error: null
    }
}
async function BN(t, e, n, i, r, s) {
    const o = FN(e, i, r, s);
    let a;
    try {
        a = await t(n, Object.assign({}, o))
    } catch (l) {
        throw console.error(l),
        new ap(es(l),0)
    }
    if (a.ok || await N_(a),
    i != null && i.noResolveJson)
        return a;
    try {
        return await a.json()
    } catch (l) {
        await N_(l)
    }
}
function Ni(t) {
    var e;
    let n = null;
    HN(t) && (n = Object.assign({}, t),
    t.expires_at || (n.expires_at = SN(t.expires_in)));
    const i = (e = t.user) !== null && e !== void 0 ? e : t;
    return {
        data: {
            session: n,
            user: i
        },
        error: null
    }
}
function D_(t) {
    const e = Ni(t);
    return !e.error && t.weak_password && typeof t.weak_password == "object" && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.message && typeof t.weak_password.message == "string" && t.weak_password.reasons.reduce( (n, i) => n && typeof i == "string", !0) && (e.data.weak_password = t.weak_password),
    e
}
function mr(t) {
    var e;
    return {
        data: {
            user: (e = t.user) !== null && e !== void 0 ? e : t
        },
        error: null
    }
}
function zN(t) {
    return {
        data: t,
        error: null
    }
}
function VN(t) {
    const {action_link: e, email_otp: n, hashed_token: i, redirect_to: r, verification_type: s} = t
      , o = UN(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"])
      , a = {
        action_link: e,
        email_otp: n,
        hashed_token: i,
        redirect_to: r,
        verification_type: s
    }
      , l = Object.assign({}, o);
    return {
        data: {
            properties: a,
            user: l
        },
        error: null
    }
}
function jN(t) {
    return t
}
function HN(t) {
    return t.access_token && t.refresh_token && t.expires_in
}
const oh = ["global", "local", "others"];
var GN = function(t, e) {
    var n = {};
    for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)
            e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]);
    return n
};
class WN {
    constructor({url: e="", headers: n={}, fetch: i}) {
        this.url = e,
        this.headers = n,
        this.fetch = jb(i),
        this.mfa = {
            listFactors: this._listFactors.bind(this),
            deleteFactor: this._deleteFactor.bind(this)
        }
    }
    async signOut(e, n=oh[0]) {
        if (oh.indexOf(n) < 0)
            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${oh.join(", ")}`);
        try {
            return await He(this.fetch, "POST", `${this.url}/logout?scope=${n}`, {
                headers: this.headers,
                jwt: e,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (i) {
            if (Fe(i))
                return {
                    data: null,
                    error: i
                };
            throw i
        }
    }
    async inviteUserByEmail(e, n={}) {
        try {
            return await He(this.fetch, "POST", `${this.url}/invite`, {
                body: {
                    email: e,
                    data: n.data
                },
                headers: this.headers,
                redirectTo: n.redirectTo,
                xform: mr
            })
        } catch (i) {
            if (Fe(i))
                return {
                    data: {
                        user: null
                    },
                    error: i
                };
            throw i
        }
    }
    async generateLink(e) {
        try {
            const {options: n} = e
              , i = GN(e, ["options"])
              , r = Object.assign(Object.assign({}, i), n);
            return "newEmail"in i && (r.new_email = i == null ? void 0 : i.newEmail,
            delete r.newEmail),
            await He(this.fetch, "POST", `${this.url}/admin/generate_link`, {
                body: r,
                headers: this.headers,
                xform: VN,
                redirectTo: n == null ? void 0 : n.redirectTo
            })
        } catch (n) {
            if (Fe(n))
                return {
                    data: {
                        properties: null,
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async createUser(e) {
        try {
            return await He(this.fetch, "POST", `${this.url}/admin/users`, {
                body: e,
                headers: this.headers,
                xform: mr
            })
        } catch (n) {
            if (Fe(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async listUsers(e) {
        var n, i, r, s, o, a, l;
        try {
            const c = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , u = await He(this.fetch, "GET", `${this.url}/admin/users`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (i = (n = e == null ? void 0 : e.page) === null || n === void 0 ? void 0 : n.toString()) !== null && i !== void 0 ? i : "",
                    per_page: (s = (r = e == null ? void 0 : e.perPage) === null || r === void 0 ? void 0 : r.toString()) !== null && s !== void 0 ? s : ""
                },
                xform: jN
            });
            if (u.error)
                throw u.error;
            const d = await u.json()
              , h = (o = u.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , p = (l = (a = u.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return p.length > 0 && (p.forEach(v => {
                const x = parseInt(v.split(";")[0].split("=")[1].substring(0, 1))
                  , g = JSON.parse(v.split(";")[1].split("=")[1]);
                c[`${g}Page`] = x
            }
            ),
            c.total = parseInt(h)),
            {
                data: Object.assign(Object.assign({}, d), c),
                error: null
            }
        } catch (c) {
            if (Fe(c))
                return {
                    data: {
                        users: []
                    },
                    error: c
                };
            throw c
        }
    }
    async getUserById(e) {
        Ds(e);
        try {
            return await He(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                xform: mr
            })
        } catch (n) {
            if (Fe(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async updateUserById(e, n) {
        Ds(e);
        try {
            return await He(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
                body: n,
                headers: this.headers,
                xform: mr
            })
        } catch (i) {
            if (Fe(i))
                return {
                    data: {
                        user: null
                    },
                    error: i
                };
            throw i
        }
    }
    async deleteUser(e, n=!1) {
        Ds(e);
        try {
            return await He(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                body: {
                    should_soft_delete: n
                },
                xform: mr
            })
        } catch (i) {
            if (Fe(i))
                return {
                    data: {
                        user: null
                    },
                    error: i
                };
            throw i
        }
    }
    async _listFactors(e) {
        Ds(e.userId);
        try {
            const {data: n, error: i} = await He(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, {
                headers: this.headers,
                xform: r => ({
                    data: {
                        factors: r
                    },
                    error: null
                })
            });
            return {
                data: n,
                error: i
            }
        } catch (n) {
            if (Fe(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _deleteFactor(e) {
        Ds(e.userId),
        Ds(e.id);
        try {
            return {
                data: await He(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, {
                    headers: this.headers
                }),
                error: null
            }
        } catch (n) {
            if (Fe(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
}
function L_(t={}) {
    return {
        getItem: e => t[e] || null,
        setItem: (e, n) => {
            t[e] = n
        }
        ,
        removeItem: e => {
            delete t[e]
        }
    }
}
function $N() {
    if (typeof globalThis != "object")
        try {
            Object.defineProperty(Object.prototype, "__magic__", {
                get: function() {
                    return this
                },
                configurable: !0
            }),
            __magic__.globalThis = __magic__,
            delete Object.prototype.__magic__
        } catch {
            typeof self < "u" && (self.globalThis = self)
        }
}
const Ls = {
    debug: !!(globalThis && Vb() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class Hb extends Error {
    constructor(e) {
        super(e),
        this.isAcquireTimeout = !0
    }
}
class XN extends Hb {
}
async function qN(t, e, n) {
    Ls.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, e);
    const i = new globalThis.AbortController;
    return e > 0 && setTimeout( () => {
        i.abort(),
        Ls.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", t)
    }
    , e),
    await Promise.resolve().then( () => globalThis.navigator.locks.request(t, e === 0 ? {
        mode: "exclusive",
        ifAvailable: !0
    } : {
        mode: "exclusive",
        signal: i.signal
    }, async r => {
        if (r) {
            Ls.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", t, r.name);
            try {
                return await n()
            } finally {
                Ls.debug && console.log("@supabase/gotrue-js: navigatorLock: released", t, r.name)
            }
        } else {
            if (e === 0)
                throw Ls.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", t),
                new XN(`Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`);
            if (Ls.debug)
                try {
                    const s = await globalThis.navigator.locks.query();
                    console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(s, null, "  "))
                } catch (s) {
                    console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", s)
                }
            return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),
            await n()
        }
    }
    ))
}
$N();
const KN = {
    url: sN,
    storageKey: oN,
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    headers: aN,
    flowType: "implicit",
    debug: !1,
    hasCustomAuthorizationHeader: !1
};
async function I_(t, e, n) {
    return await n()
}
const Is = {};
class ol {
    constructor(e) {
        var n, i;
        this.userStorage = null,
        this.memoryStorage = null,
        this.stateChangeEmitters = new Map,
        this.autoRefreshTicker = null,
        this.visibilityChangedCallback = null,
        this.refreshingDeferred = null,
        this.initializePromise = null,
        this.detectSessionInUrl = !0,
        this.hasCustomAuthorizationHeader = !1,
        this.suppressGetSessionWarning = !1,
        this.lockAcquired = !1,
        this.pendingInLock = [],
        this.broadcastChannel = null,
        this.logger = console.log,
        this.instanceID = ol.nextInstanceID,
        ol.nextInstanceID += 1,
        this.instanceID > 0 && ei() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
        const r = Object.assign(Object.assign({}, KN), e);
        if (this.logDebugMessages = !!r.debug,
        typeof r.debug == "function" && (this.logger = r.debug),
        this.persistSession = r.persistSession,
        this.storageKey = r.storageKey,
        this.autoRefreshToken = r.autoRefreshToken,
        this.admin = new WN({
            url: r.url,
            headers: r.headers,
            fetch: r.fetch
        }),
        this.url = r.url,
        this.headers = r.headers,
        this.fetch = jb(r.fetch),
        this.lock = r.lock || I_,
        this.detectSessionInUrl = r.detectSessionInUrl,
        this.flowType = r.flowType,
        this.hasCustomAuthorizationHeader = r.hasCustomAuthorizationHeader,
        r.lock ? this.lock = r.lock : ei() && (!((n = globalThis == null ? void 0 : globalThis.navigator) === null || n === void 0) && n.locks) ? this.lock = qN : this.lock = I_,
        this.jwks || (this.jwks = {
            keys: []
        },
        this.jwks_cached_at = Number.MIN_SAFE_INTEGER),
        this.mfa = {
            verify: this._verify.bind(this),
            enroll: this._enroll.bind(this),
            unenroll: this._unenroll.bind(this),
            challenge: this._challenge.bind(this),
            listFactors: this._listFactors.bind(this),
            challengeAndVerify: this._challengeAndVerify.bind(this),
            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
        },
        this.persistSession ? (r.storage ? this.storage = r.storage : Vb() ? this.storage = globalThis.localStorage : (this.memoryStorage = {},
        this.storage = L_(this.memoryStorage)),
        r.userStorage && (this.userStorage = r.userStorage)) : (this.memoryStorage = {},
        this.storage = L_(this.memoryStorage)),
        ei() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
            try {
                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)
            } catch (s) {
                console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", s)
            }
            (i = this.broadcastChannel) === null || i === void 0 || i.addEventListener("message", async s => {
                this._debug("received broadcast notification from other tab or client", s),
                await this._notifyAllSubscribers(s.data.event, s.data.session, !1)
            }
            )
        }
        this.initialize()
    }
    get jwks() {
        var e, n;
        return (n = (e = Is[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !== null && n !== void 0 ? n : {
            keys: []
        }
    }
    set jwks(e) {
        Is[this.storageKey] = Object.assign(Object.assign({}, Is[this.storageKey]), {
            jwks: e
        })
    }
    get jwks_cached_at() {
        var e, n;
        return (n = (e = Is[this.storageKey]) === null || e === void 0 ? void 0 : e.cachedAt) !== null && n !== void 0 ? n : Number.MIN_SAFE_INTEGER
    }
    set jwks_cached_at(e) {
        Is[this.storageKey] = Object.assign(Object.assign({}, Is[this.storageKey]), {
            cachedAt: e
        })
    }
    _debug(...e) {
        return this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${Ob}) ${new Date().toISOString()}`, ...e),
        this
    }
    async initialize() {
        return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(),
        await this.initializePromise)
    }
    async _initialize() {
        var e;
        try {
            const n = bN(window.location.href);
            let i = "none";
            if (this._isImplicitGrantCallback(n) ? i = "implicit" : await this._isPKCECallback(n) && (i = "pkce"),
            ei() && this.detectSessionInUrl && i !== "none") {
                const {data: r, error: s} = await this._getSessionFromURL(n, i);
                if (s) {
                    if (this._debug("#_initialize()", "error detecting session from URL", s),
                    fN(s)) {
                        const l = (e = s.details) === null || e === void 0 ? void 0 : e.code;
                        if (l === "identity_already_exists" || l === "identity_not_found" || l === "single_identity_not_deletable")
                            return {
                                error: s
                            }
                    }
                    return await this._removeSession(),
                    {
                        error: s
                    }
                }
                const {session: o, redirectType: a} = r;
                return this._debug("#_initialize()", "detected session in URL", o, "redirect type", a),
                await this._saveSession(o),
                setTimeout(async () => {
                    a === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", o) : await this._notifyAllSubscribers("SIGNED_IN", o)
                }
                , 0),
                {
                    error: null
                }
            }
            return await this._recoverAndRefresh(),
            {
                error: null
            }
        } catch (n) {
            return Fe(n) ? {
                error: n
            } : {
                error: new Bb("Unexpected error during initialization",n)
            }
        } finally {
            await this._handleVisibilityChange(),
            this._debug("#_initialize()", "end")
        }
    }
    async signInAnonymously(e) {
        var n, i, r;
        try {
            const s = await He(this.fetch, "POST", `${this.url}/signup`, {
                headers: this.headers,
                body: {
                    data: (i = (n = e == null ? void 0 : e.options) === null || n === void 0 ? void 0 : n.data) !== null && i !== void 0 ? i : {},
                    gotrue_meta_security: {
                        captcha_token: (r = e == null ? void 0 : e.options) === null || r === void 0 ? void 0 : r.captchaToken
                    }
                },
                xform: Ni
            })
              , {data: o, error: a} = s;
            if (a || !o)
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                };
            const l = o.session
              , c = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            {
                data: {
                    user: c,
                    session: l
                },
                error: null
            }
        } catch (s) {
            if (Fe(s))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                };
            throw s
        }
    }
    async signUp(e) {
        var n, i, r;
        try {
            let s;
            if ("email"in e) {
                const {email: u, password: d, options: h} = e;
                let p = null
                  , v = null;
                this.flowType === "pkce" && ([p,v] = await Ns(this.storage, this.storageKey)),
                s = await He(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    redirectTo: h == null ? void 0 : h.emailRedirectTo,
                    body: {
                        email: u,
                        password: d,
                        data: (n = h == null ? void 0 : h.data) !== null && n !== void 0 ? n : {},
                        gotrue_meta_security: {
                            captcha_token: h == null ? void 0 : h.captchaToken
                        },
                        code_challenge: p,
                        code_challenge_method: v
                    },
                    xform: Ni
                })
            } else if ("phone"in e) {
                const {phone: u, password: d, options: h} = e;
                s = await He(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    body: {
                        phone: u,
                        password: d,
                        data: (i = h == null ? void 0 : h.data) !== null && i !== void 0 ? i : {},
                        channel: (r = h == null ? void 0 : h.channel) !== null && r !== void 0 ? r : "sms",
                        gotrue_meta_security: {
                            captcha_token: h == null ? void 0 : h.captchaToken
                        }
                    },
                    xform: Ni
                })
            } else
                throw new ic("You must provide either an email or phone number and a password");
            const {data: o, error: a} = s;
            if (a || !o)
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                };
            const l = o.session
              , c = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            {
                data: {
                    user: c,
                    session: l
                },
                error: null
            }
        } catch (s) {
            if (Fe(s))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                };
            throw s
        }
    }
    async signInWithPassword(e) {
        try {
            let n;
            if ("email"in e) {
                const {email: s, password: o, options: a} = e;
                n = await He(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        email: s,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: D_
                })
            } else if ("phone"in e) {
                const {phone: s, password: o, options: a} = e;
                n = await He(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        phone: s,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: D_
                })
            } else
                throw new ic("You must provide either an email or phone number and a password");
            const {data: i, error: r} = n;
            return r ? {
                data: {
                    user: null,
                    session: null
                },
                error: r
            } : !i || !i.session || !i.user ? {
                data: {
                    user: null,
                    session: null
                },
                error: new nc
            } : (i.session && (await this._saveSession(i.session),
            await this._notifyAllSubscribers("SIGNED_IN", i.session)),
            {
                data: Object.assign({
                    user: i.user,
                    session: i.session
                }, i.weak_password ? {
                    weakPassword: i.weak_password
                } : null),
                error: r
            })
        } catch (n) {
            if (Fe(n))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: n
                };
            throw n
        }
    }
    async signInWithOAuth(e) {
        var n, i, r, s;
        return await this._handleProviderSignIn(e.provider, {
            redirectTo: (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo,
            scopes: (i = e.options) === null || i === void 0 ? void 0 : i.scopes,
            queryParams: (r = e.options) === null || r === void 0 ? void 0 : r.queryParams,
            skipBrowserRedirect: (s = e.options) === null || s === void 0 ? void 0 : s.skipBrowserRedirect
        })
    }
    async exchangeCodeForSession(e) {
        return await this.initializePromise,
        this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
    }
    async signInWithWeb3(e) {
        const {chain: n} = e;
        if (n === "solana")
            return await this.signInWithSolana(e);
        throw new Error(`@supabase/auth-js: Unsupported chain "${n}"`)
    }
    async signInWithSolana(e) {
        var n, i, r, s, o, a, l, c, u, d, h, p;
        let v, x;
        if ("message"in e)
            v = e.message,
            x = e.signature;
        else {
            const {chain: g, wallet: f, statement: y, options: _} = e;
            let S;
            if (ei())
                if (typeof f == "object")
                    S = f;
                else {
                    const A = window;
                    if ("solana"in A && typeof A.solana == "object" && ("signIn"in A.solana && typeof A.solana.signIn == "function" || "signMessage"in A.solana && typeof A.solana.signMessage == "function"))
                        S = A.solana;
                    else
                        throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof f != "object" || !(_ != null && _.url))
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                S = f
            }
            const T = new URL((n = _ == null ? void 0 : _.url) !== null && n !== void 0 ? n : window.location.href);
            if ("signIn"in S && S.signIn) {
                const A = await S.signIn(Object.assign(Object.assign(Object.assign({
                    issuedAt: new Date().toISOString()
                }, _ == null ? void 0 : _.signInWithSolana), {
                    version: "1",
                    domain: T.host,
                    uri: T.href
                }), y ? {
                    statement: y
                } : null));
                let C;
                if (Array.isArray(A) && A[0] && typeof A[0] == "object")
                    C = A[0];
                else if (A && typeof A == "object" && "signedMessage"in A && "signature"in A)
                    C = A;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
                if ("signedMessage"in C && "signature"in C && (typeof C.signedMessage == "string" || C.signedMessage instanceof Uint8Array) && C.signature instanceof Uint8Array)
                    v = typeof C.signedMessage == "string" ? C.signedMessage : new TextDecoder().decode(C.signedMessage),
                    x = C.signature;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")
            } else {
                if (!("signMessage"in S) || typeof S.signMessage != "function" || !("publicKey"in S) || typeof S != "object" || !S.publicKey || !("toBase58"in S.publicKey) || typeof S.publicKey.toBase58 != "function")
                    throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
                v = [`${T.host} wants you to sign in with your Solana account:`, S.publicKey.toBase58(), ...y ? ["", y, ""] : [""], "Version: 1", `URI: ${T.href}`, `Issued At: ${(r = (i = _ == null ? void 0 : _.signInWithSolana) === null || i === void 0 ? void 0 : i.issuedAt) !== null && r !== void 0 ? r : new Date().toISOString()}`, ...!((s = _ == null ? void 0 : _.signInWithSolana) === null || s === void 0) && s.notBefore ? [`Not Before: ${_.signInWithSolana.notBefore}`] : [], ...!((o = _ == null ? void 0 : _.signInWithSolana) === null || o === void 0) && o.expirationTime ? [`Expiration Time: ${_.signInWithSolana.expirationTime}`] : [], ...!((a = _ == null ? void 0 : _.signInWithSolana) === null || a === void 0) && a.chainId ? [`Chain ID: ${_.signInWithSolana.chainId}`] : [], ...!((l = _ == null ? void 0 : _.signInWithSolana) === null || l === void 0) && l.nonce ? [`Nonce: ${_.signInWithSolana.nonce}`] : [], ...!((c = _ == null ? void 0 : _.signInWithSolana) === null || c === void 0) && c.requestId ? [`Request ID: ${_.signInWithSolana.requestId}`] : [], ...!((d = (u = _ == null ? void 0 : _.signInWithSolana) === null || u === void 0 ? void 0 : u.resources) === null || d === void 0) && d.length ? ["Resources", ..._.signInWithSolana.resources.map(C => `- ${C}`)] : []].join(`
`);
                const A = await S.signMessage(new TextEncoder().encode(v), "utf8");
                if (!A || !(A instanceof Uint8Array))
                    throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
                x = A
            }
        }
        try {
            const {data: g, error: f} = await He(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "solana",
                    message: v,
                    signature: xN(x)
                }, !((h = e.options) === null || h === void 0) && h.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (p = e.options) === null || p === void 0 ? void 0 : p.captchaToken
                    }
                } : null),
                xform: Ni
            });
            if (f)
                throw f;
            return !g || !g.session || !g.user ? {
                data: {
                    user: null,
                    session: null
                },
                error: new nc
            } : (g.session && (await this._saveSession(g.session),
            await this._notifyAllSubscribers("SIGNED_IN", g.session)),
            {
                data: Object.assign({}, g),
                error: f
            })
        } catch (g) {
            if (Fe(g))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: g
                };
            throw g
        }
    }
    async _exchangeCodeForSession(e) {
        const n = await Gr(this.storage, `${this.storageKey}-code-verifier`)
          , [i,r] = (n ?? "").split("/");
        try {
            const {data: s, error: o} = await He(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
                headers: this.headers,
                body: {
                    auth_code: e,
                    code_verifier: i
                },
                xform: Ni
            });
            if (await nr(this.storage, `${this.storageKey}-code-verifier`),
            o)
                throw o;
            return !s || !s.session || !s.user ? {
                data: {
                    user: null,
                    session: null,
                    redirectType: null
                },
                error: new nc
            } : (s.session && (await this._saveSession(s.session),
            await this._notifyAllSubscribers("SIGNED_IN", s.session)),
            {
                data: Object.assign(Object.assign({}, s), {
                    redirectType: r ?? null
                }),
                error: o
            })
        } catch (s) {
            if (Fe(s))
                return {
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: s
                };
            throw s
        }
    }
    async signInWithIdToken(e) {
        try {
            const {options: n, provider: i, token: r, access_token: s, nonce: o} = e
              , a = await He(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                headers: this.headers,
                body: {
                    provider: i,
                    id_token: r,
                    access_token: s,
                    nonce: o,
                    gotrue_meta_security: {
                        captcha_token: n == null ? void 0 : n.captchaToken
                    }
                },
                xform: Ni
            })
              , {data: l, error: c} = a;
            return c ? {
                data: {
                    user: null,
                    session: null
                },
                error: c
            } : !l || !l.session || !l.user ? {
                data: {
                    user: null,
                    session: null
                },
                error: new nc
            } : (l.session && (await this._saveSession(l.session),
            await this._notifyAllSubscribers("SIGNED_IN", l.session)),
            {
                data: l,
                error: c
            })
        } catch (n) {
            if (Fe(n))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: n
                };
            throw n
        }
    }
    async signInWithOtp(e) {
        var n, i, r, s, o;
        try {
            if ("email"in e) {
                const {email: a, options: l} = e;
                let c = null
                  , u = null;
                this.flowType === "pkce" && ([c,u] = await Ns(this.storage, this.storageKey));
                const {error: d} = await He(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        email: a,
                        data: (n = l == null ? void 0 : l.data) !== null && n !== void 0 ? n : {},
                        create_user: (i = l == null ? void 0 : l.shouldCreateUser) !== null && i !== void 0 ? i : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        code_challenge: c,
                        code_challenge_method: u
                    },
                    redirectTo: l == null ? void 0 : l.emailRedirectTo
                });
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: d
                }
            }
            if ("phone"in e) {
                const {phone: a, options: l} = e
                  , {data: c, error: u} = await He(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        phone: a,
                        data: (r = l == null ? void 0 : l.data) !== null && r !== void 0 ? r : {},
                        create_user: (s = l == null ? void 0 : l.shouldCreateUser) !== null && s !== void 0 ? s : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        channel: (o = l == null ? void 0 : l.channel) !== null && o !== void 0 ? o : "sms"
                    }
                });
                return {
                    data: {
                        user: null,
                        session: null,
                        messageId: c == null ? void 0 : c.message_id
                    },
                    error: u
                }
            }
            throw new ic("You must provide either an email or phone number.")
        } catch (a) {
            if (Fe(a))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                };
            throw a
        }
    }
    async verifyOtp(e) {
        var n, i;
        try {
            let r, s;
            "options"in e && (r = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo,
            s = (i = e.options) === null || i === void 0 ? void 0 : i.captchaToken);
            const {data: o, error: a} = await He(this.fetch, "POST", `${this.url}/verify`, {
                headers: this.headers,
                body: Object.assign(Object.assign({}, e), {
                    gotrue_meta_security: {
                        captcha_token: s
                    }
                }),
                redirectTo: r,
                xform: Ni
            });
            if (a)
                throw a;
            if (!o)
                throw new Error("An error occurred on token verification.");
            const l = o.session
              , c = o.user;
            return l != null && l.access_token && (await this._saveSession(l),
            await this._notifyAllSubscribers(e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", l)),
            {
                data: {
                    user: c,
                    session: l
                },
                error: null
            }
        } catch (r) {
            if (Fe(r))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                };
            throw r
        }
    }
    async signInWithSSO(e) {
        var n, i, r;
        try {
            let s = null
              , o = null;
            return this.flowType === "pkce" && ([s,o] = await Ns(this.storage, this.storageKey)),
            await He(this.fetch, "POST", `${this.url}/sso`, {
                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId"in e ? {
                    provider_id: e.providerId
                } : null), "domain"in e ? {
                    domain: e.domain
                } : null), {
                    redirect_to: (i = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo) !== null && i !== void 0 ? i : void 0
                }), !((r = e == null ? void 0 : e.options) === null || r === void 0) && r.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: e.options.captchaToken
                    }
                } : null), {
                    skip_http_redirect: !0,
                    code_challenge: s,
                    code_challenge_method: o
                }),
                headers: this.headers,
                xform: zN
            })
        } catch (s) {
            if (Fe(s))
                return {
                    data: null,
                    error: s
                };
            throw s
        }
    }
    async reauthenticate() {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._reauthenticate())
    }
    async _reauthenticate() {
        try {
            return await this._useSession(async e => {
                const {data: {session: n}, error: i} = e;
                if (i)
                    throw i;
                if (!n)
                    throw new ur;
                const {error: r} = await He(this.fetch, "GET", `${this.url}/reauthenticate`, {
                    headers: this.headers,
                    jwt: n.access_token
                });
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                }
            }
            )
        } catch (e) {
            if (Fe(e))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: e
                };
            throw e
        }
    }
    async resend(e) {
        try {
            const n = `${this.url}/resend`;
            if ("email"in e) {
                const {email: i, type: r, options: s} = e
                  , {error: o} = await He(this.fetch, "POST", n, {
                    headers: this.headers,
                    body: {
                        email: i,
                        type: r,
                        gotrue_meta_security: {
                            captcha_token: s == null ? void 0 : s.captchaToken
                        }
                    },
                    redirectTo: s == null ? void 0 : s.emailRedirectTo
                });
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: o
                }
            } else if ("phone"in e) {
                const {phone: i, type: r, options: s} = e
                  , {data: o, error: a} = await He(this.fetch, "POST", n, {
                    headers: this.headers,
                    body: {
                        phone: i,
                        type: r,
                        gotrue_meta_security: {
                            captcha_token: s == null ? void 0 : s.captchaToken
                        }
                    }
                });
                return {
                    data: {
                        user: null,
                        session: null,
                        messageId: o == null ? void 0 : o.message_id
                    },
                    error: a
                }
            }
            throw new ic("You must provide either an email or phone number and a type")
        } catch (n) {
            if (Fe(n))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: n
                };
            throw n
        }
    }
    async getSession() {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => this._useSession(async n => n))
    }
    async _acquireLock(e, n) {
        this._debug("#_acquireLock", "begin", e);
        try {
            if (this.lockAcquired) {
                const i = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve()
                  , r = (async () => (await i,
                await n()))();
                return this.pendingInLock.push((async () => {
                    try {
                        await r
                    } catch {}
                }
                )()),
                r
            }
            return await this.lock(`lock:${this.storageKey}`, e, async () => {
                this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
                try {
                    this.lockAcquired = !0;
                    const i = n();
                    for (this.pendingInLock.push((async () => {
                        try {
                            await i
                        } catch {}
                    }
                    )()),
                    await i; this.pendingInLock.length; ) {
                        const r = [...this.pendingInLock];
                        await Promise.all(r),
                        this.pendingInLock.splice(0, r.length)
                    }
                    return await i
                } finally {
                    this._debug("#_acquireLock", "lock released for storage key", this.storageKey),
                    this.lockAcquired = !1
                }
            }
            )
        } finally {
            this._debug("#_acquireLock", "end")
        }
    }
    async _useSession(e) {
        this._debug("#_useSession", "begin");
        try {
            const n = await this.__loadSession();
            return await e(n)
        } finally {
            this._debug("#_useSession", "end")
        }
    }
    async __loadSession() {
        this._debug("#__loadSession()", "begin"),
        this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
        try {
            let e = null;
            const n = await Gr(this.storage, this.storageKey);
            if (this._debug("#getSession()", "session from storage", n),
            n !== null && (this._isValidSession(n) ? e = n : (this._debug("#getSession()", "session from storage is not valid"),
            await this._removeSession())),
            !e)
                return {
                    data: {
                        session: null
                    },
                    error: null
                };
            const i = e.expires_at ? e.expires_at * 1e3 - Date.now() < nh : !1;
            if (this._debug("#__loadSession()", `session has${i ? "" : " not"} expired`, "expires_at", e.expires_at),
            !i) {
                if (this.userStorage) {
                    const o = await Gr(this.userStorage, this.storageKey + "-user");
                    o != null && o.user ? e.user = o.user : e.user = sh()
                }
                if (this.storage.isServer && e.user) {
                    let o = this.suppressGetSessionWarning;
                    e = new Proxy(e,{
                        get: (l, c, u) => (!o && c === "user" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),
                        o = !0,
                        this.suppressGetSessionWarning = !0),
                        Reflect.get(l, c, u))
                    })
                }
                return {
                    data: {
                        session: e
                    },
                    error: null
                }
            }
            const {session: r, error: s} = await this._callRefreshToken(e.refresh_token);
            return s ? {
                data: {
                    session: null
                },
                error: s
            } : {
                data: {
                    session: r
                },
                error: null
            }
        } finally {
            this._debug("#__loadSession()", "end")
        }
    }
    async getUser(e) {
        return e ? await this._getUser(e) : (await this.initializePromise,
        await this._acquireLock(-1, async () => await this._getUser()))
    }
    async _getUser(e) {
        try {
            return e ? await He(this.fetch, "GET", `${this.url}/user`, {
                headers: this.headers,
                jwt: e,
                xform: mr
            }) : await this._useSession(async n => {
                var i, r, s;
                const {data: o, error: a} = n;
                if (a)
                    throw a;
                return !(!((i = o.session) === null || i === void 0) && i.access_token) && !this.hasCustomAuthorizationHeader ? {
                    data: {
                        user: null
                    },
                    error: new ur
                } : await He(this.fetch, "GET", `${this.url}/user`, {
                    headers: this.headers,
                    jwt: (s = (r = o.session) === null || r === void 0 ? void 0 : r.access_token) !== null && s !== void 0 ? s : void 0,
                    xform: mr
                })
            }
            )
        } catch (n) {
            if (Fe(n))
                return hN(n) && (await this._removeSession(),
                await nr(this.storage, `${this.storageKey}-code-verifier`)),
                {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async updateUser(e, n={}) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._updateUser(e, n))
    }
    async _updateUser(e, n={}) {
        try {
            return await this._useSession(async i => {
                const {data: r, error: s} = i;
                if (s)
                    throw s;
                if (!r.session)
                    throw new ur;
                const o = r.session;
                let a = null
                  , l = null;
                this.flowType === "pkce" && e.email != null && ([a,l] = await Ns(this.storage, this.storageKey));
                const {data: c, error: u} = await He(this.fetch, "PUT", `${this.url}/user`, {
                    headers: this.headers,
                    redirectTo: n == null ? void 0 : n.emailRedirectTo,
                    body: Object.assign(Object.assign({}, e), {
                        code_challenge: a,
                        code_challenge_method: l
                    }),
                    jwt: o.access_token,
                    xform: mr
                });
                if (u)
                    throw u;
                return o.user = c.user,
                await this._saveSession(o),
                await this._notifyAllSubscribers("USER_UPDATED", o),
                {
                    data: {
                        user: o.user
                    },
                    error: null
                }
            }
            )
        } catch (i) {
            if (Fe(i))
                return {
                    data: {
                        user: null
                    },
                    error: i
                };
            throw i
        }
    }
    async setSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._setSession(e))
    }
    async _setSession(e) {
        try {
            if (!e.access_token || !e.refresh_token)
                throw new ur;
            const n = Date.now() / 1e3;
            let i = n
              , r = !0
              , s = null;
            const {payload: o} = rh(e.access_token);
            if (o.exp && (i = o.exp,
            r = i <= n),
            r) {
                const {session: a, error: l} = await this._callRefreshToken(e.refresh_token);
                if (l)
                    return {
                        data: {
                            user: null,
                            session: null
                        },
                        error: l
                    };
                if (!a)
                    return {
                        data: {
                            user: null,
                            session: null
                        },
                        error: null
                    };
                s = a
            } else {
                const {data: a, error: l} = await this._getUser(e.access_token);
                if (l)
                    throw l;
                s = {
                    access_token: e.access_token,
                    refresh_token: e.refresh_token,
                    user: a.user,
                    token_type: "bearer",
                    expires_in: i - n,
                    expires_at: i
                },
                await this._saveSession(s),
                await this._notifyAllSubscribers("SIGNED_IN", s)
            }
            return {
                data: {
                    user: s.user,
                    session: s
                },
                error: null
            }
        } catch (n) {
            if (Fe(n))
                return {
                    data: {
                        session: null,
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async refreshSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._refreshSession(e))
    }
    async _refreshSession(e) {
        try {
            return await this._useSession(async n => {
                var i;
                if (!e) {
                    const {data: o, error: a} = n;
                    if (a)
                        throw a;
                    e = (i = o.session) !== null && i !== void 0 ? i : void 0
                }
                if (!(e != null && e.refresh_token))
                    throw new ur;
                const {session: r, error: s} = await this._callRefreshToken(e.refresh_token);
                return s ? {
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                } : r ? {
                    data: {
                        user: r.user,
                        session: r
                    },
                    error: null
                } : {
                    data: {
                        user: null,
                        session: null
                    },
                    error: null
                }
            }
            )
        } catch (n) {
            if (Fe(n))
                return {
                    data: {
                        user: null,
                        session: null
                    },
                    error: n
                };
            throw n
        }
    }
    async _getSessionFromURL(e, n) {
        try {
            if (!ei())
                throw new rc("No browser detected.");
            if (e.error || e.error_description || e.error_code)
                throw new rc(e.error_description || "Error in URL with unspecified error_description",{
                    error: e.error || "unspecified_error",
                    code: e.error_code || "unspecified_code"
                });
            switch (n) {
            case "implicit":
                if (this.flowType === "pkce")
                    throw new T_("Not a valid PKCE flow url.");
                break;
            case "pkce":
                if (this.flowType === "implicit")
                    throw new rc("Not a valid implicit grant flow url.");
                break;
            default:
            }
            if (n === "pkce") {
                if (this._debug("#_initialize()", "begin", "is PKCE flow", !0),
                !e.code)
                    throw new T_("No code detected.");
                const {data: y, error: _} = await this._exchangeCodeForSession(e.code);
                if (_)
                    throw _;
                const S = new URL(window.location.href);
                return S.searchParams.delete("code"),
                window.history.replaceState(window.history.state, "", S.toString()),
                {
                    data: {
                        session: y.session,
                        redirectType: null
                    },
                    error: null
                }
            }
            const {provider_token: i, provider_refresh_token: r, access_token: s, refresh_token: o, expires_in: a, expires_at: l, token_type: c} = e;
            if (!s || !a || !o || !c)
                throw new rc("No session defined in URL");
            const u = Math.round(Date.now() / 1e3)
              , d = parseInt(a);
            let h = u + d;
            l && (h = parseInt(l));
            const p = h - u;
            p * 1e3 <= Ks && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${p}s, should have been closer to ${d}s`);
            const v = h - d;
            u - v >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", v, h, u) : u - v < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", v, h, u);
            const {data: x, error: g} = await this._getUser(s);
            if (g)
                throw g;
            const f = {
                provider_token: i,
                provider_refresh_token: r,
                access_token: s,
                expires_in: d,
                expires_at: h,
                refresh_token: o,
                token_type: c,
                user: x.user
            };
            return window.location.hash = "",
            this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
            {
                data: {
                    session: f,
                    redirectType: e.type
                },
                error: null
            }
        } catch (i) {
            if (Fe(i))
                return {
                    data: {
                        session: null,
                        redirectType: null
                    },
                    error: i
                };
            throw i
        }
    }
    _isImplicitGrantCallback(e) {
        return !!(e.access_token || e.error_description)
    }
    async _isPKCECallback(e) {
        const n = await Gr(this.storage, `${this.storageKey}-code-verifier`);
        return !!(e.code && n)
    }
    async signOut(e={
        scope: "global"
    }) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._signOut(e))
    }
    async _signOut({scope: e}={
        scope: "global"
    }) {
        return await this._useSession(async n => {
            var i;
            const {data: r, error: s} = n;
            if (s)
                return {
                    error: s
                };
            const o = (i = r.session) === null || i === void 0 ? void 0 : i.access_token;
            if (o) {
                const {error: a} = await this.admin.signOut(o, e);
                if (a && !(dN(a) && (a.status === 404 || a.status === 401 || a.status === 403)))
                    return {
                        error: a
                    }
            }
            return e !== "others" && (await this._removeSession(),
            await nr(this.storage, `${this.storageKey}-code-verifier`)),
            {
                error: null
            }
        }
        )
    }
    onAuthStateChange(e) {
        const n = wN()
          , i = {
            id: n,
            callback: e,
            unsubscribe: () => {
                this._debug("#unsubscribe()", "state change callback with id removed", n),
                this.stateChangeEmitters.delete(n)
            }
        };
        return this._debug("#onAuthStateChange()", "registered callback with id", n),
        this.stateChangeEmitters.set(n, i),
        (async () => (await this.initializePromise,
        await this._acquireLock(-1, async () => {
            this._emitInitialSession(n)
        }
        )))(),
        {
            data: {
                subscription: i
            }
        }
    }
    async _emitInitialSession(e) {
        return await this._useSession(async n => {
            var i, r;
            try {
                const {data: {session: s}, error: o} = n;
                if (o)
                    throw o;
                await ((i = this.stateChangeEmitters.get(e)) === null || i === void 0 ? void 0 : i.callback("INITIAL_SESSION", s)),
                this._debug("INITIAL_SESSION", "callback id", e, "session", s)
            } catch (s) {
                await ((r = this.stateChangeEmitters.get(e)) === null || r === void 0 ? void 0 : r.callback("INITIAL_SESSION", null)),
                this._debug("INITIAL_SESSION", "callback id", e, "error", s),
                console.error(s)
            }
        }
        )
    }
    async resetPasswordForEmail(e, n={}) {
        let i = null
          , r = null;
        this.flowType === "pkce" && ([i,r] = await Ns(this.storage, this.storageKey, !0));
        try {
            return await He(this.fetch, "POST", `${this.url}/recover`, {
                body: {
                    email: e,
                    code_challenge: i,
                    code_challenge_method: r,
                    gotrue_meta_security: {
                        captcha_token: n.captchaToken
                    }
                },
                headers: this.headers,
                redirectTo: n.redirectTo
            })
        } catch (s) {
            if (Fe(s))
                return {
                    data: null,
                    error: s
                };
            throw s
        }
    }
    async getUserIdentities() {
        var e;
        try {
            const {data: n, error: i} = await this.getUser();
            if (i)
                throw i;
            return {
                data: {
                    identities: (e = n.user.identities) !== null && e !== void 0 ? e : []
                },
                error: null
            }
        } catch (n) {
            if (Fe(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async linkIdentity(e) {
        var n;
        try {
            const {data: i, error: r} = await this._useSession(async s => {
                var o, a, l, c, u;
                const {data: d, error: h} = s;
                if (h)
                    throw h;
                const p = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, e.provider, {
                    redirectTo: (o = e.options) === null || o === void 0 ? void 0 : o.redirectTo,
                    scopes: (a = e.options) === null || a === void 0 ? void 0 : a.scopes,
                    queryParams: (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
                    skipBrowserRedirect: !0
                });
                return await He(this.fetch, "GET", p, {
                    headers: this.headers,
                    jwt: (u = (c = d.session) === null || c === void 0 ? void 0 : c.access_token) !== null && u !== void 0 ? u : void 0
                })
            }
            );
            if (r)
                throw r;
            return ei() && !(!((n = e.options) === null || n === void 0) && n.skipBrowserRedirect) && window.location.assign(i == null ? void 0 : i.url),
            {
                data: {
                    provider: e.provider,
                    url: i == null ? void 0 : i.url
                },
                error: null
            }
        } catch (i) {
            if (Fe(i))
                return {
                    data: {
                        provider: e.provider,
                        url: null
                    },
                    error: i
                };
            throw i
        }
    }
    async unlinkIdentity(e) {
        try {
            return await this._useSession(async n => {
                var i, r;
                const {data: s, error: o} = n;
                if (o)
                    throw o;
                return await He(this.fetch, "DELETE", `${this.url}/user/identities/${e.identity_id}`, {
                    headers: this.headers,
                    jwt: (r = (i = s.session) === null || i === void 0 ? void 0 : i.access_token) !== null && r !== void 0 ? r : void 0
                })
            }
            )
        } catch (n) {
            if (Fe(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _refreshAccessToken(e) {
        const n = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
        this._debug(n, "begin");
        try {
            const i = Date.now();
            return await MN(async r => (r > 0 && await TN(200 * Math.pow(2, r - 1)),
            this._debug(n, "refreshing attempt", r),
            await He(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
                body: {
                    refresh_token: e
                },
                headers: this.headers,
                xform: Ni
            })), (r, s) => {
                const o = 200 * Math.pow(2, r);
                return s && ih(s) && Date.now() + o - i < Ks
            }
            )
        } catch (i) {
            if (this._debug(n, "error", i),
            Fe(i))
                return {
                    data: {
                        session: null,
                        user: null
                    },
                    error: i
                };
            throw i
        } finally {
            this._debug(n, "end")
        }
    }
    _isValidSession(e) {
        return typeof e == "object" && e !== null && "access_token"in e && "refresh_token"in e && "expires_at"in e
    }
    async _handleProviderSignIn(e, n) {
        const i = await this._getUrlForProvider(`${this.url}/authorize`, e, {
            redirectTo: n.redirectTo,
            scopes: n.scopes,
            queryParams: n.queryParams
        });
        return this._debug("#_handleProviderSignIn()", "provider", e, "options", n, "url", i),
        ei() && !n.skipBrowserRedirect && window.location.assign(i),
        {
            data: {
                provider: e,
                url: i
            },
            error: null
        }
    }
    async _recoverAndRefresh() {
        var e, n;
        const i = "#_recoverAndRefresh()";
        this._debug(i, "begin");
        try {
            const r = await Gr(this.storage, this.storageKey);
            if (r && this.userStorage) {
                let o = await Gr(this.userStorage, this.storageKey + "-user");
                !this.storage.isServer && Object.is(this.storage, this.userStorage) && !o && (o = {
                    user: r.user
                },
                await Ys(this.userStorage, this.storageKey + "-user", o)),
                r.user = (e = o == null ? void 0 : o.user) !== null && e !== void 0 ? e : sh()
            } else if (r && !r.user && !r.user) {
                const o = await Gr(this.storage, this.storageKey + "-user");
                o && (o != null && o.user) ? (r.user = o.user,
                await nr(this.storage, this.storageKey + "-user"),
                await Ys(this.storage, this.storageKey, r)) : r.user = sh()
            }
            if (this._debug(i, "session from storage", r),
            !this._isValidSession(r)) {
                this._debug(i, "session is not valid"),
                r !== null && await this._removeSession();
                return
            }
            const s = ((n = r.expires_at) !== null && n !== void 0 ? n : 1 / 0) * 1e3 - Date.now() < nh;
            if (this._debug(i, `session has${s ? "" : " not"} expired with margin of ${nh}s`),
            s) {
                if (this.autoRefreshToken && r.refresh_token) {
                    const {error: o} = await this._callRefreshToken(r.refresh_token);
                    o && (console.error(o),
                    ih(o) || (this._debug(i, "refresh failed with a non-retryable error, removing the session", o),
                    await this._removeSession()))
                }
            } else if (r.user && r.user.__isUserNotAvailableProxy === !0)
                try {
                    const {data: o, error: a} = await this._getUser(r.access_token);
                    !a && (o != null && o.user) ? (r.user = o.user,
                    await this._saveSession(r),
                    await this._notifyAllSubscribers("SIGNED_IN", r)) : this._debug(i, "could not get user data, skipping SIGNED_IN notification")
                } catch (o) {
                    console.error("Error getting user data:", o),
                    this._debug(i, "error getting user data, skipping SIGNED_IN notification", o)
                }
            else
                await this._notifyAllSubscribers("SIGNED_IN", r)
        } catch (r) {
            this._debug(i, "error", r),
            console.error(r);
            return
        } finally {
            this._debug(i, "end")
        }
    }
    async _callRefreshToken(e) {
        var n, i;
        if (!e)
            throw new ur;
        if (this.refreshingDeferred)
            return this.refreshingDeferred.promise;
        const r = `#_callRefreshToken(${e.substring(0, 5)}...)`;
        this._debug(r, "begin");
        try {
            this.refreshingDeferred = new nd;
            const {data: s, error: o} = await this._refreshAccessToken(e);
            if (o)
                throw o;
            if (!s.session)
                throw new ur;
            await this._saveSession(s.session),
            await this._notifyAllSubscribers("TOKEN_REFRESHED", s.session);
            const a = {
                session: s.session,
                error: null
            };
            return this.refreshingDeferred.resolve(a),
            a
        } catch (s) {
            if (this._debug(r, "error", s),
            Fe(s)) {
                const o = {
                    session: null,
                    error: s
                };
                return ih(s) || await this._removeSession(),
                (n = this.refreshingDeferred) === null || n === void 0 || n.resolve(o),
                o
            }
            throw (i = this.refreshingDeferred) === null || i === void 0 || i.reject(s),
            s
        } finally {
            this.refreshingDeferred = null,
            this._debug(r, "end")
        }
    }
    async _notifyAllSubscribers(e, n, i=!0) {
        const r = `#_notifyAllSubscribers(${e})`;
        this._debug(r, "begin", n, `broadcast = ${i}`);
        try {
            this.broadcastChannel && i && this.broadcastChannel.postMessage({
                event: e,
                session: n
            });
            const s = []
              , o = Array.from(this.stateChangeEmitters.values()).map(async a => {
                try {
                    await a.callback(e, n)
                } catch (l) {
                    s.push(l)
                }
            }
            );
            if (await Promise.all(o),
            s.length > 0) {
                for (let a = 0; a < s.length; a += 1)
                    console.error(s[a]);
                throw s[0]
            }
        } finally {
            this._debug(r, "end")
        }
    }
    async _saveSession(e) {
        this._debug("#_saveSession()", e),
        this.suppressGetSessionWarning = !0;
        const n = Object.assign({}, e)
          , i = n.user && n.user.__isUserNotAvailableProxy === !0;
        if (this.userStorage) {
            !i && n.user && await Ys(this.userStorage, this.storageKey + "-user", {
                user: n.user
            });
            const r = Object.assign({}, n);
            delete r.user;
            const s = P_(r);
            await Ys(this.storage, this.storageKey, s)
        } else {
            const r = P_(n);
            await Ys(this.storage, this.storageKey, r)
        }
    }
    async _removeSession() {
        this._debug("#_removeSession()"),
        await nr(this.storage, this.storageKey),
        await nr(this.storage, this.storageKey + "-code-verifier"),
        await nr(this.storage, this.storageKey + "-user"),
        this.userStorage && await nr(this.userStorage, this.storageKey + "-user"),
        await this._notifyAllSubscribers("SIGNED_OUT", null)
    }
    _removeVisibilityChangedCallback() {
        this._debug("#_removeVisibilityChangedCallback()");
        const e = this.visibilityChangedCallback;
        this.visibilityChangedCallback = null;
        try {
            e && ei() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", e)
        } catch (n) {
            console.error("removing visibilitychange callback failed", n)
        }
    }
    async _startAutoRefresh() {
        await this._stopAutoRefresh(),
        this._debug("#_startAutoRefresh()");
        const e = setInterval( () => this._autoRefreshTokenTick(), Ks);
        this.autoRefreshTicker = e,
        e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e),
        setTimeout(async () => {
            await this.initializePromise,
            await this._autoRefreshTokenTick()
        }
        , 0)
    }
    async _stopAutoRefresh() {
        this._debug("#_stopAutoRefresh()");
        const e = this.autoRefreshTicker;
        this.autoRefreshTicker = null,
        e && clearInterval(e)
    }
    async startAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._startAutoRefresh()
    }
    async stopAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._stopAutoRefresh()
    }
    async _autoRefreshTokenTick() {
        this._debug("#_autoRefreshTokenTick()", "begin");
        try {
            await this._acquireLock(0, async () => {
                try {
                    const e = Date.now();
                    try {
                        return await this._useSession(async n => {
                            const {data: {session: i}} = n;
                            if (!i || !i.refresh_token || !i.expires_at) {
                                this._debug("#_autoRefreshTokenTick()", "no session");
                                return
                            }
                            const r = Math.floor((i.expires_at * 1e3 - e) / Ks);
                            this._debug("#_autoRefreshTokenTick()", `access token expires in ${r} ticks, a tick lasts ${Ks}ms, refresh threshold is ${sp} ticks`),
                            r <= sp && await this._callRefreshToken(i.refresh_token)
                        }
                        )
                    } catch (n) {
                        console.error("Auto refresh tick failed with error. This is likely a transient error.", n)
                    }
                } finally {
                    this._debug("#_autoRefreshTokenTick()", "end")
                }
            }
            )
        } catch (e) {
            if (e.isAcquireTimeout || e instanceof Hb)
                this._debug("auto refresh token tick lock not available");
            else
                throw e
        }
    }
    async _handleVisibilityChange() {
        if (this._debug("#_handleVisibilityChange()"),
        !ei() || !(window != null && window.addEventListener))
            return this.autoRefreshToken && this.startAutoRefresh(),
            !1;
        try {
            this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1),
            window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback),
            await this._onVisibilityChanged(!0)
        } catch (e) {
            console.error("_handleVisibilityChange", e)
        }
    }
    async _onVisibilityChanged(e) {
        const n = `#_onVisibilityChanged(${e})`;
        this._debug(n, "visibilityState", document.visibilityState),
        document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(),
        e || (await this.initializePromise,
        await this._acquireLock(-1, async () => {
            if (document.visibilityState !== "visible") {
                this._debug(n, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
                return
            }
            await this._recoverAndRefresh()
        }
        ))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh()
    }
    async _getUrlForProvider(e, n, i) {
        const r = [`provider=${encodeURIComponent(n)}`];
        if (i != null && i.redirectTo && r.push(`redirect_to=${encodeURIComponent(i.redirectTo)}`),
        i != null && i.scopes && r.push(`scopes=${encodeURIComponent(i.scopes)}`),
        this.flowType === "pkce") {
            const [s,o] = await Ns(this.storage, this.storageKey)
              , a = new URLSearchParams({
                code_challenge: `${encodeURIComponent(s)}`,
                code_challenge_method: `${encodeURIComponent(o)}`
            });
            r.push(a.toString())
        }
        if (i != null && i.queryParams) {
            const s = new URLSearchParams(i.queryParams);
            r.push(s.toString())
        }
        return i != null && i.skipBrowserRedirect && r.push(`skip_http_redirect=${i.skipBrowserRedirect}`),
        `${e}?${r.join("&")}`
    }
    async _unenroll(e) {
        try {
            return await this._useSession(async n => {
                var i;
                const {data: r, error: s} = n;
                return s ? {
                    data: null,
                    error: s
                } : await He(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, {
                    headers: this.headers,
                    jwt: (i = r == null ? void 0 : r.session) === null || i === void 0 ? void 0 : i.access_token
                })
            }
            )
        } catch (n) {
            if (Fe(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _enroll(e) {
        try {
            return await this._useSession(async n => {
                var i, r;
                const {data: s, error: o} = n;
                if (o)
                    return {
                        data: null,
                        error: o
                    };
                const a = Object.assign({
                    friendly_name: e.friendlyName,
                    factor_type: e.factorType
                }, e.factorType === "phone" ? {
                    phone: e.phone
                } : {
                    issuer: e.issuer
                })
                  , {data: l, error: c} = await He(this.fetch, "POST", `${this.url}/factors`, {
                    body: a,
                    headers: this.headers,
                    jwt: (i = s == null ? void 0 : s.session) === null || i === void 0 ? void 0 : i.access_token
                });
                return c ? {
                    data: null,
                    error: c
                } : (e.factorType === "totp" && (!((r = l == null ? void 0 : l.totp) === null || r === void 0) && r.qr_code) && (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
                {
                    data: l,
                    error: null
                })
            }
            )
        } catch (n) {
            if (Fe(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _verify(e) {
        return this._acquireLock(-1, async () => {
            try {
                return await this._useSession(async n => {
                    var i;
                    const {data: r, error: s} = n;
                    if (s)
                        return {
                            data: null,
                            error: s
                        };
                    const {data: o, error: a} = await He(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, {
                        body: {
                            code: e.code,
                            challenge_id: e.challengeId
                        },
                        headers: this.headers,
                        jwt: (i = r == null ? void 0 : r.session) === null || i === void 0 ? void 0 : i.access_token
                    });
                    return a ? {
                        data: null,
                        error: a
                    } : (await this._saveSession(Object.assign({
                        expires_at: Math.round(Date.now() / 1e3) + o.expires_in
                    }, o)),
                    await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", o),
                    {
                        data: o,
                        error: a
                    })
                }
                )
            } catch (n) {
                if (Fe(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        }
        )
    }
    async _challenge(e) {
        return this._acquireLock(-1, async () => {
            try {
                return await this._useSession(async n => {
                    var i;
                    const {data: r, error: s} = n;
                    return s ? {
                        data: null,
                        error: s
                    } : await He(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, {
                        body: {
                            channel: e.channel
                        },
                        headers: this.headers,
                        jwt: (i = r == null ? void 0 : r.session) === null || i === void 0 ? void 0 : i.access_token
                    })
                }
                )
            } catch (n) {
                if (Fe(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        }
        )
    }
    async _challengeAndVerify(e) {
        const {data: n, error: i} = await this._challenge({
            factorId: e.factorId
        });
        return i ? {
            data: null,
            error: i
        } : await this._verify({
            factorId: e.factorId,
            challengeId: n.id,
            code: e.code
        })
    }
    async _listFactors() {
        const {data: {user: e}, error: n} = await this.getUser();
        if (n)
            return {
                data: null,
                error: n
            };
        const i = (e == null ? void 0 : e.factors) || []
          , r = i.filter(o => o.factor_type === "totp" && o.status === "verified")
          , s = i.filter(o => o.factor_type === "phone" && o.status === "verified");
        return {
            data: {
                all: i,
                totp: r,
                phone: s
            },
            error: null
        }
    }
    async _getAuthenticatorAssuranceLevel() {
        return this._acquireLock(-1, async () => await this._useSession(async e => {
            var n, i;
            const {data: {session: r}, error: s} = e;
            if (s)
                return {
                    data: null,
                    error: s
                };
            if (!r)
                return {
                    data: {
                        currentLevel: null,
                        nextLevel: null,
                        currentAuthenticationMethods: []
                    },
                    error: null
                };
            const {payload: o} = rh(r.access_token);
            let a = null;
            o.aal && (a = o.aal);
            let l = a;
            ((i = (n = r.user.factors) === null || n === void 0 ? void 0 : n.filter(d => d.status === "verified")) !== null && i !== void 0 ? i : []).length > 0 && (l = "aal2");
            const u = o.amr || [];
            return {
                data: {
                    currentLevel: a,
                    nextLevel: l,
                    currentAuthenticationMethods: u
                },
                error: null
            }
        }
        ))
    }
    async fetchJwk(e, n={
        keys: []
    }) {
        let i = n.keys.find(a => a.kid === e);
        if (i)
            return i;
        const r = Date.now();
        if (i = this.jwks.keys.find(a => a.kid === e),
        i && this.jwks_cached_at + cN > r)
            return i;
        const {data: s, error: o} = await He(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
            headers: this.headers
        });
        if (o)
            throw o;
        return !s.keys || s.keys.length === 0 || (this.jwks = s,
        this.jwks_cached_at = r,
        i = s.keys.find(a => a.kid === e),
        !i) ? null : i
    }
    async getClaims(e, n={}) {
        try {
            let i = e;
            if (!i) {
                const {data: p, error: v} = await this.getSession();
                if (v || !p.session)
                    return {
                        data: null,
                        error: v
                    };
                i = p.session.access_token
            }
            const {header: r, payload: s, signature: o, raw: {header: a, payload: l}} = rh(i);
            n != null && n.allowExpired || LN(s.exp);
            const c = !r.alg || r.alg.startsWith("HS") || !r.kid || !("crypto"in globalThis && "subtle"in globalThis.crypto) ? null : await this.fetchJwk(r.kid, n != null && n.keys ? {
                keys: n.keys
            } : n == null ? void 0 : n.jwks);
            if (!c) {
                const {error: p} = await this.getUser(i);
                if (p)
                    throw p;
                return {
                    data: {
                        claims: s,
                        header: r,
                        signature: o
                    },
                    error: null
                }
            }
            const u = IN(r.alg)
              , d = await crypto.subtle.importKey("jwk", c, u, !0, ["verify"]);
            if (!await crypto.subtle.verify(u, d, o, yN(`${a}.${l}`)))
                throw new lp("Invalid JWT signature");
            return {
                data: {
                    claims: s,
                    header: r,
                    signature: o
                },
                error: null
            }
        } catch (i) {
            if (Fe(i))
                return {
                    data: null,
                    error: i
                };
            throw i
        }
    }
}
ol.nextInstanceID = 0;
const YN = ol;
class ZN extends YN {
    constructor(e) {
        super(e)
    }
}
var JN = function(t, e, n, i) {
    function r(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(i.next(u))
            } catch (d) {
                o(d)
            }
        }
        function l(u) {
            try {
                c(i.throw(u))
            } catch (d) {
                o(d)
            }
        }
        function c(u) {
            u.done ? s(u.value) : r(u.value).then(a, l)
        }
        c((i = i.apply(t, e || [])).next())
    }
    )
};
class QN {
    constructor(e, n, i) {
        var r, s, o;
        this.supabaseUrl = e,
        this.supabaseKey = n;
        const a = rN(e);
        if (!n)
            throw new Error("supabaseKey is required.");
        this.realtimeUrl = new URL("realtime/v1",a),
        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"),
        this.authUrl = new URL("auth/v1",a),
        this.storageUrl = new URL("storage/v1",a),
        this.functionsUrl = new URL("functions/v1",a);
        const l = `sb-${a.hostname.split(".")[0]}-auth-token`
          , c = {
            db: q2,
            realtime: Y2,
            auth: Object.assign(Object.assign({}, K2), {
                storageKey: l
            }),
            global: X2
        }
          , u = iN(i ?? {}, c);
        this.storageKey = (r = u.auth.storageKey) !== null && r !== void 0 ? r : "",
        this.headers = (s = u.global.headers) !== null && s !== void 0 ? s : {},
        u.accessToken ? (this.accessToken = u.accessToken,
        this.auth = new Proxy({},{
            get: (d, h) => {
                throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(h)} is not possible`)
            }
        })) : this.auth = this._initSupabaseAuthClient((o = u.auth) !== null && o !== void 0 ? o : {}, this.headers, u.global.fetch),
        this.fetch = eN(n, this._getAccessToken.bind(this), u.global.fetch),
        this.realtime = this._initRealtimeClient(Object.assign({
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this)
        }, u.realtime)),
        this.rest = new p2(new URL("rest/v1",a).href,{
            headers: this.headers,
            schema: u.db.schema,
            fetch: this.fetch
        }),
        this.storage = new G2(this.storageUrl.href,this.headers,this.fetch,i == null ? void 0 : i.storage),
        u.accessToken || this._listenForAuthEvents()
    }
    get functions() {
        return new $P(this.functionsUrl.href,{
            headers: this.headers,
            customFetch: this.fetch
        })
    }
    from(e) {
        return this.rest.from(e)
    }
    schema(e) {
        return this.rest.schema(e)
    }
    rpc(e, n={}, i={}) {
        return this.rest.rpc(e, n, i)
    }
    channel(e, n={
        config: {}
    }) {
        return this.realtime.channel(e, n)
    }
    getChannels() {
        return this.realtime.getChannels()
    }
    removeChannel(e) {
        return this.realtime.removeChannel(e)
    }
    removeAllChannels() {
        return this.realtime.removeAllChannels()
    }
    _getAccessToken() {
        var e, n;
        return JN(this, void 0, void 0, function*() {
            if (this.accessToken)
                return yield this.accessToken();
            const {data: i} = yield this.auth.getSession();
            return (n = (e = i.session) === null || e === void 0 ? void 0 : e.access_token) !== null && n !== void 0 ? n : this.supabaseKey
        })
    }
    _initSupabaseAuthClient({autoRefreshToken: e, persistSession: n, detectSessionInUrl: i, storage: r, userStorage: s, storageKey: o, flowType: a, lock: l, debug: c}, u, d) {
        const h = {
            Authorization: `Bearer ${this.supabaseKey}`,
            apikey: `${this.supabaseKey}`
        };
        return new ZN({
            url: this.authUrl.href,
            headers: Object.assign(Object.assign({}, h), u),
            storageKey: o,
            autoRefreshToken: e,
            persistSession: n,
            detectSessionInUrl: i,
            storage: r,
            userStorage: s,
            flowType: a,
            lock: l,
            debug: c,
            fetch: d,
            hasCustomAuthorizationHeader: Object.keys(this.headers).some(p => p.toLowerCase() === "authorization")
        })
    }
    _initRealtimeClient(e) {
        return new N2(this.realtimeUrl.href,Object.assign(Object.assign({}, e), {
            params: Object.assign({
                apikey: this.supabaseKey
            }, e == null ? void 0 : e.params)
        }))
    }
    _listenForAuthEvents() {
        return this.auth.onAuthStateChange( (n, i) => {
            this._handleTokenChanged(n, "CLIENT", i == null ? void 0 : i.access_token)
        }
        )
    }
    _handleTokenChanged(e, n, i) {
        (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== i ? this.changedAccessToken = i : e === "SIGNED_OUT" && (this.realtime.setAuth(),
        n == "STORAGE" && this.auth.signOut(),
        this.changedAccessToken = void 0)
    }
}
const Gb = (t, e, n) => new QN(t,e,n);
function eD() {
    if (typeof window < "u" || typeof process > "u")
        return !1;
    const t = process.version;
    if (t == null)
        return !1;
    const e = t.match(/^v(\d+)\./);
    return e ? parseInt(e[1], 10) <= 18 : !1
}
eD() && console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
const tD = Gb("https://ayesqktfjrdsdhilxest.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF5ZXNxa3RmanJkc2RoaWx4ZXN0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjExNDY2NzIsImV4cCI6MjA3NjcyMjY3Mn0.oaJhcCSgo38pLoHFWcvqQrrLUakCDXhsprosOUU20cE");
function nD({isOpen: t, onClose: e}) {
    const [n,i] = oe.useState({
        name: "",
        email: "",
        company: "",
        projectType: "Content Strategy",
        budget: "",
        timeline: "",
        description: ""
    })
      , [r,s] = oe.useState("idle");
    if (!t)
        return null;
    const o = async a => {
        a.preventDefault(),
        s("sending");
        try {
            const {error: l} = await tD.functions.invoke("send-contact-email", {
                body: {
                    type: "project",
                    name: n.name,
                    email: n.email,
                    company: n.company,
                    projectType: n.projectType,
                    budget: n.budget,
                    timeline: n.timeline,
                    description: n.description
                }
            });
            if (l)
                throw l;
            s("success"),
            setTimeout( () => {
                e(),
                i({
                    name: "",
                    email: "",
                    company: "",
                    projectType: "Content Strategy",
                    budget: "",
                    timeline: "",
                    description: ""
                }),
                s("idle")
            }
            , 2e3)
        } catch (l) {
            console.error("Error sending project request:", l),
            s("error")
        }
    }
    ;
    return m.jsx("div", {
        className: "fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4",
        children: m.jsxs("div", {
            className: "bg-slate-900 border border-white/10 rounded-2xl max-w-3xl w-full p-8 relative max-h-[90vh] overflow-y-auto",
            children: [m.jsx("button", {
                onClick: e,
                className: "absolute top-4 right-4 text-gray-400 hover:text-white transition-colors z-10",
                children: m.jsx(vl, {
                    className: "w-6 h-6"
                })
            }), m.jsx("h2", {
                className: "text-3xl font-bold text-white mb-2",
                children: "Start Your Project"
            }), m.jsx("p", {
                className: "text-gray-400 mb-6",
                children: "Tell me about your project and let's bring your vision to life."
            }), m.jsxs("form", {
                onSubmit: o,
                className: "space-y-5",
                children: [m.jsxs("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 gap-5",
                    children: [m.jsxs("div", {
                        children: [m.jsx("label", {
                            className: "block text-sm font-medium text-gray-300 mb-2",
                            children: "Name *"
                        }), m.jsx("input", {
                            type: "text",
                            required: !0,
                            value: n.name,
                            onChange: a => i({
                                ...n,
                                name: a.target.value
                            }),
                            className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-cyan-400 transition-colors",
                            placeholder: "Your full name"
                        })]
                    }), m.jsxs("div", {
                        children: [m.jsx("label", {
                            className: "block text-sm font-medium text-gray-300 mb-2",
                            children: "Email *"
                        }), m.jsx("input", {
                            type: "email",
                            required: !0,
                            value: n.email,
                            onChange: a => i({
                                ...n,
                                email: a.target.value
                            }),
                            className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-cyan-400 transition-colors",
                            placeholder: "your@email.com"
                        })]
                    })]
                }), m.jsxs("div", {
                    children: [m.jsx("label", {
                        className: "block text-sm font-medium text-gray-300 mb-2",
                        children: "Company/Organization"
                    }), m.jsx("input", {
                        type: "text",
                        value: n.company,
                        onChange: a => i({
                            ...n,
                            company: a.target.value
                        }),
                        className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-cyan-400 transition-colors",
                        placeholder: "Optional"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsx("label", {
                        className: "block text-sm font-medium text-gray-300 mb-2",
                        children: "Project Type *"
                    }), m.jsxs("select", {
                        required: !0,
                        value: n.projectType,
                        onChange: a => i({
                            ...n,
                            projectType: a.target.value
                        }),
                        className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-cyan-400 transition-colors cursor-pointer",
                        children: [m.jsx("option", {
                            value: "Content Strategy",
                            children: "Content Strategy"
                        }), m.jsx("option", {
                            value: "Mobile and Web App Development",
                            children: "Mobile and Web App Development"
                        }), m.jsx("option", {
                            value: "Video Production",
                            children: "Video Production"
                        }), m.jsx("option", {
                            value: "Sound Design",
                            children: "Sound Design"
                        }), m.jsx("option", {
                            value: "AI Automation",
                            children: "AI Automation"
                        }), m.jsx("option", {
                            value: "Social Media",
                            children: "Social Media"
                        }), m.jsx("option", {
                            value: "Generative AI Workflows",
                            children: "Generative AI Workflows"
                        }), m.jsx("option", {
                            value: "Prompt Engineering",
                            children: "Prompt Engineering"
                        }), m.jsx("option", {
                            value: "Graphic Design",
                            children: "Graphic Design"
                        }), m.jsx("option", {
                            value: "Web Development",
                            children: "Web Development"
                        })]
                    })]
                }), m.jsxs("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 gap-5",
                    children: [m.jsxs("div", {
                        children: [m.jsx("label", {
                            className: "block text-sm font-medium text-gray-300 mb-2",
                            children: "Budget Range"
                        }), m.jsxs("select", {
                            value: n.budget,
                            onChange: a => i({
                                ...n,
                                budget: a.target.value
                            }),
                            className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-cyan-400 transition-colors cursor-pointer",
                            children: [m.jsx("option", {
                                value: "",
                                children: "Select budget (optional)"
                            }), m.jsx("option", {
                                value: "Under $5K",
                                children: "Under $5,000"
                            }), m.jsx("option", {
                                value: "$5K - $10K",
                                children: "$5,000 - $10,000"
                            }), m.jsx("option", {
                                value: "$10K - $25K",
                                children: "$10,000 - $25,000"
                            }), m.jsx("option", {
                                value: "$25K - $50K",
                                children: "$25,000 - $50,000"
                            }), m.jsx("option", {
                                value: "$50K+",
                                children: "$50,000+"
                            }), m.jsx("option", {
                                value: "Not Sure",
                                children: "Not Sure Yet"
                            })]
                        })]
                    }), m.jsxs("div", {
                        children: [m.jsx("label", {
                            className: "block text-sm font-medium text-gray-300 mb-2",
                            children: "Timeline"
                        }), m.jsxs("select", {
                            value: n.timeline,
                            onChange: a => i({
                                ...n,
                                timeline: a.target.value
                            }),
                            className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-cyan-400 transition-colors cursor-pointer",
                            children: [m.jsx("option", {
                                value: "",
                                children: "Select timeline (optional)"
                            }), m.jsx("option", {
                                value: "ASAP",
                                children: "ASAP (1-2 weeks)"
                            }), m.jsx("option", {
                                value: "1-2 months",
                                children: "1-2 months"
                            }), m.jsx("option", {
                                value: "2-3 months",
                                children: "2-3 months"
                            }), m.jsx("option", {
                                value: "3-6 months",
                                children: "3-6 months"
                            }), m.jsx("option", {
                                value: "6+ months",
                                children: "6+ months"
                            }), m.jsx("option", {
                                value: "Flexible",
                                children: "Flexible"
                            })]
                        })]
                    })]
                }), m.jsxs("div", {
                    children: [m.jsx("label", {
                        className: "block text-sm font-medium text-gray-300 mb-2",
                        children: "Project Description *"
                    }), m.jsx("textarea", {
                        required: !0,
                        rows: 5,
                        value: n.description,
                        onChange: a => i({
                            ...n,
                            description: a.target.value
                        }),
                        className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-cyan-400 transition-colors resize-none",
                        placeholder: "Describe your project, goals, key features, target audience, and any specific requirements..."
                    })]
                }), m.jsx("button", {
                    type: "submit",
                    disabled: r === "sending",
                    className: "w-full bg-gradient-to-r from-cyan-500 to-blue-500 text-white font-bold py-4 rounded-full hover:from-cyan-400 hover:to-blue-400 transition-all disabled:opacity-50 shadow-lg hover:shadow-xl",
                    children: r === "sending" ? "Sending..." : r === "success" ? "Project Request Sent!" : "Submit Project Request"
                }), r === "error" && m.jsx("p", {
                    className: "text-red-400 text-sm text-center",
                    children: "Failed to send request. Please try again."
                })]
            })]
        })
    })
}
const iD = Gb("https://ayesqktfjrdsdhilxest.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF5ZXNxa3RmanJkc2RoaWx4ZXN0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjExNDY2NzIsImV4cCI6MjA3NjcyMjY3Mn0.oaJhcCSgo38pLoHFWcvqQrrLUakCDXhsprosOUU20cE");
function rD({isOpen: t, onClose: e}) {
    const [n,i] = oe.useState({
        name: "",
        email: "",
        company: "",
        topicsOfInterest: [],
        requestType: "Mentoring",
        message: ""
    })
      , [r,s] = oe.useState("idle");
    if (!t)
        return null;
    const o = async a => {
        a.preventDefault(),
        s("sending");
        try {
            const {error: l} = await iD.functions.invoke("send-contact-email", {
                body: {
                    type: "consultation",
                    name: n.name,
                    email: n.email,
                    company: n.company,
                    topicsOfInterest: n.topicsOfInterest,
                    requestType: n.requestType,
                    message: n.message
                }
            });
            if (l)
                throw l;
            s("success"),
            setTimeout( () => {
                e(),
                i({
                    name: "",
                    email: "",
                    company: "",
                    topicsOfInterest: [],
                    requestType: "Mentoring",
                    message: ""
                }),
                s("idle")
            }
            , 2e3)
        } catch (l) {
            console.error("Error sending consultation request:", l),
            s("error")
        }
    }
    ;
    return m.jsx("div", {
        className: "fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4",
        children: m.jsxs("div", {
            className: "bg-slate-900/80 backdrop-blur-xl border border-white/10 rounded-2xl max-w-2xl w-full p-8 relative max-h-[90vh] overflow-y-auto shadow-2xl",
            children: [m.jsx("button", {
                onClick: e,
                className: "absolute top-4 right-4 text-gray-400 hover:text-white transition-colors z-10",
                children: m.jsx(vl, {
                    className: "w-6 h-6"
                })
            }), m.jsx("h2", {
                className: "text-3xl font-bold text-white mb-2",
                children: "Book a Consultation"
            }), m.jsx("p", {
                className: "text-gray-400 mb-6",
                children: "Let's discuss how I can help you learn, grow, or train your team."
            }), m.jsxs("form", {
                onSubmit: o,
                className: "space-y-5",
                children: [m.jsxs("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 gap-5",
                    children: [m.jsxs("div", {
                        children: [m.jsx("label", {
                            className: "block text-sm font-medium text-gray-300 mb-2",
                            children: "Name *"
                        }), m.jsx("input", {
                            type: "text",
                            required: !0,
                            value: n.name,
                            onChange: a => i({
                                ...n,
                                name: a.target.value
                            }),
                            className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-teal-400 transition-colors",
                            placeholder: "Your full name"
                        })]
                    }), m.jsxs("div", {
                        children: [m.jsx("label", {
                            className: "block text-sm font-medium text-gray-300 mb-2",
                            children: "Email *"
                        }), m.jsx("input", {
                            type: "email",
                            required: !0,
                            value: n.email,
                            onChange: a => i({
                                ...n,
                                email: a.target.value
                            }),
                            className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-teal-400 transition-colors",
                            placeholder: "your@email.com"
                        })]
                    })]
                }), m.jsxs("div", {
                    children: [m.jsx("label", {
                        className: "block text-sm font-medium text-gray-300 mb-2",
                        children: "Company/Organization"
                    }), m.jsx("input", {
                        type: "text",
                        value: n.company,
                        onChange: a => i({
                            ...n,
                            company: a.target.value
                        }),
                        className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-teal-400 transition-colors",
                        placeholder: "Optional"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsx("label", {
                        className: "block text-sm font-medium text-gray-300 mb-3",
                        children: "Topics of Interest *"
                    }), m.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-2 gap-3",
                        children: ["Content Strategy", "Mobile and Web App Development", "Video Production", "Sound Design", "AI Automation", "Social Media", "Generative AI Workflows", "Prompt Engineering", "Graphic Design", "Web Development"].map(a => m.jsxs("label", {
                            className: "flex items-center space-x-3 cursor-pointer group",
                            children: [m.jsx("input", {
                                type: "checkbox",
                                checked: n.topicsOfInterest.includes(a),
                                onChange: l => {
                                    l.target.checked ? i({
                                        ...n,
                                        topicsOfInterest: [...n.topicsOfInterest, a]
                                    }) : i({
                                        ...n,
                                        topicsOfInterest: n.topicsOfInterest.filter(c => c !== a)
                                    })
                                }
                                ,
                                className: "w-4 h-4 rounded border-white/10 bg-slate-800/50 text-teal-500 focus:ring-teal-400 focus:ring-offset-0 cursor-pointer"
                            }), m.jsx("span", {
                                className: "text-gray-300 group-hover:text-white transition-colors text-sm",
                                children: a
                            })]
                        }, a))
                    })]
                }), m.jsxs("div", {
                    children: [m.jsx("label", {
                        className: "block text-sm font-medium text-gray-300 mb-2",
                        children: "Engagement Type *"
                    }), m.jsxs("select", {
                        required: !0,
                        value: n.requestType,
                        onChange: a => i({
                            ...n,
                            requestType: a.target.value
                        }),
                        className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-teal-400 transition-colors cursor-pointer",
                        children: [m.jsx("option", {
                            value: "Mentoring",
                            children: "1-on-1 Mentoring"
                        }), m.jsx("option", {
                            value: "Corporate Training",
                            children: "Corporate Training Workshop"
                        }), m.jsx("option", {
                            value: "Team Workshop",
                            children: "Team Workshop"
                        }), m.jsx("option", {
                            value: "Speaking Engagement",
                            children: "Speaking Engagement"
                        }), m.jsx("option", {
                            value: "Course Development",
                            children: "Course Development"
                        }), m.jsx("option", {
                            value: "Technical Consulting",
                            children: "Technical Consulting"
                        }), m.jsx("option", {
                            value: "Other",
                            children: "Other"
                        })]
                    })]
                }), m.jsxs("div", {
                    children: [m.jsx("label", {
                        className: "block text-sm font-medium text-gray-300 mb-2",
                        children: "Tell me more about your needs *"
                    }), m.jsx("textarea", {
                        required: !0,
                        rows: 5,
                        value: n.message,
                        onChange: a => i({
                            ...n,
                            message: a.target.value
                        }),
                        className: "w-full bg-slate-800/50 border border-white/10 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-teal-400 transition-colors resize-none",
                        placeholder: "What would you like to learn? What are your goals? Any specific topics or challenges?"
                    })]
                }), m.jsx("button", {
                    type: "submit",
                    disabled: r === "sending",
                    className: "w-full bg-gradient-to-r from-teal-500 to-emerald-600 text-white font-bold py-4 rounded-full hover:from-teal-400 hover:to-emerald-500 transition-all disabled:opacity-50 shadow-lg hover:shadow-xl",
                    children: r === "sending" ? "Sending..." : r === "success" ? "Request Sent!" : "Submit Request"
                }), r === "error" && m.jsx("p", {
                    className: "text-red-400 text-sm text-center",
                    children: "Failed to send request. Please try again."
                })]
            })]
        })
    })
}
function sD({isOpen: t, onClose: e, onContactClick: n, onBookingClick: i}) {
    if (!t)
        return null;
    const r = () => {
        e(),
        n()
    }
      , s = () => {
        e(),
        i()
    }
    ;
    return m.jsx("div", {
        className: "fixed inset-0 bg-slate-950/95 backdrop-blur-xl z-50 lg:hidden",
        children: m.jsxs("div", {
            className: "flex flex-col h-full p-6",
            children: [m.jsx("div", {
                className: "flex justify-end mb-8",
                children: m.jsx("button", {
                    onClick: e,
                    className: "text-white hover:text-cyan-400 transition-colors",
                    children: m.jsx(vl, {
                        className: "w-8 h-8"
                    })
                })
            }), m.jsxs("nav", {
                className: "flex flex-col gap-6",
                children: [m.jsx("a", {
                    href: "#services",
                    onClick: e,
                    className: "text-2xl font-semibold text-white hover:text-cyan-400 transition-colors",
                    children: "Services"
                }), m.jsx("a", {
                    href: "#portfolio",
                    onClick: e,
                    className: "text-2xl font-semibold text-white hover:text-cyan-400 transition-colors",
                    children: "Portfolio"
                }), m.jsx("a", {
                    href: "#about",
                    onClick: e,
                    className: "text-2xl font-semibold text-white hover:text-cyan-400 transition-colors",
                    children: "About"
                }), m.jsx("a", {
                    href: "#faq",
                    onClick: e,
                    className: "text-2xl font-semibold text-white hover:text-cyan-400 transition-colors",
                    children: "FAQ"
                }), m.jsx("button", {
                    onClick: r,
                    className: "text-left text-2xl font-semibold text-white hover:text-cyan-400 transition-colors",
                    children: "Contact"
                }), m.jsx("button", {
                    onClick: s,
                    className: "mt-4 bg-gradient-to-r from-cyan-500 to-blue-500 text-white px-8 py-4 rounded-full font-semibold text-lg hover:from-cyan-400 hover:to-blue-400 transition-all",
                    children: "Book a Call"
                })]
            })]
        })
    })
}
function oD() {
    const [t,e] = oe.useState(0);
    return oe.useEffect( () => {
        const n = () => {
            const i = document.documentElement.scrollHeight - window.innerHeight
              , r = window.scrollY / i * 100;
            e(r)
        }
        ;
        return window.addEventListener("scroll", n),
        () => window.removeEventListener("scroll", n)
    }
    , []),
    m.jsx("div", {
        className: "fixed top-0 left-0 w-full h-1 bg-slate-900/50 backdrop-blur-sm z-50",
        children: m.jsx("div", {
            className: "h-full bg-gradient-to-r from-cyan-500 to-blue-500 transition-all duration-150",
            style: {
                width: `${t}%`
            }
        })
    })
}
function aD() {
    const [t,e] = oe.useState(!1);
    oe.useEffect( () => {
        const i = () => {
            e(window.scrollY > 500)
        }
        ;
        return window.addEventListener("scroll", i),
        () => window.removeEventListener("scroll", i)
    }
    , []);
    const n = () => {
        window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }
    ;
    return t ? m.jsx("button", {
        onClick: n,
        className: "fixed bottom-44 right-8 md:bottom-44 md:right-8 bottom-8 right-24 bg-gradient-to-r from-cyan-500 to-blue-500 text-white p-4 rounded-full shadow-lg hover:from-cyan-400 hover:to-blue-400 transition-all z-40 group",
        children: m.jsx(r1, {
            className: "w-6 h-6 group-hover:-translate-y-1 transition-transform"
        })
    }) : null
}
function lD({settings: t}) {
    return oe.useEffect( () => {
        if (!t.enabled)
            return;
        const e = []
          , n = (a, l) => {
            const c = Math.floor(3 + Math.random() * 4);
            for (let u = 0; u < c; u++) {
                const d = document.createElement("div");
                d.className = "sparkle";
                const h = Math.PI * 2 * u / c + Math.random() * .5
                  , p = 15 + Math.random() * 35
                  , v = Math.cos(h) * p
                  , x = Math.sin(h) * p;
                d.style.left = `${a}px`,
                d.style.top = `${l}px`,
                d.style.setProperty("--offset-x", `${v}px`),
                d.style.setProperty("--offset-y", `${x}px`),
                d.style.width = `${t.particleSize}px`,
                d.style.height = `${t.particleSize}px`,
                d.style.filter = `brightness(${t.brightness}%) hue-rotate(${t.hueShift}deg) blur(${t.blur}px)`,
                d.style.opacity = String(t.opacity),
                d.style.animationDuration = `${.6 + Math.random() * .4}s`,
                document.body.appendChild(d),
                e.push(d),
                setTimeout( () => {
                    d.remove(),
                    e.splice(e.indexOf(d), 1)
                }
                , 1e3 / t.speed)
            }
        }
        ;
        let i = 0;
        const r = 30
          , s = a => {
            const l = Date.now();
            l - i >= r && (n(a.clientX, a.clientY),
            i = l)
        }
          , o = a => {
            const l = Date.now();
            if (l - i >= r && a.touches.length > 0) {
                const c = a.touches[0];
                n(c.clientX, c.clientY),
                i = l
            }
        }
        ;
        return document.addEventListener("mousemove", s),
        document.addEventListener("touchmove", o, {
            passive: !0
        }),
        () => {
            document.removeEventListener("mousemove", s),
            document.removeEventListener("touchmove", o),
            e.forEach(a => a.remove())
        }
    }
    , [t]),
    null
}
function cD({onSettingsChange: t}) {
    const [e,n] = oe.useState(!1)
      , i = oe.useRef(null)
      , [r,s] = oe.useState({
        x: 50,
        y: 50
    })
      , [o,a] = oe.useState({
        enabled: !1,
        particleSize: 2,
        speed: 1.5,
        opacity: 1,
        brightness: 70,
        hueShift: 180,
        blur: 0
    });
    oe.useEffect( () => {
        const c = d => {
            i.current && !i.current.contains(d.target) && n(!1)
        }
          , u = d => {
            if (i.current) {
                const h = i.current.getBoundingClientRect();
                s({
                    x: (d.clientX - h.left) / h.width * 100,
                    y: (d.clientY - h.top) / h.height * 100
                })
            }
        }
        ;
        return e && (document.addEventListener("mousedown", c),
        document.addEventListener("mousemove", u)),
        () => {
            document.removeEventListener("mousedown", c),
            document.removeEventListener("mousemove", u)
        }
    }
    , [e]);
    const l = (c, u) => {
        const d = {
            ...o,
            [c]: u
        };
        a(d),
        t(d)
    }
    ;
    return m.jsxs("div", {
        className: "fixed bottom-24 right-8 md:bottom-24 md:right-8 z-40",
        ref: i,
        children: [m.jsx("button", {
            onClick: () => n(!e),
            className: "bg-gradient-to-r from-purple-500 to-pink-500 text-white p-4 rounded-full shadow-lg hover:from-purple-400 hover:to-pink-400 transition-all",
            children: m.jsx(Su, {
                className: "w-6 h-6"
            })
        }), e && m.jsxs("div", {
            className: "absolute bottom-0 right-20 md:right-20 right-0 backdrop-blur-md bg-slate-900/60 border rounded-2xl p-6 w-80 max-w-[calc(100vw-2rem)] transition-all duration-500 hover:shadow-[0_0_25px_rgba(255,255,255,0.2)]",
            style: {
                borderColor: `hsl(${o.hueShift}, 100%, 70%)`,
                boxShadow: `0 0 15px hsl(${o.hueShift}, 100%, 70%, 0.35)`,
                backgroundImage: `radial-gradient(circle at ${r.x}% ${r.y}%, rgba(255,255,255,0.08), transparent 60%)`
            },
            children: [m.jsxs("div", {
                className: "flex items-center justify-between mb-4",
                children: [m.jsx("h3", {
                    className: "text-white font-bold",
                    children: "Sparkle Cursor"
                }), m.jsx("button", {
                    onClick: () => n(!1),
                    className: "text-gray-400 hover:text-white transition-colors",
                    children: m.jsx(vl, {
                        className: "w-5 h-5"
                    })
                })]
            }), m.jsxs("div", {
                className: "space-y-4",
                children: [m.jsx("div", {
                    className: "bg-gradient-to-br from-purple-500/10 to-pink-500/10 border border-purple-400/30 rounded-xl p-4 mb-2",
                    children: m.jsxs("div", {
                        className: "flex items-start justify-between",
                        children: [m.jsxs("div", {
                            className: "flex-1",
                            children: [m.jsxs("div", {
                                className: "flex items-center gap-2 mb-1",
                                children: [m.jsx(Su, {
                                    className: "w-4 h-4 text-purple-400"
                                }), m.jsx("span", {
                                    className: "text-white font-semibold text-sm",
                                    children: "Sparkle Effect"
                                })]
                            }), m.jsx("p", {
                                className: "text-xs text-gray-400",
                                children: "Show sparkles following your cursor"
                            })]
                        }), m.jsx("button", {
                            onClick: () => l("enabled", !o.enabled),
                            className: `relative inline-flex h-7 w-14 items-center rounded-full transition-all duration-300 ${o.enabled ? "bg-gradient-to-r from-purple-500 to-pink-500 shadow-[0_0_15px_rgba(168,85,247,0.5)]" : "bg-gray-600"}`,
                            children: m.jsx("span", {
                                className: `inline-block h-5 w-5 transform rounded-full bg-white shadow-lg transition-transform duration-300 ${o.enabled ? "translate-x-8" : "translate-x-1"}`
                            })
                        })]
                    })
                }), m.jsxs("div", {
                    className: "pt-2 border-t border-white/10",
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Size: ", o.particleSize, "px"]
                    }), m.jsx("input", {
                        type: "range",
                        min: "1",
                        max: "10",
                        step: "0.5",
                        value: o.particleSize,
                        onChange: c => l("particleSize", parseFloat(c.target.value)),
                        className: "w-full"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Speed: ", o.speed, "x"]
                    }), m.jsx("input", {
                        type: "range",
                        min: "0.5",
                        max: "3",
                        step: "0.1",
                        value: o.speed,
                        onChange: c => l("speed", parseFloat(c.target.value)),
                        className: "w-full"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Opacity: ", o.opacity]
                    }), m.jsx("input", {
                        type: "range",
                        min: "0.1",
                        max: "1",
                        step: "0.1",
                        value: o.opacity,
                        onChange: c => l("opacity", parseFloat(c.target.value)),
                        className: "w-full"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Brightness: ", o.brightness, "%"]
                    }), m.jsx("input", {
                        type: "range",
                        min: "10",
                        max: "200",
                        value: o.brightness,
                        onChange: c => l("brightness", parseInt(c.target.value)),
                        className: "w-full"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Hue Shift: ", o.hueShift, ""]
                    }), m.jsx("input", {
                        type: "range",
                        min: "0",
                        max: "360",
                        value: o.hueShift,
                        onChange: c => l("hueShift", parseInt(c.target.value)),
                        className: "w-full"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Particle Blur: ", o.blur, "px"]
                    }), m.jsx("input", {
                        type: "range",
                        min: "0",
                        max: "10",
                        step: "0.5",
                        value: o.blur,
                        onChange: c => l("blur", parseFloat(c.target.value)),
                        className: "w-full"
                    })]
                })]
            })]
        })]
    })
}
const Wc = {
    brightness: 38,
    speed: 50,
    size: 50,
    clickReactive: !1,
    blur: 80,
    color: "#22d3ee",
    zoom: 89
};
function uD({onSettingsChange: t}) {
    const [e,n] = oe.useState(!1)
      , i = oe.useRef(null)
      , [r,s] = oe.useState({
        x: 50,
        y: 50
    })
      , [o,a] = oe.useState(Wc);
    oe.useEffect( () => {
        const u = h => {
            i.current && !i.current.contains(h.target) && n(!1)
        }
          , d = h => {
            if (i.current) {
                const p = i.current.getBoundingClientRect();
                s({
                    x: (h.clientX - p.left) / p.width * 100,
                    y: (h.clientY - p.top) / p.height * 100
                })
            }
        }
        ;
        return e && (document.addEventListener("mousedown", u),
        document.addEventListener("mousemove", d)),
        () => {
            document.removeEventListener("mousedown", u),
            document.removeEventListener("mousemove", d)
        }
    }
    , [e]);
    const l = (u, d) => {
        const h = {
            ...o,
            [u]: d
        };
        a(h),
        t(h)
    }
      , c = () => {
        a(Wc),
        t(Wc)
    }
    ;
    return m.jsxs("div", {
        className: "fixed bottom-8 right-8 md:bottom-8 md:right-8 z-40",
        ref: i,
        children: [m.jsx("button", {
            onClick: () => n(!e),
            className: "bg-gradient-to-r from-cyan-500 to-blue-500 text-white p-4 rounded-full shadow-lg hover:from-cyan-400 hover:to-blue-400 transition-all",
            children: m.jsx(a1, {
                className: "w-6 h-6"
            })
        }), e && m.jsxs("div", {
            className: "absolute bottom-0 right-20 md:right-20 right-0 backdrop-blur-md bg-slate-900/60 border rounded-2xl p-6 w-80 max-w-[calc(100vw-2rem)] transition-all duration-500 hover:shadow-[0_0_25px_rgba(255,255,255,0.2)]",
            style: {
                borderColor: o.color,
                boxShadow: `0 0 15px ${o.color}55`,
                backgroundImage: `radial-gradient(circle at ${r.x}% ${r.y}%, rgba(255,255,255,0.08), transparent 60%)`
            },
            children: [m.jsxs("div", {
                className: "flex items-center justify-between mb-4",
                children: [m.jsx("h3", {
                    className: "text-white font-bold",
                    children: "Particle Settings"
                }), m.jsx("button", {
                    onClick: () => n(!1),
                    className: "text-gray-400 hover:text-white transition-colors",
                    children: m.jsx(vl, {
                        className: "w-5 h-5"
                    })
                })]
            }), m.jsxs("div", {
                className: "space-y-4",
                children: [m.jsxs("div", {
                    className: "bg-gradient-to-br from-cyan-500/10 to-blue-500/10 border border-cyan-400/30 rounded-xl p-4 mb-2",
                    children: [m.jsxs("div", {
                        className: "flex items-start justify-between mb-2",
                        children: [m.jsxs("div", {
                            className: "flex-1",
                            children: [m.jsxs("div", {
                                className: "flex items-center gap-2 mb-1",
                                children: [m.jsx(o1, {
                                    className: "w-4 h-4 text-cyan-400"
                                }), m.jsx("span", {
                                    className: "text-white font-semibold text-sm",
                                    children: "Cursor Interactive"
                                })]
                            }), m.jsx("p", {
                                className: "text-xs text-gray-400",
                                children: "Particles follow your cursor position"
                            })]
                        }), m.jsx("button", {
                            onClick: () => l("clickReactive", !o.clickReactive),
                            className: `relative inline-flex h-7 w-14 items-center rounded-full transition-all duration-300 ${o.clickReactive ? "bg-gradient-to-r from-cyan-500 to-blue-500 shadow-[0_0_15px_rgba(34,211,238,0.5)]" : "bg-gray-600"}`,
                            children: m.jsx("span", {
                                className: `inline-block h-5 w-5 transform rounded-full bg-white shadow-lg transition-transform duration-300 ${o.clickReactive ? "translate-x-8" : "translate-x-1"}`
                            })
                        })]
                    }), o.clickReactive && m.jsxs("div", {
                        className: "mt-4 pt-4 border-t border-cyan-400/20",
                        children: [m.jsxs("label", {
                            className: "text-cyan-300 text-xs block mb-2 flex items-center gap-2",
                            children: [m.jsx(rv, {
                                className: "w-3.5 h-3.5"
                            }), "Zoom Level: ", o.zoom, "%"]
                        }), m.jsxs("div", {
                            className: "flex items-center gap-3",
                            children: [m.jsx(c1, {
                                className: "w-4 h-4 text-cyan-400"
                            }), m.jsx("input", {
                                type: "range",
                                min: "50",
                                max: "200",
                                value: o.zoom,
                                onChange: u => l("zoom", parseInt(u.target.value)),
                                className: "flex-1"
                            }), m.jsx(rv, {
                                className: "w-4 h-4 text-cyan-400"
                            })]
                        })]
                    })]
                }), m.jsxs("div", {
                    className: "pt-2 border-t border-white/10",
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Brightness: ", o.brightness, "%"]
                    }), m.jsx("input", {
                        type: "range",
                        min: "0",
                        max: "100",
                        value: o.brightness,
                        onChange: u => l("brightness", parseInt(u.target.value)),
                        className: "w-full"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Speed: ", o.speed, "%"]
                    }), m.jsx("input", {
                        type: "range",
                        min: "0",
                        max: "100",
                        value: o.speed,
                        onChange: u => l("speed", parseInt(u.target.value)),
                        className: "w-full"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Size: ", o.size, "%"]
                    }), m.jsx("input", {
                        type: "range",
                        min: "10",
                        max: "200",
                        value: o.size,
                        onChange: u => l("size", parseInt(u.target.value)),
                        className: "w-full"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsxs("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: ["Blur: ", o.blur, "%"]
                    }), m.jsx("input", {
                        type: "range",
                        min: "0",
                        max: "100",
                        value: o.blur,
                        onChange: u => l("blur", parseInt(u.target.value)),
                        className: "w-full"
                    })]
                }), m.jsxs("div", {
                    children: [m.jsx("label", {
                        className: "text-gray-300 text-sm block mb-2",
                        children: "Color"
                    }), m.jsx("input", {
                        type: "color",
                        value: o.color,
                        onChange: u => l("color", u.target.value),
                        className: "w-full h-10 rounded cursor-pointer"
                    })]
                }), m.jsx("button", {
                    onClick: c,
                    className: "w-full mt-4 bg-gradient-to-r from-cyan-500 to-blue-500 text-white font-semibold py-2 px-4 rounded-lg hover:from-cyan-400 hover:to-blue-400 transition-all",
                    children: "Reset to Defaults"
                })]
            })]
        })]
    })
}
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Pg = "180"
  , dD = 0
  , k_ = 1
  , hD = 2
  , Wb = 1
  , fD = 2
  , Di = 3
  , Lr = 0
  , Sn = 1
  , Ui = 2
  , Ar = 0
  , bo = 1
  , cp = 2
  , U_ = 3
  , O_ = 4
  , pD = 5
  , rs = 100
  , mD = 101
  , gD = 102
  , vD = 103
  , _D = 104
  , yD = 200
  , xD = 201
  , SD = 202
  , wD = 203
  , up = 204
  , dp = 205
  , bD = 206
  , ED = 207
  , TD = 208
  , MD = 209
  , AD = 210
  , CD = 211
  , RD = 212
  , PD = 213
  , ND = 214
  , hp = 0
  , fp = 1
  , pp = 2
  , ko = 3
  , mp = 4
  , gp = 5
  , vp = 6
  , _p = 7
  , $b = 0
  , DD = 1
  , LD = 2
  , Cr = 0
  , ID = 1
  , kD = 2
  , UD = 3
  , OD = 4
  , FD = 5
  , BD = 6
  , zD = 7
  , Xb = 300
  , Uo = 301
  , Oo = 302
  , yp = 303
  , xp = 304
  , id = 306
  , Sp = 1e3
  , ds = 1001
  , wp = 1002
  , ui = 1003
  , VD = 1004
  , sc = 1005
  , _i = 1006
  , ah = 1007
  , hs = 1008
  , Yi = 1009
  , qb = 1010
  , Kb = 1011
  , al = 1012
  , Ng = 1013
  , ws = 1014
  , Bi = 1015
  , Tl = 1016
  , Dg = 1017
  , Lg = 1018
  , ll = 1020
  , Yb = 35902
  , Zb = 35899
  , Jb = 1021
  , Qb = 1022
  , ai = 1023
  , cl = 1026
  , ul = 1027
  , eE = 1028
  , Ig = 1029
  , tE = 1030
  , kg = 1031
  , Ug = 1033
  , $c = 33776
  , Xc = 33777
  , qc = 33778
  , Kc = 33779
  , bp = 35840
  , Ep = 35841
  , Tp = 35842
  , Mp = 35843
  , Ap = 36196
  , Cp = 37492
  , Rp = 37496
  , Pp = 37808
  , Np = 37809
  , Dp = 37810
  , Lp = 37811
  , Ip = 37812
  , kp = 37813
  , Up = 37814
  , Op = 37815
  , Fp = 37816
  , Bp = 37817
  , zp = 37818
  , Vp = 37819
  , jp = 37820
  , Hp = 37821
  , Gp = 36492
  , Wp = 36494
  , $p = 36495
  , Xp = 36283
  , qp = 36284
  , Kp = 36285
  , Yp = 36286
  , jD = 3200
  , HD = 3201
  , GD = 0
  , WD = 1
  , gr = ""
  , Bn = "srgb"
  , Fo = "srgb-linear"
  , Pu = "linear"
  , rt = "srgb"
  , ks = 7680
  , F_ = 519
  , $D = 512
  , XD = 513
  , qD = 514
  , nE = 515
  , KD = 516
  , YD = 517
  , ZD = 518
  , JD = 519
  , B_ = 35044
  , z_ = "300 es"
  , yi = 2e3
  , Nu = 2001;
class qo {
    addEventListener(e, n) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(n) === -1 && i[e].push(n)
    }
    hasEventListener(e, n) {
        const i = this._listeners;
        return i === void 0 ? !1 : i[e] !== void 0 && i[e].indexOf(n) !== -1
    }
    removeEventListener(e, n) {
        const i = this._listeners;
        if (i === void 0)
            return;
        const r = i[e];
        if (r !== void 0) {
            const s = r.indexOf(n);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        const n = this._listeners;
        if (n === void 0)
            return;
        const i = n[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const Jt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
  , lh = Math.PI / 180
  , Zp = 180 / Math.PI;
function Ml() {
    const t = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (Jt[t & 255] + Jt[t >> 8 & 255] + Jt[t >> 16 & 255] + Jt[t >> 24 & 255] + "-" + Jt[e & 255] + Jt[e >> 8 & 255] + "-" + Jt[e >> 16 & 15 | 64] + Jt[e >> 24 & 255] + "-" + Jt[n & 63 | 128] + Jt[n >> 8 & 255] + "-" + Jt[n >> 16 & 255] + Jt[n >> 24 & 255] + Jt[i & 255] + Jt[i >> 8 & 255] + Jt[i >> 16 & 255] + Jt[i >> 24 & 255]).toLowerCase()
}
function Xe(t, e, n) {
    return Math.max(e, Math.min(n, t))
}
function QD(t, e) {
    return (t % e + e) % e
}
function ch(t, e, n) {
    return (1 - n) * t + n * e
}
function la(t, e) {
    switch (e.constructor) {
    case Float32Array:
        return t;
    case Uint32Array:
        return t / 4294967295;
    case Uint16Array:
        return t / 65535;
    case Uint8Array:
        return t / 255;
    case Int32Array:
        return Math.max(t / 2147483647, -1);
    case Int16Array:
        return Math.max(t / 32767, -1);
    case Int8Array:
        return Math.max(t / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function fn(t, e) {
    switch (e.constructor) {
    case Float32Array:
        return t;
    case Uint32Array:
        return Math.round(t * 4294967295);
    case Uint16Array:
        return Math.round(t * 65535);
    case Uint8Array:
        return Math.round(t * 255);
    case Int32Array:
        return Math.round(t * 2147483647);
    case Int16Array:
        return Math.round(t * 32767);
    case Int8Array:
        return Math.round(t * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
class st {
    constructor(e=0, n=0) {
        st.prototype.isVector2 = !0,
        this.x = e,
        this.y = n
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, n) {
        return this.x = e,
        this.y = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, n) {
        switch (e) {
        case 0:
            this.x = n;
            break;
        case 1:
            this.y = n;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, n) {
        return this.x = e.x + n.x,
        this.y = e.y + n.y,
        this
    }
    addScaledVector(e, n) {
        return this.x += e.x * n,
        this.y += e.y * n,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, n) {
        return this.x = e.x - n.x,
        this.y = e.y - n.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const n = this.x
          , i = this.y
          , r = e.elements;
        return this.x = r[0] * n + r[3] * i + r[6],
        this.y = r[1] * n + r[4] * i + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, n) {
        return this.x = Xe(this.x, e.x, n.x),
        this.y = Xe(this.y, e.y, n.y),
        this
    }
    clampScalar(e, n) {
        return this.x = Xe(this.x, e, n),
        this.y = Xe(this.y, e, n),
        this
    }
    clampLength(e, n) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Xe(i, e, n))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const n = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (n === 0)
            return Math.PI / 2;
        const i = this.dot(e) / n;
        return Math.acos(Xe(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const n = this.x - e.x
          , i = this.y - e.y;
        return n * n + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, n) {
        return this.x += (e.x - this.x) * n,
        this.y += (e.y - this.y) * n,
        this
    }
    lerpVectors(e, n, i) {
        return this.x = e.x + (n.x - e.x) * i,
        this.y = e.y + (n.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, n=0) {
        return this.x = e[n],
        this.y = e[n + 1],
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this.x,
        e[n + 1] = this.y,
        e
    }
    fromBufferAttribute(e, n) {
        return this.x = e.getX(n),
        this.y = e.getY(n),
        this
    }
    rotateAround(e, n) {
        const i = Math.cos(n)
          , r = Math.sin(n)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * i - o * r + e.x,
        this.y = s * r + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Al {
    constructor(e=0, n=0, i=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = n,
        this._z = i,
        this._w = r
    }
    static slerpFlat(e, n, i, r, s, o, a) {
        let l = i[r + 0]
          , c = i[r + 1]
          , u = i[r + 2]
          , d = i[r + 3];
        const h = s[o + 0]
          , p = s[o + 1]
          , v = s[o + 2]
          , x = s[o + 3];
        if (a === 0) {
            e[n + 0] = l,
            e[n + 1] = c,
            e[n + 2] = u,
            e[n + 3] = d;
            return
        }
        if (a === 1) {
            e[n + 0] = h,
            e[n + 1] = p,
            e[n + 2] = v,
            e[n + 3] = x;
            return
        }
        if (d !== x || l !== h || c !== p || u !== v) {
            let g = 1 - a;
            const f = l * h + c * p + u * v + d * x
              , y = f >= 0 ? 1 : -1
              , _ = 1 - f * f;
            if (_ > Number.EPSILON) {
                const T = Math.sqrt(_)
                  , A = Math.atan2(T, f * y);
                g = Math.sin(g * A) / T,
                a = Math.sin(a * A) / T
            }
            const S = a * y;
            if (l = l * g + h * S,
            c = c * g + p * S,
            u = u * g + v * S,
            d = d * g + x * S,
            g === 1 - a) {
                const T = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
                l *= T,
                c *= T,
                u *= T,
                d *= T
            }
        }
        e[n] = l,
        e[n + 1] = c,
        e[n + 2] = u,
        e[n + 3] = d
    }
    static multiplyQuaternionsFlat(e, n, i, r, s, o) {
        const a = i[r]
          , l = i[r + 1]
          , c = i[r + 2]
          , u = i[r + 3]
          , d = s[o]
          , h = s[o + 1]
          , p = s[o + 2]
          , v = s[o + 3];
        return e[n] = a * v + u * d + l * p - c * h,
        e[n + 1] = l * v + u * h + c * d - a * p,
        e[n + 2] = c * v + u * p + a * h - l * d,
        e[n + 3] = u * v - a * d - l * h - c * p,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, n, i, r) {
        return this._x = e,
        this._y = n,
        this._z = i,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, n=!0) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(i / 2)
          , u = a(r / 2)
          , d = a(s / 2)
          , h = l(i / 2)
          , p = l(r / 2)
          , v = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = h * u * d + c * p * v,
            this._y = c * p * d - h * u * v,
            this._z = c * u * v + h * p * d,
            this._w = c * u * d - h * p * v;
            break;
        case "YXZ":
            this._x = h * u * d + c * p * v,
            this._y = c * p * d - h * u * v,
            this._z = c * u * v - h * p * d,
            this._w = c * u * d + h * p * v;
            break;
        case "ZXY":
            this._x = h * u * d - c * p * v,
            this._y = c * p * d + h * u * v,
            this._z = c * u * v + h * p * d,
            this._w = c * u * d - h * p * v;
            break;
        case "ZYX":
            this._x = h * u * d - c * p * v,
            this._y = c * p * d + h * u * v,
            this._z = c * u * v - h * p * d,
            this._w = c * u * d + h * p * v;
            break;
        case "YZX":
            this._x = h * u * d + c * p * v,
            this._y = c * p * d + h * u * v,
            this._z = c * u * v - h * p * d,
            this._w = c * u * d - h * p * v;
            break;
        case "XZY":
            this._x = h * u * d - c * p * v,
            this._y = c * p * d - h * u * v,
            this._z = c * u * v + h * p * d,
            this._w = c * u * d + h * p * v;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return n === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, n) {
        const i = n / 2
          , r = Math.sin(i);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const n = e.elements
          , i = n[0]
          , r = n[4]
          , s = n[8]
          , o = n[1]
          , a = n[5]
          , l = n[9]
          , c = n[2]
          , u = n[6]
          , d = n[10]
          , h = i + a + d;
        if (h > 0) {
            const p = .5 / Math.sqrt(h + 1);
            this._w = .25 / p,
            this._x = (u - l) * p,
            this._y = (s - c) * p,
            this._z = (o - r) * p
        } else if (i > a && i > d) {
            const p = 2 * Math.sqrt(1 + i - a - d);
            this._w = (u - l) / p,
            this._x = .25 * p,
            this._y = (r + o) / p,
            this._z = (s + c) / p
        } else if (a > d) {
            const p = 2 * Math.sqrt(1 + a - i - d);
            this._w = (s - c) / p,
            this._x = (r + o) / p,
            this._y = .25 * p,
            this._z = (l + u) / p
        } else {
            const p = 2 * Math.sqrt(1 + d - i - a);
            this._w = (o - r) / p,
            this._x = (s + c) / p,
            this._y = (l + u) / p,
            this._z = .25 * p
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, n) {
        let i = e.dot(n) + 1;
        return i < 1e-8 ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * n.z - e.z * n.y,
        this._y = e.z * n.x - e.x * n.z,
        this._z = e.x * n.y - e.y * n.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(Xe(this.dot(e), -1, 1)))
    }
    rotateTowards(e, n) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const r = Math.min(1, n / i);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, n) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , a = n._x
          , l = n._y
          , c = n._z
          , u = n._w;
        return this._x = i * u + o * a + r * c - s * l,
        this._y = r * u + o * l + s * a - i * c,
        this._z = s * u + o * c + i * l - r * a,
        this._w = o * u - i * a - r * l - s * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, n) {
        if (n === 0)
            return this;
        if (n === 1)
            return this.copy(e);
        const i = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = r,
            this._z = s,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const p = 1 - n;
            return this._w = p * o + n * this._w,
            this._x = p * i + n * this._x,
            this._y = p * r + n * this._y,
            this._z = p * s + n * this._z,
            this.normalize(),
            this
        }
        const c = Math.sqrt(l)
          , u = Math.atan2(c, a)
          , d = Math.sin((1 - n) * u) / c
          , h = Math.sin(n * u) / c;
        return this._w = o * d + this._w * h,
        this._x = i * d + this._x * h,
        this._y = r * d + this._y * h,
        this._z = s * d + this._z * h,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, n, i) {
        return this.copy(e).slerp(n, i)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , n = 2 * Math.PI * Math.random()
          , i = Math.random()
          , r = Math.sqrt(1 - i)
          , s = Math.sqrt(i);
        return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(n), s * Math.cos(n))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, n=0) {
        return this._x = e[n],
        this._y = e[n + 1],
        this._z = e[n + 2],
        this._w = e[n + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this._x,
        e[n + 1] = this._y,
        e[n + 2] = this._z,
        e[n + 3] = this._w,
        e
    }
    fromBufferAttribute(e, n) {
        return this._x = e.getX(n),
        this._y = e.getY(n),
        this._z = e.getZ(n),
        this._w = e.getW(n),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class z {
    constructor(e=0, n=0, i=0) {
        z.prototype.isVector3 = !0,
        this.x = e,
        this.y = n,
        this.z = i
    }
    set(e, n, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = n,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, n) {
        switch (e) {
        case 0:
            this.x = n;
            break;
        case 1:
            this.y = n;
            break;
        case 2:
            this.z = n;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, n) {
        return this.x = e.x + n.x,
        this.y = e.y + n.y,
        this.z = e.z + n.z,
        this
    }
    addScaledVector(e, n) {
        return this.x += e.x * n,
        this.y += e.y * n,
        this.z += e.z * n,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, n) {
        return this.x = e.x - n.x,
        this.y = e.y - n.y,
        this.z = e.z - n.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, n) {
        return this.x = e.x * n.x,
        this.y = e.y * n.y,
        this.z = e.z * n.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(V_.setFromEuler(e))
    }
    applyAxisAngle(e, n) {
        return this.applyQuaternion(V_.setFromAxisAngle(e, n))
    }
    applyMatrix3(e) {
        const n = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * n + s[3] * i + s[6] * r,
        this.y = s[1] * n + s[4] * i + s[7] * r,
        this.z = s[2] * n + s[5] * i + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const n = this.x
          , i = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * n + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * n + s[4] * i + s[8] * r + s[12]) * o,
        this.y = (s[1] * n + s[5] * i + s[9] * r + s[13]) * o,
        this.z = (s[2] * n + s[6] * i + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const n = this.x
          , i = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = 2 * (o * r - a * i)
          , u = 2 * (a * n - s * r)
          , d = 2 * (s * i - o * n);
        return this.x = n + l * c + o * d - a * u,
        this.y = i + l * u + a * c - s * d,
        this.z = r + l * d + s * u - o * c,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const n = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * n + s[4] * i + s[8] * r,
        this.y = s[1] * n + s[5] * i + s[9] * r,
        this.z = s[2] * n + s[6] * i + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, n) {
        return this.x = Xe(this.x, e.x, n.x),
        this.y = Xe(this.y, e.y, n.y),
        this.z = Xe(this.z, e.z, n.z),
        this
    }
    clampScalar(e, n) {
        return this.x = Xe(this.x, e, n),
        this.y = Xe(this.y, e, n),
        this.z = Xe(this.z, e, n),
        this
    }
    clampLength(e, n) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Xe(i, e, n))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, n) {
        return this.x += (e.x - this.x) * n,
        this.y += (e.y - this.y) * n,
        this.z += (e.z - this.z) * n,
        this
    }
    lerpVectors(e, n, i) {
        return this.x = e.x + (n.x - e.x) * i,
        this.y = e.y + (n.y - e.y) * i,
        this.z = e.z + (n.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, n) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = n.x
          , a = n.y
          , l = n.z;
        return this.x = r * l - s * a,
        this.y = s * o - i * l,
        this.z = i * a - r * o,
        this
    }
    projectOnVector(e) {
        const n = e.lengthSq();
        if (n === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / n;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return uh.copy(this).projectOnVector(e),
        this.sub(uh)
    }
    reflect(e) {
        return this.sub(uh.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const n = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (n === 0)
            return Math.PI / 2;
        const i = this.dot(e) / n;
        return Math.acos(Xe(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const n = this.x - e.x
          , i = this.y - e.y
          , r = this.z - e.z;
        return n * n + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, n, i) {
        const r = Math.sin(n) * e;
        return this.x = r * Math.sin(i),
        this.y = Math.cos(n) * e,
        this.z = r * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, n, i) {
        return this.x = e * Math.sin(n),
        this.y = i,
        this.z = e * Math.cos(n),
        this
    }
    setFromMatrixPosition(e) {
        const n = e.elements;
        return this.x = n[12],
        this.y = n[13],
        this.z = n[14],
        this
    }
    setFromMatrixScale(e) {
        const n = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = n,
        this.y = i,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, n) {
        return this.fromArray(e.elements, n * 4)
    }
    setFromMatrix3Column(e, n) {
        return this.fromArray(e.elements, n * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, n=0) {
        return this.x = e[n],
        this.y = e[n + 1],
        this.z = e[n + 2],
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this.x,
        e[n + 1] = this.y,
        e[n + 2] = this.z,
        e
    }
    fromBufferAttribute(e, n) {
        return this.x = e.getX(n),
        this.y = e.getY(n),
        this.z = e.getZ(n),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , n = Math.random() * 2 - 1
          , i = Math.sqrt(1 - n * n);
        return this.x = i * Math.cos(e),
        this.y = n,
        this.z = i * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const uh = new z
  , V_ = new Al;
class ze {
    constructor(e, n, i, r, s, o, a, l, c) {
        ze.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, n, i, r, s, o, a, l, c)
    }
    set(e, n, i, r, s, o, a, l, c) {
        const u = this.elements;
        return u[0] = e,
        u[1] = r,
        u[2] = a,
        u[3] = n,
        u[4] = s,
        u[5] = l,
        u[6] = i,
        u[7] = o,
        u[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const n = this.elements
          , i = e.elements;
        return n[0] = i[0],
        n[1] = i[1],
        n[2] = i[2],
        n[3] = i[3],
        n[4] = i[4],
        n[5] = i[5],
        n[6] = i[6],
        n[7] = i[7],
        n[8] = i[8],
        this
    }
    extractBasis(e, n, i) {
        return e.setFromMatrix3Column(this, 0),
        n.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const n = e.elements;
        return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, n) {
        const i = e.elements
          , r = n.elements
          , s = this.elements
          , o = i[0]
          , a = i[3]
          , l = i[6]
          , c = i[1]
          , u = i[4]
          , d = i[7]
          , h = i[2]
          , p = i[5]
          , v = i[8]
          , x = r[0]
          , g = r[3]
          , f = r[6]
          , y = r[1]
          , _ = r[4]
          , S = r[7]
          , T = r[2]
          , A = r[5]
          , C = r[8];
        return s[0] = o * x + a * y + l * T,
        s[3] = o * g + a * _ + l * A,
        s[6] = o * f + a * S + l * C,
        s[1] = c * x + u * y + d * T,
        s[4] = c * g + u * _ + d * A,
        s[7] = c * f + u * S + d * C,
        s[2] = h * x + p * y + v * T,
        s[5] = h * g + p * _ + v * A,
        s[8] = h * f + p * S + v * C,
        this
    }
    multiplyScalar(e) {
        const n = this.elements;
        return n[0] *= e,
        n[3] *= e,
        n[6] *= e,
        n[1] *= e,
        n[4] *= e,
        n[7] *= e,
        n[2] *= e,
        n[5] *= e,
        n[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , n = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8];
        return n * o * u - n * a * c - i * s * u + i * a * l + r * s * c - r * o * l
    }
    invert() {
        const e = this.elements
          , n = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , d = u * o - a * c
          , h = a * l - u * s
          , p = c * s - o * l
          , v = n * d + i * h + r * p;
        if (v === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const x = 1 / v;
        return e[0] = d * x,
        e[1] = (r * c - u * i) * x,
        e[2] = (a * i - r * o) * x,
        e[3] = h * x,
        e[4] = (u * n - r * l) * x,
        e[5] = (r * s - a * n) * x,
        e[6] = p * x,
        e[7] = (i * l - c * n) * x,
        e[8] = (o * n - i * s) * x,
        this
    }
    transpose() {
        let e;
        const n = this.elements;
        return e = n[1],
        n[1] = n[3],
        n[3] = e,
        e = n[2],
        n[2] = n[6],
        n[6] = e,
        e = n[5],
        n[5] = n[7],
        n[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const n = this.elements;
        return e[0] = n[0],
        e[1] = n[3],
        e[2] = n[6],
        e[3] = n[1],
        e[4] = n[4],
        e[5] = n[7],
        e[6] = n[2],
        e[7] = n[5],
        e[8] = n[8],
        this
    }
    setUvTransform(e, n, i, r, s, o, a) {
        const l = Math.cos(s)
          , c = Math.sin(s);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + n, 0, 0, 1),
        this
    }
    scale(e, n) {
        return this.premultiply(dh.makeScale(e, n)),
        this
    }
    rotate(e) {
        return this.premultiply(dh.makeRotation(-e)),
        this
    }
    translate(e, n) {
        return this.premultiply(dh.makeTranslation(e, n)),
        this
    }
    makeTranslation(e, n) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, n, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const n = Math.cos(e)
          , i = Math.sin(e);
        return this.set(n, -i, 0, i, n, 0, 0, 0, 1),
        this
    }
    makeScale(e, n) {
        return this.set(e, 0, 0, 0, n, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const n = this.elements
          , i = e.elements;
        for (let r = 0; r < 9; r++)
            if (n[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, n=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + n];
        return this
    }
    toArray(e=[], n=0) {
        const i = this.elements;
        return e[n] = i[0],
        e[n + 1] = i[1],
        e[n + 2] = i[2],
        e[n + 3] = i[3],
        e[n + 4] = i[4],
        e[n + 5] = i[5],
        e[n + 6] = i[6],
        e[n + 7] = i[7],
        e[n + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const dh = new ze;
function iE(t) {
    for (let e = t.length - 1; e >= 0; --e)
        if (t[e] >= 65535)
            return !0;
    return !1
}
function Du(t) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t)
}
function eL() {
    const t = Du("canvas");
    return t.style.display = "block",
    t
}
const j_ = {};
function dl(t) {
    t in j_ || (j_[t] = !0,
    console.warn(t))
}
function tL(t, e, n) {
    return new Promise(function(i, r) {
        function s() {
            switch (t.clientWaitSync(e, t.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case t.WAIT_FAILED:
                r();
                break;
            case t.TIMEOUT_EXPIRED:
                setTimeout(s, n);
                break;
            default:
                i()
            }
        }
        setTimeout(s, n)
    }
    )
}
const H_ = new ze().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
  , G_ = new ze().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
function nL() {
    const t = {
        enabled: !0,
        workingColorSpace: Fo,
        spaces: {},
        convert: function(r, s, o) {
            return this.enabled === !1 || s === o || !s || !o || (this.spaces[s].transfer === rt && (r.r = ji(r.r),
            r.g = ji(r.g),
            r.b = ji(r.b)),
            this.spaces[s].primaries !== this.spaces[o].primaries && (r.applyMatrix3(this.spaces[s].toXYZ),
            r.applyMatrix3(this.spaces[o].fromXYZ)),
            this.spaces[o].transfer === rt && (r.r = Eo(r.r),
            r.g = Eo(r.g),
            r.b = Eo(r.b))),
            r
        },
        workingToColorSpace: function(r, s) {
            return this.convert(r, this.workingColorSpace, s)
        },
        colorSpaceToWorking: function(r, s) {
            return this.convert(r, s, this.workingColorSpace)
        },
        getPrimaries: function(r) {
            return this.spaces[r].primaries
        },
        getTransfer: function(r) {
            return r === gr ? Pu : this.spaces[r].transfer
        },
        getToneMappingMode: function(r) {
            return this.spaces[r].outputColorSpaceConfig.toneMappingMode || "standard"
        },
        getLuminanceCoefficients: function(r, s=this.workingColorSpace) {
            return r.fromArray(this.spaces[s].luminanceCoefficients)
        },
        define: function(r) {
            Object.assign(this.spaces, r)
        },
        _getMatrix: function(r, s, o) {
            return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ)
        },
        _getDrawingBufferColorSpace: function(r) {
            return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace
        },
        _getUnpackColorSpace: function(r=this.workingColorSpace) {
            return this.spaces[r].workingColorSpaceConfig.unpackColorSpace
        },
        fromWorkingColorSpace: function(r, s) {
            return dl("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
            t.workingToColorSpace(r, s)
        },
        toWorkingColorSpace: function(r, s) {
            return dl("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
            t.colorSpaceToWorking(r, s)
        }
    }
      , e = [.64, .33, .3, .6, .15, .06]
      , n = [.2126, .7152, .0722]
      , i = [.3127, .329];
    return t.define({
        [Fo]: {
            primaries: e,
            whitePoint: i,
            transfer: Pu,
            toXYZ: H_,
            fromXYZ: G_,
            luminanceCoefficients: n,
            workingColorSpaceConfig: {
                unpackColorSpace: Bn
            },
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Bn
            }
        },
        [Bn]: {
            primaries: e,
            whitePoint: i,
            transfer: rt,
            toXYZ: H_,
            fromXYZ: G_,
            luminanceCoefficients: n,
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Bn
            }
        }
    }),
    t
}
const Qe = nL();
function ji(t) {
    return t < .04045 ? t * .0773993808 : Math.pow(t * .9478672986 + .0521327014, 2.4)
}
function Eo(t) {
    return t < .0031308 ? t * 12.92 : 1.055 * Math.pow(t, .41666) - .055
}
let Us;
class iL {
    static getDataURL(e, n="image/png") {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let i;
        if (e instanceof HTMLCanvasElement)
            i = e;
        else {
            Us === void 0 && (Us = Du("canvas")),
            Us.width = e.width,
            Us.height = e.height;
            const r = Us.getContext("2d");
            e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height),
            i = Us
        }
        return i.toDataURL(n)
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const n = Du("canvas");
            n.width = e.width,
            n.height = e.height;
            const i = n.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = ji(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0),
            n
        } else if (e.data) {
            const n = e.data.slice(0);
            for (let i = 0; i < n.length; i++)
                n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[i] = Math.floor(ji(n[i] / 255) * 255) : n[i] = ji(n[i]);
            return {
                data: n,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let rL = 0;
class Og {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: rL++
        }),
        this.uuid = Ml(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    getSize(e) {
        const n = this.data;
        return typeof HTMLVideoElement < "u" && n instanceof HTMLVideoElement ? e.set(n.videoWidth, n.videoHeight, 0) : n instanceof VideoFrame ? e.set(n.displayHeight, n.displayWidth, 0) : n !== null ? e.set(n.width, n.height, n.depth || 0) : e.set(0, 0, 0),
        e
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string";
        if (!n && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(hh(r[o].image)) : s.push(hh(r[o]))
            } else
                s = hh(r);
            i.url = s
        }
        return n || (e.images[this.uuid] = i),
        i
    }
}
function hh(t) {
    return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap ? iL.getDataURL(t) : t.data ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let sL = 0;
const fh = new z;
class wn extends qo {
    constructor(e=wn.DEFAULT_IMAGE, n=wn.DEFAULT_MAPPING, i=ds, r=ds, s=_i, o=hs, a=ai, l=Yi, c=wn.DEFAULT_ANISOTROPY, u=gr) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: sL++
        }),
        this.uuid = Ml(),
        this.name = "",
        this.source = new Og(e),
        this.mipmaps = [],
        this.mapping = n,
        this.channel = 0,
        this.wrapS = i,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new st(0,0),
        this.repeat = new st(1,1),
        this.center = new st(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new ze,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = u,
        this.userData = {},
        this.updateRanges = [],
        this.version = 0,
        this.onUpdate = null,
        this.renderTarget = null,
        this.isRenderTargetTexture = !1,
        this.isArrayTexture = !!(e && e.depth && e.depth > 1),
        this.pmremVersion = 0
    }
    get width() {
        return this.source.getSize(fh).x
    }
    get height() {
        return this.source.getSize(fh).y
    }
    get depth() {
        return this.source.getSize(fh).z
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    addUpdateRange(e, n) {
        this.updateRanges.push({
            start: e,
            count: n
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.renderTarget = e.renderTarget,
        this.isRenderTargetTexture = e.isRenderTargetTexture,
        this.isArrayTexture = e.isArrayTexture,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    setValues(e) {
        for (const n in e) {
            const i = e[n];
            if (i === void 0) {
                console.warn(`THREE.Texture.setValues(): parameter '${n}' has value of undefined.`);
                continue
            }
            const r = this[n];
            if (r === void 0) {
                console.warn(`THREE.Texture.setValues(): property '${n}' does not exist.`);
                continue
            }
            r && i && r.isVector2 && i.isVector2 || r && i && r.isVector3 && i.isVector3 || r && i && r.isMatrix3 && i.isMatrix3 ? r.copy(i) : this[n] = i
        }
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string";
        if (!n && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.7,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        n || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== Xb)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Sp:
                e.x = e.x - Math.floor(e.x);
                break;
            case ds:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case wp:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Sp:
                e.y = e.y - Math.floor(e.y);
                break;
            case ds:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case wp:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
wn.DEFAULT_IMAGE = null;
wn.DEFAULT_MAPPING = Xb;
wn.DEFAULT_ANISOTROPY = 1;
class Rt {
    constructor(e=0, n=0, i=0, r=1) {
        Rt.prototype.isVector4 = !0,
        this.x = e,
        this.y = n,
        this.z = i,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, n, i, r) {
        return this.x = e,
        this.y = n,
        this.z = i,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, n) {
        switch (e) {
        case 0:
            this.x = n;
            break;
        case 1:
            this.y = n;
            break;
        case 2:
            this.z = n;
            break;
        case 3:
            this.w = n;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, n) {
        return this.x = e.x + n.x,
        this.y = e.y + n.y,
        this.z = e.z + n.z,
        this.w = e.w + n.w,
        this
    }
    addScaledVector(e, n) {
        return this.x += e.x * n,
        this.y += e.y * n,
        this.z += e.z * n,
        this.w += e.w * n,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, n) {
        return this.x = e.x - n.x,
        this.y = e.y - n.y,
        this.z = e.z - n.z,
        this.w = e.w - n.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const n = this.x
          , i = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * n + o[4] * i + o[8] * r + o[12] * s,
        this.y = o[1] * n + o[5] * i + o[9] * r + o[13] * s,
        this.z = o[2] * n + o[6] * i + o[10] * r + o[14] * s,
        this.w = o[3] * n + o[7] * i + o[11] * r + o[15] * s,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this.w /= e.w,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const n = Math.sqrt(1 - e.w * e.w);
        return n < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / n,
        this.y = e.y / n,
        this.z = e.z / n),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let n, i, r, s;
        const l = e.elements
          , c = l[0]
          , u = l[4]
          , d = l[8]
          , h = l[1]
          , p = l[5]
          , v = l[9]
          , x = l[2]
          , g = l[6]
          , f = l[10];
        if (Math.abs(u - h) < .01 && Math.abs(d - x) < .01 && Math.abs(v - g) < .01) {
            if (Math.abs(u + h) < .1 && Math.abs(d + x) < .1 && Math.abs(v + g) < .1 && Math.abs(c + p + f - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            n = Math.PI;
            const _ = (c + 1) / 2
              , S = (p + 1) / 2
              , T = (f + 1) / 2
              , A = (u + h) / 4
              , C = (d + x) / 4
              , P = (v + g) / 4;
            return _ > S && _ > T ? _ < .01 ? (i = 0,
            r = .707106781,
            s = .707106781) : (i = Math.sqrt(_),
            r = A / i,
            s = C / i) : S > T ? S < .01 ? (i = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(S),
            i = A / r,
            s = P / r) : T < .01 ? (i = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(T),
            i = C / s,
            r = P / s),
            this.set(i, r, s, n),
            this
        }
        let y = Math.sqrt((g - v) * (g - v) + (d - x) * (d - x) + (h - u) * (h - u));
        return Math.abs(y) < .001 && (y = 1),
        this.x = (g - v) / y,
        this.y = (d - x) / y,
        this.z = (h - u) / y,
        this.w = Math.acos((c + p + f - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const n = e.elements;
        return this.x = n[12],
        this.y = n[13],
        this.z = n[14],
        this.w = n[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, n) {
        return this.x = Xe(this.x, e.x, n.x),
        this.y = Xe(this.y, e.y, n.y),
        this.z = Xe(this.z, e.z, n.z),
        this.w = Xe(this.w, e.w, n.w),
        this
    }
    clampScalar(e, n) {
        return this.x = Xe(this.x, e, n),
        this.y = Xe(this.y, e, n),
        this.z = Xe(this.z, e, n),
        this.w = Xe(this.w, e, n),
        this
    }
    clampLength(e, n) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Xe(i, e, n))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, n) {
        return this.x += (e.x - this.x) * n,
        this.y += (e.y - this.y) * n,
        this.z += (e.z - this.z) * n,
        this.w += (e.w - this.w) * n,
        this
    }
    lerpVectors(e, n, i) {
        return this.x = e.x + (n.x - e.x) * i,
        this.y = e.y + (n.y - e.y) * i,
        this.z = e.z + (n.z - e.z) * i,
        this.w = e.w + (n.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, n=0) {
        return this.x = e[n],
        this.y = e[n + 1],
        this.z = e[n + 2],
        this.w = e[n + 3],
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this.x,
        e[n + 1] = this.y,
        e[n + 2] = this.z,
        e[n + 3] = this.w,
        e
    }
    fromBufferAttribute(e, n) {
        return this.x = e.getX(n),
        this.y = e.getY(n),
        this.z = e.getZ(n),
        this.w = e.getW(n),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class oL extends qo {
    constructor(e=1, n=1, i={}) {
        super(),
        i = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: _i,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1,
            depth: 1,
            multiview: !1
        }, i),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = n,
        this.depth = i.depth,
        this.scissor = new Rt(0,0,e,n),
        this.scissorTest = !1,
        this.viewport = new Rt(0,0,e,n);
        const r = {
            width: e,
            height: n,
            depth: i.depth
        }
          , s = new wn(r);
        this.textures = [];
        const o = i.count;
        for (let a = 0; a < o; a++)
            this.textures[a] = s.clone(),
            this.textures[a].isRenderTargetTexture = !0,
            this.textures[a].renderTarget = this;
        this._setTextureOptions(i),
        this.depthBuffer = i.depthBuffer,
        this.stencilBuffer = i.stencilBuffer,
        this.resolveDepthBuffer = i.resolveDepthBuffer,
        this.resolveStencilBuffer = i.resolveStencilBuffer,
        this._depthTexture = null,
        this.depthTexture = i.depthTexture,
        this.samples = i.samples,
        this.multiview = i.multiview
    }
    _setTextureOptions(e={}) {
        const n = {
            minFilter: _i,
            generateMipmaps: !1,
            flipY: !1,
            internalFormat: null
        };
        e.mapping !== void 0 && (n.mapping = e.mapping),
        e.wrapS !== void 0 && (n.wrapS = e.wrapS),
        e.wrapT !== void 0 && (n.wrapT = e.wrapT),
        e.wrapR !== void 0 && (n.wrapR = e.wrapR),
        e.magFilter !== void 0 && (n.magFilter = e.magFilter),
        e.minFilter !== void 0 && (n.minFilter = e.minFilter),
        e.format !== void 0 && (n.format = e.format),
        e.type !== void 0 && (n.type = e.type),
        e.anisotropy !== void 0 && (n.anisotropy = e.anisotropy),
        e.colorSpace !== void 0 && (n.colorSpace = e.colorSpace),
        e.flipY !== void 0 && (n.flipY = e.flipY),
        e.generateMipmaps !== void 0 && (n.generateMipmaps = e.generateMipmaps),
        e.internalFormat !== void 0 && (n.internalFormat = e.internalFormat);
        for (let i = 0; i < this.textures.length; i++)
            this.textures[i].setValues(n)
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    set depthTexture(e) {
        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
        e !== null && (e.renderTarget = this),
        this._depthTexture = e
    }
    get depthTexture() {
        return this._depthTexture
    }
    setSize(e, n, i=1) {
        if (this.width !== e || this.height !== n || this.depth !== i) {
            this.width = e,
            this.height = n,
            this.depth = i;
            for (let r = 0, s = this.textures.length; r < s; r++)
                this.textures[r].image.width = e,
                this.textures[r].image.height = n,
                this.textures[r].image.depth = i,
                this.textures[r].isArrayTexture = this.textures[r].image.depth > 1;
            this.dispose()
        }
        this.viewport.set(0, 0, e, n),
        this.scissor.set(0, 0, e, n)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let n = 0, i = e.textures.length; n < i; n++) {
            this.textures[n] = e.textures[n].clone(),
            this.textures[n].isRenderTargetTexture = !0,
            this.textures[n].renderTarget = this;
            const r = Object.assign({}, e.textures[n].image);
            this.textures[n].source = new Og(r)
        }
        return this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class bs extends oL {
    constructor(e=1, n=1, i={}) {
        super(e, n, i),
        this.isWebGLRenderTarget = !0
    }
}
class rE extends wn {
    constructor(e=null, n=1, i=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: n,
            height: i,
            depth: r
        },
        this.magFilter = ui,
        this.minFilter = ui,
        this.wrapR = ds,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class aL extends wn {
    constructor(e=null, n=1, i=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: n,
            height: i,
            depth: r
        },
        this.magFilter = ui,
        this.minFilter = ui,
        this.wrapR = ds,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Cl {
    constructor(e=new z(1 / 0,1 / 0,1 / 0), n=new z(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = n
    }
    set(e, n) {
        return this.min.copy(e),
        this.max.copy(n),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let n = 0, i = e.length; n < i; n += 3)
            this.expandByPoint(Zn.fromArray(e, n));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let n = 0, i = e.count; n < i; n++)
            this.expandByPoint(Zn.fromBufferAttribute(e, n));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let n = 0, i = e.length; n < i; n++)
            this.expandByPoint(e[n]);
        return this
    }
    setFromCenterAndSize(e, n) {
        const i = Zn.copy(n).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, n=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, n)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, n=!1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const s = i.getAttribute("position");
            if (n === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, Zn) : Zn.fromBufferAttribute(s, o),
                    Zn.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Zn);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                oc.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(),
                oc.copy(i.boundingBox)),
                oc.applyMatrix4(e.matrixWorld),
                this.union(oc)
        }
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++)
            this.expandByObject(r[s], n);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, n) {
        return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Zn),
        Zn.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let n, i;
        return e.normal.x > 0 ? (n = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (n += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (n += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        n <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(ca),
        ac.subVectors(this.max, ca),
        Os.subVectors(e.a, ca),
        Fs.subVectors(e.b, ca),
        Bs.subVectors(e.c, ca),
        ir.subVectors(Fs, Os),
        rr.subVectors(Bs, Fs),
        Wr.subVectors(Os, Bs);
        let n = [0, -ir.z, ir.y, 0, -rr.z, rr.y, 0, -Wr.z, Wr.y, ir.z, 0, -ir.x, rr.z, 0, -rr.x, Wr.z, 0, -Wr.x, -ir.y, ir.x, 0, -rr.y, rr.x, 0, -Wr.y, Wr.x, 0];
        return !ph(n, Os, Fs, Bs, ac) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !ph(n, Os, Fs, Bs, ac)) ? !1 : (lc.crossVectors(ir, rr),
        n = [lc.x, lc.y, lc.z],
        ph(n, Os, Fs, Bs, ac))
    }
    clampPoint(e, n) {
        return n.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Zn).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(Zn).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Mi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Mi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Mi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Mi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Mi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Mi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Mi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Mi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Mi),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
    toJSON() {
        return {
            min: this.min.toArray(),
            max: this.max.toArray()
        }
    }
    fromJSON(e) {
        return this.min.fromArray(e.min),
        this.max.fromArray(e.max),
        this
    }
}
const Mi = [new z, new z, new z, new z, new z, new z, new z, new z]
  , Zn = new z
  , oc = new Cl
  , Os = new z
  , Fs = new z
  , Bs = new z
  , ir = new z
  , rr = new z
  , Wr = new z
  , ca = new z
  , ac = new z
  , lc = new z
  , $r = new z;
function ph(t, e, n, i, r) {
    for (let s = 0, o = t.length - 3; s <= o; s += 3) {
        $r.fromArray(t, s);
        const a = r.x * Math.abs($r.x) + r.y * Math.abs($r.y) + r.z * Math.abs($r.z)
          , l = e.dot($r)
          , c = n.dot($r)
          , u = i.dot($r);
        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
            return !1
    }
    return !0
}
const lL = new Cl
  , ua = new z
  , mh = new z;
class rd {
    constructor(e=new z, n=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = n
    }
    set(e, n) {
        return this.center.copy(e),
        this.radius = n,
        this
    }
    setFromPoints(e, n) {
        const i = this.center;
        n !== void 0 ? i.copy(n) : lL.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const n = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= n * n
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, n) {
        const i = this.center.distanceToSquared(e);
        return n.copy(e),
        i > this.radius * this.radius && (n.sub(this.center).normalize(),
        n.multiplyScalar(this.radius).add(this.center)),
        n
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        ua.subVectors(e, this.center);
        const n = ua.lengthSq();
        if (n > this.radius * this.radius) {
            const i = Math.sqrt(n)
              , r = (i - this.radius) * .5;
            this.center.addScaledVector(ua, r / i),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (mh.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(ua.copy(e.center).add(mh)),
        this.expandByPoint(ua.copy(e.center).sub(mh))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        return {
            radius: this.radius,
            center: this.center.toArray()
        }
    }
    fromJSON(e) {
        return this.radius = e.radius,
        this.center.fromArray(e.center),
        this
    }
}
const Ai = new z
  , gh = new z
  , cc = new z
  , sr = new z
  , vh = new z
  , uc = new z
  , _h = new z;
class sE {
    constructor(e=new z, n=new z(0,0,-1)) {
        this.origin = e,
        this.direction = n
    }
    set(e, n) {
        return this.origin.copy(e),
        this.direction.copy(n),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, n) {
        return n.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, Ai)),
        this
    }
    closestPointToPoint(e, n) {
        n.subVectors(e, this.origin);
        const i = n.dot(this.direction);
        return i < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const n = Ai.subVectors(e, this.origin).dot(this.direction);
        return n < 0 ? this.origin.distanceToSquared(e) : (Ai.copy(this.origin).addScaledVector(this.direction, n),
        Ai.distanceToSquared(e))
    }
    distanceSqToSegment(e, n, i, r) {
        gh.copy(e).add(n).multiplyScalar(.5),
        cc.copy(n).sub(e).normalize(),
        sr.copy(this.origin).sub(gh);
        const s = e.distanceTo(n) * .5
          , o = -this.direction.dot(cc)
          , a = sr.dot(this.direction)
          , l = -sr.dot(cc)
          , c = sr.lengthSq()
          , u = Math.abs(1 - o * o);
        let d, h, p, v;
        if (u > 0)
            if (d = o * l - a,
            h = o * a - l,
            v = s * u,
            d >= 0)
                if (h >= -v)
                    if (h <= v) {
                        const x = 1 / u;
                        d *= x,
                        h *= x,
                        p = d * (d + o * h + 2 * a) + h * (o * d + h + 2 * l) + c
                    } else
                        h = s,
                        d = Math.max(0, -(o * h + a)),
                        p = -d * d + h * (h + 2 * l) + c;
                else
                    h = -s,
                    d = Math.max(0, -(o * h + a)),
                    p = -d * d + h * (h + 2 * l) + c;
            else
                h <= -v ? (d = Math.max(0, -(-o * s + a)),
                h = d > 0 ? -s : Math.min(Math.max(-s, -l), s),
                p = -d * d + h * (h + 2 * l) + c) : h <= v ? (d = 0,
                h = Math.min(Math.max(-s, -l), s),
                p = h * (h + 2 * l) + c) : (d = Math.max(0, -(o * s + a)),
                h = d > 0 ? s : Math.min(Math.max(-s, -l), s),
                p = -d * d + h * (h + 2 * l) + c);
        else
            h = o > 0 ? -s : s,
            d = Math.max(0, -(o * h + a)),
            p = -d * d + h * (h + 2 * l) + c;
        return i && i.copy(this.origin).addScaledVector(this.direction, d),
        r && r.copy(gh).addScaledVector(cc, h),
        p
    }
    intersectSphere(e, n) {
        Ai.subVectors(e.center, this.origin);
        const i = Ai.dot(this.direction)
          , r = Ai.dot(Ai) - i * i
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , a = i - o
          , l = i + o;
        return l < 0 ? null : a < 0 ? this.at(l, n) : this.at(a, n)
    }
    intersectsSphere(e) {
        return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const n = e.normal.dot(this.direction);
        if (n === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / n;
        return i >= 0 ? i : null
    }
    intersectPlane(e, n) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, n)
    }
    intersectsPlane(e) {
        const n = e.distanceToPoint(this.origin);
        return n === 0 || e.normal.dot(this.direction) * n < 0
    }
    intersectBox(e, n) {
        let i, r, s, o, a, l;
        const c = 1 / this.direction.x
          , u = 1 / this.direction.y
          , d = 1 / this.direction.z
          , h = this.origin;
        return c >= 0 ? (i = (e.min.x - h.x) * c,
        r = (e.max.x - h.x) * c) : (i = (e.max.x - h.x) * c,
        r = (e.min.x - h.x) * c),
        u >= 0 ? (s = (e.min.y - h.y) * u,
        o = (e.max.y - h.y) * u) : (s = (e.max.y - h.y) * u,
        o = (e.min.y - h.y) * u),
        i > o || s > r || ((s > i || isNaN(i)) && (i = s),
        (o < r || isNaN(r)) && (r = o),
        d >= 0 ? (a = (e.min.z - h.z) * d,
        l = (e.max.z - h.z) * d) : (a = (e.max.z - h.z) * d,
        l = (e.min.z - h.z) * d),
        i > l || a > r) || ((a > i || i !== i) && (i = a),
        (l < r || r !== r) && (r = l),
        r < 0) ? null : this.at(i >= 0 ? i : r, n)
    }
    intersectsBox(e) {
        return this.intersectBox(e, Ai) !== null
    }
    intersectTriangle(e, n, i, r, s) {
        vh.subVectors(n, e),
        uc.subVectors(i, e),
        _h.crossVectors(vh, uc);
        let o = this.direction.dot(_h), a;
        if (o > 0) {
            if (r)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        sr.subVectors(this.origin, e);
        const l = a * this.direction.dot(uc.crossVectors(sr, uc));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(vh.cross(sr));
        if (c < 0 || l + c > o)
            return null;
        const u = -a * sr.dot(_h);
        return u < 0 ? null : this.at(u / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Lt {
    constructor(e, n, i, r, s, o, a, l, c, u, d, h, p, v, x, g) {
        Lt.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, n, i, r, s, o, a, l, c, u, d, h, p, v, x, g)
    }
    set(e, n, i, r, s, o, a, l, c, u, d, h, p, v, x, g) {
        const f = this.elements;
        return f[0] = e,
        f[4] = n,
        f[8] = i,
        f[12] = r,
        f[1] = s,
        f[5] = o,
        f[9] = a,
        f[13] = l,
        f[2] = c,
        f[6] = u,
        f[10] = d,
        f[14] = h,
        f[3] = p,
        f[7] = v,
        f[11] = x,
        f[15] = g,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Lt().fromArray(this.elements)
    }
    copy(e) {
        const n = this.elements
          , i = e.elements;
        return n[0] = i[0],
        n[1] = i[1],
        n[2] = i[2],
        n[3] = i[3],
        n[4] = i[4],
        n[5] = i[5],
        n[6] = i[6],
        n[7] = i[7],
        n[8] = i[8],
        n[9] = i[9],
        n[10] = i[10],
        n[11] = i[11],
        n[12] = i[12],
        n[13] = i[13],
        n[14] = i[14],
        n[15] = i[15],
        this
    }
    copyPosition(e) {
        const n = this.elements
          , i = e.elements;
        return n[12] = i[12],
        n[13] = i[13],
        n[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const n = e.elements;
        return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, n, i) {
        return e.setFromMatrixColumn(this, 0),
        n.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, n, i) {
        return this.set(e.x, n.x, i.x, 0, e.y, n.y, i.y, 0, e.z, n.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const n = this.elements
          , i = e.elements
          , r = 1 / zs.setFromMatrixColumn(e, 0).length()
          , s = 1 / zs.setFromMatrixColumn(e, 1).length()
          , o = 1 / zs.setFromMatrixColumn(e, 2).length();
        return n[0] = i[0] * r,
        n[1] = i[1] * r,
        n[2] = i[2] * r,
        n[3] = 0,
        n[4] = i[4] * s,
        n[5] = i[5] * s,
        n[6] = i[6] * s,
        n[7] = 0,
        n[8] = i[8] * o,
        n[9] = i[9] * o,
        n[10] = i[10] * o,
        n[11] = 0,
        n[12] = 0,
        n[13] = 0,
        n[14] = 0,
        n[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const n = this.elements
          , i = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , l = Math.cos(r)
          , c = Math.sin(r)
          , u = Math.cos(s)
          , d = Math.sin(s);
        if (e.order === "XYZ") {
            const h = o * u
              , p = o * d
              , v = a * u
              , x = a * d;
            n[0] = l * u,
            n[4] = -l * d,
            n[8] = c,
            n[1] = p + v * c,
            n[5] = h - x * c,
            n[9] = -a * l,
            n[2] = x - h * c,
            n[6] = v + p * c,
            n[10] = o * l
        } else if (e.order === "YXZ") {
            const h = l * u
              , p = l * d
              , v = c * u
              , x = c * d;
            n[0] = h + x * a,
            n[4] = v * a - p,
            n[8] = o * c,
            n[1] = o * d,
            n[5] = o * u,
            n[9] = -a,
            n[2] = p * a - v,
            n[6] = x + h * a,
            n[10] = o * l
        } else if (e.order === "ZXY") {
            const h = l * u
              , p = l * d
              , v = c * u
              , x = c * d;
            n[0] = h - x * a,
            n[4] = -o * d,
            n[8] = v + p * a,
            n[1] = p + v * a,
            n[5] = o * u,
            n[9] = x - h * a,
            n[2] = -o * c,
            n[6] = a,
            n[10] = o * l
        } else if (e.order === "ZYX") {
            const h = o * u
              , p = o * d
              , v = a * u
              , x = a * d;
            n[0] = l * u,
            n[4] = v * c - p,
            n[8] = h * c + x,
            n[1] = l * d,
            n[5] = x * c + h,
            n[9] = p * c - v,
            n[2] = -c,
            n[6] = a * l,
            n[10] = o * l
        } else if (e.order === "YZX") {
            const h = o * l
              , p = o * c
              , v = a * l
              , x = a * c;
            n[0] = l * u,
            n[4] = x - h * d,
            n[8] = v * d + p,
            n[1] = d,
            n[5] = o * u,
            n[9] = -a * u,
            n[2] = -c * u,
            n[6] = p * d + v,
            n[10] = h - x * d
        } else if (e.order === "XZY") {
            const h = o * l
              , p = o * c
              , v = a * l
              , x = a * c;
            n[0] = l * u,
            n[4] = -d,
            n[8] = c * u,
            n[1] = h * d + x,
            n[5] = o * u,
            n[9] = p * d - v,
            n[2] = v * d - p,
            n[6] = a * u,
            n[10] = x * d + h
        }
        return n[3] = 0,
        n[7] = 0,
        n[11] = 0,
        n[12] = 0,
        n[13] = 0,
        n[14] = 0,
        n[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(cL, e, uL)
    }
    lookAt(e, n, i) {
        const r = this.elements;
        return Mn.subVectors(e, n),
        Mn.lengthSq() === 0 && (Mn.z = 1),
        Mn.normalize(),
        or.crossVectors(i, Mn),
        or.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Mn.x += 1e-4 : Mn.z += 1e-4,
        Mn.normalize(),
        or.crossVectors(i, Mn)),
        or.normalize(),
        dc.crossVectors(Mn, or),
        r[0] = or.x,
        r[4] = dc.x,
        r[8] = Mn.x,
        r[1] = or.y,
        r[5] = dc.y,
        r[9] = Mn.y,
        r[2] = or.z,
        r[6] = dc.z,
        r[10] = Mn.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, n) {
        const i = e.elements
          , r = n.elements
          , s = this.elements
          , o = i[0]
          , a = i[4]
          , l = i[8]
          , c = i[12]
          , u = i[1]
          , d = i[5]
          , h = i[9]
          , p = i[13]
          , v = i[2]
          , x = i[6]
          , g = i[10]
          , f = i[14]
          , y = i[3]
          , _ = i[7]
          , S = i[11]
          , T = i[15]
          , A = r[0]
          , C = r[4]
          , P = r[8]
          , M = r[12]
          , b = r[1]
          , L = r[5]
          , F = r[9]
          , H = r[13]
          , Z = r[2]
          , $ = r[6]
          , q = r[10]
          , B = r[14]
          , D = r[3]
          , G = r[7]
          , Y = r[11]
          , le = r[15];
        return s[0] = o * A + a * b + l * Z + c * D,
        s[4] = o * C + a * L + l * $ + c * G,
        s[8] = o * P + a * F + l * q + c * Y,
        s[12] = o * M + a * H + l * B + c * le,
        s[1] = u * A + d * b + h * Z + p * D,
        s[5] = u * C + d * L + h * $ + p * G,
        s[9] = u * P + d * F + h * q + p * Y,
        s[13] = u * M + d * H + h * B + p * le,
        s[2] = v * A + x * b + g * Z + f * D,
        s[6] = v * C + x * L + g * $ + f * G,
        s[10] = v * P + x * F + g * q + f * Y,
        s[14] = v * M + x * H + g * B + f * le,
        s[3] = y * A + _ * b + S * Z + T * D,
        s[7] = y * C + _ * L + S * $ + T * G,
        s[11] = y * P + _ * F + S * q + T * Y,
        s[15] = y * M + _ * H + S * B + T * le,
        this
    }
    multiplyScalar(e) {
        const n = this.elements;
        return n[0] *= e,
        n[4] *= e,
        n[8] *= e,
        n[12] *= e,
        n[1] *= e,
        n[5] *= e,
        n[9] *= e,
        n[13] *= e,
        n[2] *= e,
        n[6] *= e,
        n[10] *= e,
        n[14] *= e,
        n[3] *= e,
        n[7] *= e,
        n[11] *= e,
        n[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , n = e[0]
          , i = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , u = e[2]
          , d = e[6]
          , h = e[10]
          , p = e[14]
          , v = e[3]
          , x = e[7]
          , g = e[11]
          , f = e[15];
        return v * (+s * l * d - r * c * d - s * a * h + i * c * h + r * a * p - i * l * p) + x * (+n * l * p - n * c * h + s * o * h - r * o * p + r * c * u - s * l * u) + g * (+n * c * d - n * a * p - s * o * d + i * o * p + s * a * u - i * c * u) + f * (-r * a * u - n * l * d + n * a * h + r * o * d - i * o * h + i * l * u)
    }
    transpose() {
        const e = this.elements;
        let n;
        return n = e[1],
        e[1] = e[4],
        e[4] = n,
        n = e[2],
        e[2] = e[8],
        e[8] = n,
        n = e[6],
        e[6] = e[9],
        e[9] = n,
        n = e[3],
        e[3] = e[12],
        e[12] = n,
        n = e[7],
        e[7] = e[13],
        e[13] = n,
        n = e[11],
        e[11] = e[14],
        e[14] = n,
        this
    }
    setPosition(e, n, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = n,
        r[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , n = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , d = e[9]
          , h = e[10]
          , p = e[11]
          , v = e[12]
          , x = e[13]
          , g = e[14]
          , f = e[15]
          , y = d * g * c - x * h * c + x * l * p - a * g * p - d * l * f + a * h * f
          , _ = v * h * c - u * g * c - v * l * p + o * g * p + u * l * f - o * h * f
          , S = u * x * c - v * d * c + v * a * p - o * x * p - u * a * f + o * d * f
          , T = v * d * l - u * x * l - v * a * h + o * x * h + u * a * g - o * d * g
          , A = n * y + i * _ + r * S + s * T;
        if (A === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const C = 1 / A;
        return e[0] = y * C,
        e[1] = (x * h * s - d * g * s - x * r * p + i * g * p + d * r * f - i * h * f) * C,
        e[2] = (a * g * s - x * l * s + x * r * c - i * g * c - a * r * f + i * l * f) * C,
        e[3] = (d * l * s - a * h * s - d * r * c + i * h * c + a * r * p - i * l * p) * C,
        e[4] = _ * C,
        e[5] = (u * g * s - v * h * s + v * r * p - n * g * p - u * r * f + n * h * f) * C,
        e[6] = (v * l * s - o * g * s - v * r * c + n * g * c + o * r * f - n * l * f) * C,
        e[7] = (o * h * s - u * l * s + u * r * c - n * h * c - o * r * p + n * l * p) * C,
        e[8] = S * C,
        e[9] = (v * d * s - u * x * s - v * i * p + n * x * p + u * i * f - n * d * f) * C,
        e[10] = (o * x * s - v * a * s + v * i * c - n * x * c - o * i * f + n * a * f) * C,
        e[11] = (u * a * s - o * d * s - u * i * c + n * d * c + o * i * p - n * a * p) * C,
        e[12] = T * C,
        e[13] = (u * x * r - v * d * r + v * i * h - n * x * h - u * i * g + n * d * g) * C,
        e[14] = (v * a * r - o * x * r - v * i * l + n * x * l + o * i * g - n * a * g) * C,
        e[15] = (o * d * r - u * a * r + u * i * l - n * d * l - o * i * h + n * a * h) * C,
        this
    }
    scale(e) {
        const n = this.elements
          , i = e.x
          , r = e.y
          , s = e.z;
        return n[0] *= i,
        n[4] *= r,
        n[8] *= s,
        n[1] *= i,
        n[5] *= r,
        n[9] *= s,
        n[2] *= i,
        n[6] *= r,
        n[10] *= s,
        n[3] *= i,
        n[7] *= r,
        n[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(n, i, r))
    }
    makeTranslation(e, n, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const n = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, n, -i, 0, 0, i, n, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const n = Math.cos(e)
          , i = Math.sin(e);
        return this.set(n, 0, i, 0, 0, 1, 0, 0, -i, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const n = Math.cos(e)
          , i = Math.sin(e);
        return this.set(n, -i, 0, 0, i, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, n) {
        const i = Math.cos(n)
          , r = Math.sin(n)
          , s = 1 - i
          , o = e.x
          , a = e.y
          , l = e.z
          , c = s * o
          , u = s * a;
        return this.set(c * o + i, c * a - r * l, c * l + r * a, 0, c * a + r * l, u * a + i, u * l - r * o, 0, c * l - r * a, u * l + r * o, s * l * l + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, n, i) {
        return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, n, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, n, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, n, i) {
        const r = this.elements
          , s = n._x
          , o = n._y
          , a = n._z
          , l = n._w
          , c = s + s
          , u = o + o
          , d = a + a
          , h = s * c
          , p = s * u
          , v = s * d
          , x = o * u
          , g = o * d
          , f = a * d
          , y = l * c
          , _ = l * u
          , S = l * d
          , T = i.x
          , A = i.y
          , C = i.z;
        return r[0] = (1 - (x + f)) * T,
        r[1] = (p + S) * T,
        r[2] = (v - _) * T,
        r[3] = 0,
        r[4] = (p - S) * A,
        r[5] = (1 - (h + f)) * A,
        r[6] = (g + y) * A,
        r[7] = 0,
        r[8] = (v + _) * C,
        r[9] = (g - y) * C,
        r[10] = (1 - (h + x)) * C,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, n, i) {
        const r = this.elements;
        let s = zs.set(r[0], r[1], r[2]).length();
        const o = zs.set(r[4], r[5], r[6]).length()
          , a = zs.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        Jn.copy(this);
        const c = 1 / s
          , u = 1 / o
          , d = 1 / a;
        return Jn.elements[0] *= c,
        Jn.elements[1] *= c,
        Jn.elements[2] *= c,
        Jn.elements[4] *= u,
        Jn.elements[5] *= u,
        Jn.elements[6] *= u,
        Jn.elements[8] *= d,
        Jn.elements[9] *= d,
        Jn.elements[10] *= d,
        n.setFromRotationMatrix(Jn),
        i.x = s,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, n, i, r, s, o, a=yi, l=!1) {
        const c = this.elements
          , u = 2 * s / (n - e)
          , d = 2 * s / (i - r)
          , h = (n + e) / (n - e)
          , p = (i + r) / (i - r);
        let v, x;
        if (l)
            v = s / (o - s),
            x = o * s / (o - s);
        else if (a === yi)
            v = -(o + s) / (o - s),
            x = -2 * o * s / (o - s);
        else if (a === Nu)
            v = -o / (o - s),
            x = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return c[0] = u,
        c[4] = 0,
        c[8] = h,
        c[12] = 0,
        c[1] = 0,
        c[5] = d,
        c[9] = p,
        c[13] = 0,
        c[2] = 0,
        c[6] = 0,
        c[10] = v,
        c[14] = x,
        c[3] = 0,
        c[7] = 0,
        c[11] = -1,
        c[15] = 0,
        this
    }
    makeOrthographic(e, n, i, r, s, o, a=yi, l=!1) {
        const c = this.elements
          , u = 2 / (n - e)
          , d = 2 / (i - r)
          , h = -(n + e) / (n - e)
          , p = -(i + r) / (i - r);
        let v, x;
        if (l)
            v = 1 / (o - s),
            x = o / (o - s);
        else if (a === yi)
            v = -2 / (o - s),
            x = -(o + s) / (o - s);
        else if (a === Nu)
            v = -1 / (o - s),
            x = -s / (o - s);
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return c[0] = u,
        c[4] = 0,
        c[8] = 0,
        c[12] = h,
        c[1] = 0,
        c[5] = d,
        c[9] = 0,
        c[13] = p,
        c[2] = 0,
        c[6] = 0,
        c[10] = v,
        c[14] = x,
        c[3] = 0,
        c[7] = 0,
        c[11] = 0,
        c[15] = 1,
        this
    }
    equals(e) {
        const n = this.elements
          , i = e.elements;
        for (let r = 0; r < 16; r++)
            if (n[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, n=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + n];
        return this
    }
    toArray(e=[], n=0) {
        const i = this.elements;
        return e[n] = i[0],
        e[n + 1] = i[1],
        e[n + 2] = i[2],
        e[n + 3] = i[3],
        e[n + 4] = i[4],
        e[n + 5] = i[5],
        e[n + 6] = i[6],
        e[n + 7] = i[7],
        e[n + 8] = i[8],
        e[n + 9] = i[9],
        e[n + 10] = i[10],
        e[n + 11] = i[11],
        e[n + 12] = i[12],
        e[n + 13] = i[13],
        e[n + 14] = i[14],
        e[n + 15] = i[15],
        e
    }
}
const zs = new z
  , Jn = new Lt
  , cL = new z(0,0,0)
  , uL = new z(1,1,1)
  , or = new z
  , dc = new z
  , Mn = new z
  , W_ = new Lt
  , $_ = new Al;
class Zi {
    constructor(e=0, n=0, i=0, r=Zi.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = n,
        this._z = i,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, n, i, r=this._order) {
        return this._x = e,
        this._y = n,
        this._z = i,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, n=this._order, i=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , a = r[8]
          , l = r[1]
          , c = r[5]
          , u = r[9]
          , d = r[2]
          , h = r[6]
          , p = r[10];
        switch (n) {
        case "XYZ":
            this._y = Math.asin(Xe(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, p),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(h, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-Xe(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, p),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(Xe(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(-d, p),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-Xe(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._x = Math.atan2(h, p),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(Xe(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c),
            this._y = Math.atan2(-d, s)) : (this._x = 0,
            this._y = Math.atan2(a, p));
            break;
        case "XZY":
            this._z = Math.asin(-Xe(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(h, c),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, p),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n)
        }
        return this._order = n,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, n, i) {
        return W_.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(W_, n, i)
    }
    setFromVector3(e, n=this._order) {
        return this.set(e.x, e.y, e.z, n)
    }
    reorder(e) {
        return $_.setFromEuler(this),
        this.setFromQuaternion($_, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this._x,
        e[n + 1] = this._y,
        e[n + 2] = this._z,
        e[n + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Zi.DEFAULT_ORDER = "XYZ";
class oE {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let dL = 0;
const X_ = new z
  , Vs = new Al
  , Ci = new Lt
  , hc = new z
  , da = new z
  , hL = new z
  , fL = new Al
  , q_ = new z(1,0,0)
  , K_ = new z(0,1,0)
  , Y_ = new z(0,0,1)
  , Z_ = {
    type: "added"
}
  , pL = {
    type: "removed"
}
  , js = {
    type: "childadded",
    child: null
}
  , yh = {
    type: "childremoved",
    child: null
};
class bn extends qo {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: dL++
        }),
        this.uuid = Ml(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = bn.DEFAULT_UP.clone();
        const e = new z
          , n = new Zi
          , i = new Al
          , r = new z(1,1,1);
        function s() {
            i.setFromEuler(n, !1)
        }
        function o() {
            n.setFromQuaternion(i, void 0, !1)
        }
        n._onChange(s),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new Lt
            },
            normalMatrix: {
                value: new ze
            }
        }),
        this.matrix = new Lt,
        this.matrixWorld = new Lt,
        this.matrixAutoUpdate = bn.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = bn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new oE,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.customDepthMaterial = void 0,
        this.customDistanceMaterial = void 0,
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, n) {
        this.quaternion.setFromAxisAngle(e, n)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, n) {
        return Vs.setFromAxisAngle(e, n),
        this.quaternion.multiply(Vs),
        this
    }
    rotateOnWorldAxis(e, n) {
        return Vs.setFromAxisAngle(e, n),
        this.quaternion.premultiply(Vs),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(q_, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(K_, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(Y_, e)
    }
    translateOnAxis(e, n) {
        return X_.copy(e).applyQuaternion(this.quaternion),
        this.position.add(X_.multiplyScalar(n)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(q_, e)
    }
    translateY(e) {
        return this.translateOnAxis(K_, e)
    }
    translateZ(e) {
        return this.translateOnAxis(Y_, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Ci.copy(this.matrixWorld).invert())
    }
    lookAt(e, n, i) {
        e.isVector3 ? hc.copy(e) : hc.set(e, n, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        da.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Ci.lookAt(da, hc, this.up) : Ci.lookAt(hc, da, this.up),
        this.quaternion.setFromRotationMatrix(Ci),
        r && (Ci.extractRotation(r.matrixWorld),
        Vs.setFromRotationMatrix(Ci),
        this.quaternion.premultiply(Vs.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.add(arguments[n]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(Z_),
        js.child = e,
        this.dispatchEvent(js),
        js.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const n = this.children.indexOf(e);
        return n !== -1 && (e.parent = null,
        this.children.splice(n, 1),
        e.dispatchEvent(pL),
        yh.child = e,
        this.dispatchEvent(yh),
        yh.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Ci.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Ci.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Ci),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(Z_),
        js.child = e,
        this.dispatchEvent(js),
        js.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, n) {
        if (this[e] === n)
            return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, n);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, n, i=[]) {
        this[e] === n && i.push(this);
        const r = this.children;
        for (let s = 0, o = r.length; s < o; s++)
            r[s].getObjectsByProperty(e, n, i);
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(da, e, hL),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(da, fL, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const n = this.matrixWorld.elements;
        return e.set(n[8], n[9], n[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const n = this.children;
        for (let i = 0, r = n.length; i < r; i++)
            n[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const n = this.children;
        for (let i = 0, r = n.length; i < r; i++)
            n[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const n = this.parent;
        n !== null && (e(n),
        n.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const n = this.children;
        for (let i = 0, r = n.length; i < r; i++)
            n[i].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, n) {
        const i = this.parent;
        if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        n === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++)
                r[s].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string"
          , i = {};
        n && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.7,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        r.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (r.type = "BatchedMesh",
        r.perObjectFrustumCulled = this.perObjectFrustumCulled,
        r.sortObjects = this.sortObjects,
        r.drawRanges = this._drawRanges,
        r.reservedRanges = this._reservedRanges,
        r.geometryInfo = this._geometryInfo.map(a => ({
            ...a,
            boundingBox: a.boundingBox ? a.boundingBox.toJSON() : void 0,
            boundingSphere: a.boundingSphere ? a.boundingSphere.toJSON() : void 0
        })),
        r.instanceInfo = this._instanceInfo.map(a => ({
            ...a
        })),
        r.availableInstanceIds = this._availableInstanceIds.slice(),
        r.availableGeometryIds = this._availableGeometryIds.slice(),
        r.nextIndexStart = this._nextIndexStart,
        r.nextVertexStart = this._nextVertexStart,
        r.geometryCount = this._geometryCount,
        r.maxInstanceCount = this._maxInstanceCount,
        r.maxVertexCount = this._maxVertexCount,
        r.maxIndexCount = this._maxIndexCount,
        r.geometryInitialized = this._geometryInitialized,
        r.matricesTexture = this._matricesTexture.toJSON(e),
        r.indirectTexture = this._indirectTexture.toJSON(e),
        this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (r.boundingSphere = this.boundingSphere.toJSON()),
        this.boundingBox !== null && (r.boundingBox = this.boundingBox.toJSON()));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, u = l.length; c < u; c++) {
                        const d = l[c];
                        s(e.shapes, d)
                    }
                else
                    s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(s(e.materials, this.material[l]));
                r.material = a
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                r.animations.push(s(e.animations, l))
            }
        }
        if (n) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , u = o(e.images)
              , d = o(e.shapes)
              , h = o(e.skeletons)
              , p = o(e.animations)
              , v = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            l.length > 0 && (i.materials = l),
            c.length > 0 && (i.textures = c),
            u.length > 0 && (i.images = u),
            d.length > 0 && (i.shapes = d),
            h.length > 0 && (i.skeletons = h),
            p.length > 0 && (i.animations = p),
            v.length > 0 && (i.nodes = v)
        }
        return i.object = r,
        i;
        function o(a) {
            const l = [];
            for (const c in a) {
                const u = a[c];
                delete u.metadata,
                l.push(u)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, n=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        n === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
bn.DEFAULT_UP = new z(0,1,0);
bn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
bn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Qn = new z
  , Ri = new z
  , xh = new z
  , Pi = new z
  , Hs = new z
  , Gs = new z
  , J_ = new z
  , Sh = new z
  , wh = new z
  , bh = new z
  , Eh = new Rt
  , Th = new Rt
  , Mh = new Rt;
class oi {
    constructor(e=new z, n=new z, i=new z) {
        this.a = e,
        this.b = n,
        this.c = i
    }
    static getNormal(e, n, i, r) {
        r.subVectors(i, n),
        Qn.subVectors(e, n),
        r.cross(Qn);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, n, i, r, s) {
        Qn.subVectors(r, n),
        Ri.subVectors(i, n),
        xh.subVectors(e, n);
        const o = Qn.dot(Qn)
          , a = Qn.dot(Ri)
          , l = Qn.dot(xh)
          , c = Ri.dot(Ri)
          , u = Ri.dot(xh)
          , d = o * c - a * a;
        if (d === 0)
            return s.set(0, 0, 0),
            null;
        const h = 1 / d
          , p = (c * l - a * u) * h
          , v = (o * u - a * l) * h;
        return s.set(1 - p - v, v, p)
    }
    static containsPoint(e, n, i, r) {
        return this.getBarycoord(e, n, i, r, Pi) === null ? !1 : Pi.x >= 0 && Pi.y >= 0 && Pi.x + Pi.y <= 1
    }
    static getInterpolation(e, n, i, r, s, o, a, l) {
        return this.getBarycoord(e, n, i, r, Pi) === null ? (l.x = 0,
        l.y = 0,
        "z"in l && (l.z = 0),
        "w"in l && (l.w = 0),
        null) : (l.setScalar(0),
        l.addScaledVector(s, Pi.x),
        l.addScaledVector(o, Pi.y),
        l.addScaledVector(a, Pi.z),
        l)
    }
    static getInterpolatedAttribute(e, n, i, r, s, o) {
        return Eh.setScalar(0),
        Th.setScalar(0),
        Mh.setScalar(0),
        Eh.fromBufferAttribute(e, n),
        Th.fromBufferAttribute(e, i),
        Mh.fromBufferAttribute(e, r),
        o.setScalar(0),
        o.addScaledVector(Eh, s.x),
        o.addScaledVector(Th, s.y),
        o.addScaledVector(Mh, s.z),
        o
    }
    static isFrontFacing(e, n, i, r) {
        return Qn.subVectors(i, n),
        Ri.subVectors(e, n),
        Qn.cross(Ri).dot(r) < 0
    }
    set(e, n, i) {
        return this.a.copy(e),
        this.b.copy(n),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, n, i, r) {
        return this.a.copy(e[n]),
        this.b.copy(e[i]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, n, i, r) {
        return this.a.fromBufferAttribute(e, n),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Qn.subVectors(this.c, this.b),
        Ri.subVectors(this.a, this.b),
        Qn.cross(Ri).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return oi.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, n) {
        return oi.getBarycoord(e, this.a, this.b, this.c, n)
    }
    getInterpolation(e, n, i, r, s) {
        return oi.getInterpolation(e, this.a, this.b, this.c, n, i, r, s)
    }
    containsPoint(e) {
        return oi.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return oi.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, n) {
        const i = this.a
          , r = this.b
          , s = this.c;
        let o, a;
        Hs.subVectors(r, i),
        Gs.subVectors(s, i),
        Sh.subVectors(e, i);
        const l = Hs.dot(Sh)
          , c = Gs.dot(Sh);
        if (l <= 0 && c <= 0)
            return n.copy(i);
        wh.subVectors(e, r);
        const u = Hs.dot(wh)
          , d = Gs.dot(wh);
        if (u >= 0 && d <= u)
            return n.copy(r);
        const h = l * d - u * c;
        if (h <= 0 && l >= 0 && u <= 0)
            return o = l / (l - u),
            n.copy(i).addScaledVector(Hs, o);
        bh.subVectors(e, s);
        const p = Hs.dot(bh)
          , v = Gs.dot(bh);
        if (v >= 0 && p <= v)
            return n.copy(s);
        const x = p * c - l * v;
        if (x <= 0 && c >= 0 && v <= 0)
            return a = c / (c - v),
            n.copy(i).addScaledVector(Gs, a);
        const g = u * v - p * d;
        if (g <= 0 && d - u >= 0 && p - v >= 0)
            return J_.subVectors(s, r),
            a = (d - u) / (d - u + (p - v)),
            n.copy(r).addScaledVector(J_, a);
        const f = 1 / (g + x + h);
        return o = x * f,
        a = h * f,
        n.copy(i).addScaledVector(Hs, o).addScaledVector(Gs, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const aE = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , ar = {
    h: 0,
    s: 0,
    l: 0
}
  , fc = {
    h: 0,
    s: 0,
    l: 0
};
function Ah(t, e, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - n) : t
}
class tt {
    constructor(e, n, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, n, i)
    }
    set(e, n, i) {
        if (n === void 0 && i === void 0) {
            const r = e;
            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r)
        } else
            this.setRGB(e, n, i);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, n=Bn) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        Qe.colorSpaceToWorking(this, n),
        this
    }
    setRGB(e, n, i, r=Qe.workingColorSpace) {
        return this.r = e,
        this.g = n,
        this.b = i,
        Qe.colorSpaceToWorking(this, r),
        this
    }
    setHSL(e, n, i, r=Qe.workingColorSpace) {
        if (e = QD(e, 1),
        n = Xe(n, 0, 1),
        i = Xe(i, 0, 1),
        n === 0)
            this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + n) : i + n - i * n
              , o = 2 * i - s;
            this.r = Ah(o, s, e + 1 / 3),
            this.g = Ah(o, s, e),
            this.b = Ah(o, s, e - 1 / 3)
        }
        return Qe.colorSpaceToWorking(this, r),
        this
    }
    setStyle(e, n=Bn) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, n);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, n);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, n);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, n);
            if (o === 6)
                return this.setHex(parseInt(s, 16), n);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, n);
        return this
    }
    setColorName(e, n=Bn) {
        const i = aE[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, n) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = ji(e.r),
        this.g = ji(e.g),
        this.b = ji(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = Eo(e.r),
        this.g = Eo(e.g),
        this.b = Eo(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Bn) {
        return Qe.workingToColorSpace(Qt.copy(this), e),
        Math.round(Xe(Qt.r * 255, 0, 255)) * 65536 + Math.round(Xe(Qt.g * 255, 0, 255)) * 256 + Math.round(Xe(Qt.b * 255, 0, 255))
    }
    getHexString(e=Bn) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, n=Qe.workingColorSpace) {
        Qe.workingToColorSpace(Qt.copy(this), n);
        const i = Qt.r
          , r = Qt.g
          , s = Qt.b
          , o = Math.max(i, r, s)
          , a = Math.min(i, r, s);
        let l, c;
        const u = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const d = o - a;
            switch (c = u <= .5 ? d / (o + a) : d / (2 - o - a),
            o) {
            case i:
                l = (r - s) / d + (r < s ? 6 : 0);
                break;
            case r:
                l = (s - i) / d + 2;
                break;
            case s:
                l = (i - r) / d + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = u,
        e
    }
    getRGB(e, n=Qe.workingColorSpace) {
        return Qe.workingToColorSpace(Qt.copy(this), n),
        e.r = Qt.r,
        e.g = Qt.g,
        e.b = Qt.b,
        e
    }
    getStyle(e=Bn) {
        Qe.workingToColorSpace(Qt.copy(this), e);
        const n = Qt.r
          , i = Qt.g
          , r = Qt.b;
        return e !== Bn ? `color(${e} ${n.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`
    }
    offsetHSL(e, n, i) {
        return this.getHSL(ar),
        this.setHSL(ar.h + e, ar.s + n, ar.l + i)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, n) {
        return this.r = e.r + n.r,
        this.g = e.g + n.g,
        this.b = e.b + n.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, n) {
        return this.r += (e.r - this.r) * n,
        this.g += (e.g - this.g) * n,
        this.b += (e.b - this.b) * n,
        this
    }
    lerpColors(e, n, i) {
        return this.r = e.r + (n.r - e.r) * i,
        this.g = e.g + (n.g - e.g) * i,
        this.b = e.b + (n.b - e.b) * i,
        this
    }
    lerpHSL(e, n) {
        this.getHSL(ar),
        e.getHSL(fc);
        const i = ch(ar.h, fc.h, n)
          , r = ch(ar.s, fc.s, n)
          , s = ch(ar.l, fc.l, n);
        return this.setHSL(i, r, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const n = this.r
          , i = this.g
          , r = this.b
          , s = e.elements;
        return this.r = s[0] * n + s[3] * i + s[6] * r,
        this.g = s[1] * n + s[4] * i + s[7] * r,
        this.b = s[2] * n + s[5] * i + s[8] * r,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, n=0) {
        return this.r = e[n],
        this.g = e[n + 1],
        this.b = e[n + 2],
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this.r,
        e[n + 1] = this.g,
        e[n + 2] = this.b,
        e
    }
    fromBufferAttribute(e, n) {
        return this.r = e.getX(n),
        this.g = e.getY(n),
        this.b = e.getZ(n),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const Qt = new tt;
tt.NAMES = aE;
let mL = 0;
class Rl extends qo {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: mL++
        }),
        this.uuid = Ml(),
        this.name = "",
        this.type = "Material",
        this.blending = bo,
        this.side = Lr,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = up,
        this.blendDst = dp,
        this.blendEquation = rs,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new tt(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = ko,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = F_,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = ks,
        this.stencilZFail = ks,
        this.stencilZPass = ks,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.allowOverride = !0,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const n in e) {
                const i = e[n];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
                    continue
                }
                const r = this[n];
                if (r === void 0) {
                    console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[n] = i
            }
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string";
        n && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.7,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.sheenColorMap && this.sheenColorMap.isTexture && (i.sheenColorMap = this.sheenColorMap.toJSON(e).uuid),
        this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (i.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid),
        this.dispersion !== void 0 && (i.dispersion = this.dispersion),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== bo && (i.blending = this.blending),
        this.side !== Lr && (i.side = this.side),
        this.vertexColors === !0 && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = !0),
        this.blendSrc !== up && (i.blendSrc = this.blendSrc),
        this.blendDst !== dp && (i.blendDst = this.blendDst),
        this.blendEquation !== rs && (i.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
        this.depthFunc !== ko && (i.depthFunc = this.depthFunc),
        this.depthTest === !1 && (i.depthTest = this.depthTest),
        this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== F_ && (i.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== ks && (i.stencilFail = this.stencilFail),
        this.stencilZFail !== ks && (i.stencilZFail = this.stencilZFail),
        this.stencilZPass !== ks && (i.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (i.alphaHash = !0),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (i.forceSinglePass = !0),
        this.wireframe === !0 && (i.wireframe = !0),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = !0),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (n) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (i.textures = s),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const n = e.clippingPlanes;
        let i = null;
        if (n !== null) {
            const r = n.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s)
                i[s] = n[s].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class lE extends Rl {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new tt(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Zi,
        this.combine = $b,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const Pt = new z
  , pc = new st;
let gL = 0;
class Ei {
    constructor(e, n, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        Object.defineProperty(this, "id", {
            value: gL++
        }),
        this.name = "",
        this.array = e,
        this.itemSize = n,
        this.count = e !== void 0 ? e.length / n : 0,
        this.normalized = i,
        this.usage = B_,
        this.updateRanges = [],
        this.gpuType = Bi,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, n) {
        this.updateRanges.push({
            start: e,
            count: n
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, n, i) {
        e *= this.itemSize,
        i *= n.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = n.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let n = 0, i = this.count; n < i; n++)
                pc.fromBufferAttribute(this, n),
                pc.applyMatrix3(e),
                this.setXY(n, pc.x, pc.y);
        else if (this.itemSize === 3)
            for (let n = 0, i = this.count; n < i; n++)
                Pt.fromBufferAttribute(this, n),
                Pt.applyMatrix3(e),
                this.setXYZ(n, Pt.x, Pt.y, Pt.z);
        return this
    }
    applyMatrix4(e) {
        for (let n = 0, i = this.count; n < i; n++)
            Pt.fromBufferAttribute(this, n),
            Pt.applyMatrix4(e),
            this.setXYZ(n, Pt.x, Pt.y, Pt.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let n = 0, i = this.count; n < i; n++)
            Pt.fromBufferAttribute(this, n),
            Pt.applyNormalMatrix(e),
            this.setXYZ(n, Pt.x, Pt.y, Pt.z);
        return this
    }
    transformDirection(e) {
        for (let n = 0, i = this.count; n < i; n++)
            Pt.fromBufferAttribute(this, n),
            Pt.transformDirection(e),
            this.setXYZ(n, Pt.x, Pt.y, Pt.z);
        return this
    }
    set(e, n=0) {
        return this.array.set(e, n),
        this
    }
    getComponent(e, n) {
        let i = this.array[e * this.itemSize + n];
        return this.normalized && (i = la(i, this.array)),
        i
    }
    setComponent(e, n, i) {
        return this.normalized && (i = fn(i, this.array)),
        this.array[e * this.itemSize + n] = i,
        this
    }
    getX(e) {
        let n = this.array[e * this.itemSize];
        return this.normalized && (n = la(n, this.array)),
        n
    }
    setX(e, n) {
        return this.normalized && (n = fn(n, this.array)),
        this.array[e * this.itemSize] = n,
        this
    }
    getY(e) {
        let n = this.array[e * this.itemSize + 1];
        return this.normalized && (n = la(n, this.array)),
        n
    }
    setY(e, n) {
        return this.normalized && (n = fn(n, this.array)),
        this.array[e * this.itemSize + 1] = n,
        this
    }
    getZ(e) {
        let n = this.array[e * this.itemSize + 2];
        return this.normalized && (n = la(n, this.array)),
        n
    }
    setZ(e, n) {
        return this.normalized && (n = fn(n, this.array)),
        this.array[e * this.itemSize + 2] = n,
        this
    }
    getW(e) {
        let n = this.array[e * this.itemSize + 3];
        return this.normalized && (n = la(n, this.array)),
        n
    }
    setW(e, n) {
        return this.normalized && (n = fn(n, this.array)),
        this.array[e * this.itemSize + 3] = n,
        this
    }
    setXY(e, n, i) {
        return e *= this.itemSize,
        this.normalized && (n = fn(n, this.array),
        i = fn(i, this.array)),
        this.array[e + 0] = n,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, n, i, r) {
        return e *= this.itemSize,
        this.normalized && (n = fn(n, this.array),
        i = fn(i, this.array),
        r = fn(r, this.array)),
        this.array[e + 0] = n,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, n, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (n = fn(n, this.array),
        i = fn(i, this.array),
        r = fn(r, this.array),
        s = fn(s, this.array)),
        this.array[e + 0] = n,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== B_ && (e.usage = this.usage),
        e
    }
}
class cE extends Ei {
    constructor(e, n, i) {
        super(new Uint16Array(e), n, i)
    }
}
class uE extends Ei {
    constructor(e, n, i) {
        super(new Uint32Array(e), n, i)
    }
}
class Hi extends Ei {
    constructor(e, n, i) {
        super(new Float32Array(e), n, i)
    }
}
let vL = 0;
const On = new Lt
  , Ch = new bn
  , Ws = new z
  , An = new Cl
  , ha = new Cl
  , jt = new z;
class Qi extends qo {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: vL++
        }),
        this.uuid = Ml(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.indirect = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (iE(e) ? uE : cE)(e,1) : this.index = e,
        this
    }
    setIndirect(e) {
        return this.indirect = e,
        this
    }
    getIndirect() {
        return this.indirect
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, n) {
        return this.attributes[e] = n,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, n, i=0) {
        this.groups.push({
            start: e,
            count: n,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, n) {
        this.drawRange.start = e,
        this.drawRange.count = n
    }
    applyMatrix4(e) {
        const n = this.attributes.position;
        n !== void 0 && (n.applyMatrix4(e),
        n.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new ze().getNormalMatrix(e);
            i.applyNormalMatrix(s),
            i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return On.makeRotationFromQuaternion(e),
        this.applyMatrix4(On),
        this
    }
    rotateX(e) {
        return On.makeRotationX(e),
        this.applyMatrix4(On),
        this
    }
    rotateY(e) {
        return On.makeRotationY(e),
        this.applyMatrix4(On),
        this
    }
    rotateZ(e) {
        return On.makeRotationZ(e),
        this.applyMatrix4(On),
        this
    }
    translate(e, n, i) {
        return On.makeTranslation(e, n, i),
        this.applyMatrix4(On),
        this
    }
    scale(e, n, i) {
        return On.makeScale(e, n, i),
        this.applyMatrix4(On),
        this
    }
    lookAt(e) {
        return Ch.lookAt(e),
        Ch.updateMatrix(),
        this.applyMatrix4(Ch.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Ws).negate(),
        this.translate(Ws.x, Ws.y, Ws.z),
        this
    }
    setFromPoints(e) {
        const n = this.getAttribute("position");
        if (n === void 0) {
            const i = [];
            for (let r = 0, s = e.length; r < s; r++) {
                const o = e[r];
                i.push(o.x, o.y, o.z || 0)
            }
            this.setAttribute("position", new Hi(i,3))
        } else {
            const i = Math.min(e.length, n.count);
            for (let r = 0; r < i; r++) {
                const s = e[r];
                n.setXYZ(r, s.x, s.y, s.z || 0)
            }
            e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
            n.needsUpdate = !0
        }
        return this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Cl);
        const e = this.attributes.position
          , n = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new z(-1 / 0,-1 / 0,-1 / 0), new z(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            n)
                for (let i = 0, r = n.length; i < r; i++) {
                    const s = n[i];
                    An.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (jt.addVectors(this.boundingBox.min, An.min),
                    this.boundingBox.expandByPoint(jt),
                    jt.addVectors(this.boundingBox.max, An.max),
                    this.boundingBox.expandByPoint(jt)) : (this.boundingBox.expandByPoint(An.min),
                    this.boundingBox.expandByPoint(An.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new rd);
        const e = this.attributes.position
          , n = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new z, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (An.setFromBufferAttribute(e),
            n)
                for (let s = 0, o = n.length; s < o; s++) {
                    const a = n[s];
                    ha.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (jt.addVectors(An.min, ha.min),
                    An.expandByPoint(jt),
                    jt.addVectors(An.max, ha.max),
                    An.expandByPoint(jt)) : (An.expandByPoint(ha.min),
                    An.expandByPoint(ha.max))
                }
            An.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                jt.fromBufferAttribute(e, s),
                r = Math.max(r, i.distanceToSquared(jt));
            if (n)
                for (let s = 0, o = n.length; s < o; s++) {
                    const a = n[s]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, u = a.count; c < u; c++)
                        jt.fromBufferAttribute(a, c),
                        l && (Ws.fromBufferAttribute(e, c),
                        jt.add(Ws)),
                        r = Math.max(r, i.distanceToSquared(jt))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , n = this.attributes;
        if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = n.position
          , r = n.normal
          , s = n.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ei(new Float32Array(4 * i.count),4));
        const o = this.getAttribute("tangent")
          , a = []
          , l = [];
        for (let P = 0; P < i.count; P++)
            a[P] = new z,
            l[P] = new z;
        const c = new z
          , u = new z
          , d = new z
          , h = new st
          , p = new st
          , v = new st
          , x = new z
          , g = new z;
        function f(P, M, b) {
            c.fromBufferAttribute(i, P),
            u.fromBufferAttribute(i, M),
            d.fromBufferAttribute(i, b),
            h.fromBufferAttribute(s, P),
            p.fromBufferAttribute(s, M),
            v.fromBufferAttribute(s, b),
            u.sub(c),
            d.sub(c),
            p.sub(h),
            v.sub(h);
            const L = 1 / (p.x * v.y - v.x * p.y);
            isFinite(L) && (x.copy(u).multiplyScalar(v.y).addScaledVector(d, -p.y).multiplyScalar(L),
            g.copy(d).multiplyScalar(p.x).addScaledVector(u, -v.x).multiplyScalar(L),
            a[P].add(x),
            a[M].add(x),
            a[b].add(x),
            l[P].add(g),
            l[M].add(g),
            l[b].add(g))
        }
        let y = this.groups;
        y.length === 0 && (y = [{
            start: 0,
            count: e.count
        }]);
        for (let P = 0, M = y.length; P < M; ++P) {
            const b = y[P]
              , L = b.start
              , F = b.count;
            for (let H = L, Z = L + F; H < Z; H += 3)
                f(e.getX(H + 0), e.getX(H + 1), e.getX(H + 2))
        }
        const _ = new z
          , S = new z
          , T = new z
          , A = new z;
        function C(P) {
            T.fromBufferAttribute(r, P),
            A.copy(T);
            const M = a[P];
            _.copy(M),
            _.sub(T.multiplyScalar(T.dot(M))).normalize(),
            S.crossVectors(A, M);
            const L = S.dot(l[P]) < 0 ? -1 : 1;
            o.setXYZW(P, _.x, _.y, _.z, L)
        }
        for (let P = 0, M = y.length; P < M; ++P) {
            const b = y[P]
              , L = b.start
              , F = b.count;
            for (let H = L, Z = L + F; H < Z; H += 3)
                C(e.getX(H + 0)),
                C(e.getX(H + 1)),
                C(e.getX(H + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , n = this.getAttribute("position");
        if (n !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new Ei(new Float32Array(n.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let h = 0, p = i.count; h < p; h++)
                    i.setXYZ(h, 0, 0, 0);
            const r = new z
              , s = new z
              , o = new z
              , a = new z
              , l = new z
              , c = new z
              , u = new z
              , d = new z;
            if (e)
                for (let h = 0, p = e.count; h < p; h += 3) {
                    const v = e.getX(h + 0)
                      , x = e.getX(h + 1)
                      , g = e.getX(h + 2);
                    r.fromBufferAttribute(n, v),
                    s.fromBufferAttribute(n, x),
                    o.fromBufferAttribute(n, g),
                    u.subVectors(o, s),
                    d.subVectors(r, s),
                    u.cross(d),
                    a.fromBufferAttribute(i, v),
                    l.fromBufferAttribute(i, x),
                    c.fromBufferAttribute(i, g),
                    a.add(u),
                    l.add(u),
                    c.add(u),
                    i.setXYZ(v, a.x, a.y, a.z),
                    i.setXYZ(x, l.x, l.y, l.z),
                    i.setXYZ(g, c.x, c.y, c.z)
                }
            else
                for (let h = 0, p = n.count; h < p; h += 3)
                    r.fromBufferAttribute(n, h + 0),
                    s.fromBufferAttribute(n, h + 1),
                    o.fromBufferAttribute(n, h + 2),
                    u.subVectors(o, s),
                    d.subVectors(r, s),
                    u.cross(d),
                    i.setXYZ(h + 0, u.x, u.y, u.z),
                    i.setXYZ(h + 1, u.x, u.y, u.z),
                    i.setXYZ(h + 2, u.x, u.y, u.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let n = 0, i = e.count; n < i; n++)
            jt.fromBufferAttribute(e, n),
            jt.normalize(),
            e.setXYZ(n, jt.x, jt.y, jt.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , u = a.itemSize
              , d = a.normalized
              , h = new c.constructor(l.length * u);
            let p = 0
              , v = 0;
            for (let x = 0, g = l.length; x < g; x++) {
                a.isInterleavedBufferAttribute ? p = l[x] * a.data.stride + a.offset : p = l[x] * u;
                for (let f = 0; f < u; f++)
                    h[v++] = c[p++]
            }
            return new Ei(h,u,d)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const n = new Qi
          , i = this.index.array
          , r = this.attributes;
        for (const a in r) {
            const l = r[a]
              , c = e(l, i);
            n.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = []
              , c = s[a];
            for (let u = 0, d = c.length; u < d; u++) {
                const h = c[u]
                  , p = e(h, i);
                l.push(p)
            }
            n.morphAttributes[a] = l
        }
        n.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            n.addGroup(c.start, c.count, c.materialIndex)
        }
        return n
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.7,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const n = this.index;
        n !== null && (e.data.index = {
            type: n.array.constructor.name,
            array: Array.prototype.slice.call(n.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , u = [];
            for (let d = 0, h = c.length; d < h; d++) {
                const p = c[d];
                u.push(p.toJSON(e.data))
            }
            u.length > 0 && (r[l] = u,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = a.toJSON()),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const n = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone());
        const r = e.attributes;
        for (const c in r) {
            const u = r[c];
            this.setAttribute(c, u.clone(n))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const u = []
              , d = s[c];
            for (let h = 0, p = d.length; h < p; h++)
                u.push(d[h].clone(n));
            this.morphAttributes[c] = u
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, u = o.length; c < u; c++) {
            const d = o[c];
            this.addGroup(d.start, d.count, d.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Q_ = new Lt
  , Xr = new sE
  , mc = new rd
  , ey = new z
  , gc = new z
  , vc = new z
  , _c = new z
  , Rh = new z
  , yc = new z
  , ty = new z
  , xc = new z;
class zi extends bn {
    constructor(e=new Qi, n=new lE) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = n,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.count = 1,
        this.updateMorphTargets()
    }
    copy(e, n) {
        return super.copy(e, n),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const n = this.geometry.morphAttributes
          , i = Object.keys(n);
        if (i.length > 0) {
            const r = n[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, n) {
        const i = this.geometry
          , r = i.attributes.position
          , s = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        n.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            yc.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const u = a[l]
                  , d = s[l];
                u !== 0 && (Rh.fromBufferAttribute(d, e),
                o ? yc.addScaledVector(Rh, u) : yc.addScaledVector(Rh.sub(n), u))
            }
            n.add(yc)
        }
        return n
    }
    raycast(e, n) {
        const i = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(),
        mc.copy(i.boundingSphere),
        mc.applyMatrix4(s),
        Xr.copy(e.ray).recast(e.near),
        !(mc.containsPoint(Xr.origin) === !1 && (Xr.intersectSphere(mc, ey) === null || Xr.origin.distanceToSquared(ey) > (e.far - e.near) ** 2)) && (Q_.copy(s).invert(),
        Xr.copy(e.ray).applyMatrix4(Q_),
        !(i.boundingBox !== null && Xr.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, n, Xr)))
    }
    _computeIntersections(e, n, i) {
        let r;
        const s = this.geometry
          , o = this.material
          , a = s.index
          , l = s.attributes.position
          , c = s.attributes.uv
          , u = s.attributes.uv1
          , d = s.attributes.normal
          , h = s.groups
          , p = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let v = 0, x = h.length; v < x; v++) {
                    const g = h[v]
                      , f = o[g.materialIndex]
                      , y = Math.max(g.start, p.start)
                      , _ = Math.min(a.count, Math.min(g.start + g.count, p.start + p.count));
                    for (let S = y, T = _; S < T; S += 3) {
                        const A = a.getX(S)
                          , C = a.getX(S + 1)
                          , P = a.getX(S + 2);
                        r = Sc(this, f, e, i, c, u, d, A, C, P),
                        r && (r.faceIndex = Math.floor(S / 3),
                        r.face.materialIndex = g.materialIndex,
                        n.push(r))
                    }
                }
            else {
                const v = Math.max(0, p.start)
                  , x = Math.min(a.count, p.start + p.count);
                for (let g = v, f = x; g < f; g += 3) {
                    const y = a.getX(g)
                      , _ = a.getX(g + 1)
                      , S = a.getX(g + 2);
                    r = Sc(this, o, e, i, c, u, d, y, _, S),
                    r && (r.faceIndex = Math.floor(g / 3),
                    n.push(r))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let v = 0, x = h.length; v < x; v++) {
                    const g = h[v]
                      , f = o[g.materialIndex]
                      , y = Math.max(g.start, p.start)
                      , _ = Math.min(l.count, Math.min(g.start + g.count, p.start + p.count));
                    for (let S = y, T = _; S < T; S += 3) {
                        const A = S
                          , C = S + 1
                          , P = S + 2;
                        r = Sc(this, f, e, i, c, u, d, A, C, P),
                        r && (r.faceIndex = Math.floor(S / 3),
                        r.face.materialIndex = g.materialIndex,
                        n.push(r))
                    }
                }
            else {
                const v = Math.max(0, p.start)
                  , x = Math.min(l.count, p.start + p.count);
                for (let g = v, f = x; g < f; g += 3) {
                    const y = g
                      , _ = g + 1
                      , S = g + 2;
                    r = Sc(this, o, e, i, c, u, d, y, _, S),
                    r && (r.faceIndex = Math.floor(g / 3),
                    n.push(r))
                }
            }
    }
}
function _L(t, e, n, i, r, s, o, a) {
    let l;
    if (e.side === Sn ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === Lr, a),
    l === null)
        return null;
    xc.copy(a),
    xc.applyMatrix4(t.matrixWorld);
    const c = n.ray.origin.distanceTo(xc);
    return c < n.near || c > n.far ? null : {
        distance: c,
        point: xc.clone(),
        object: t
    }
}
function Sc(t, e, n, i, r, s, o, a, l, c) {
    t.getVertexPosition(a, gc),
    t.getVertexPosition(l, vc),
    t.getVertexPosition(c, _c);
    const u = _L(t, e, n, i, gc, vc, _c, ty);
    if (u) {
        const d = new z;
        oi.getBarycoord(ty, gc, vc, _c, d),
        r && (u.uv = oi.getInterpolatedAttribute(r, a, l, c, d, new st)),
        s && (u.uv1 = oi.getInterpolatedAttribute(s, a, l, c, d, new st)),
        o && (u.normal = oi.getInterpolatedAttribute(o, a, l, c, d, new z),
        u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
        const h = {
            a,
            b: l,
            c,
            normal: new z,
            materialIndex: 0
        };
        oi.getNormal(gc, vc, _c, h.normal),
        u.face = h,
        u.barycoord = d
    }
    return u
}
class Pl extends Qi {
    constructor(e=1, n=1, i=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: n,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = []
          , c = []
          , u = []
          , d = [];
        let h = 0
          , p = 0;
        v("z", "y", "x", -1, -1, i, n, e, o, s, 0),
        v("z", "y", "x", 1, -1, i, n, -e, o, s, 1),
        v("x", "z", "y", 1, 1, e, i, n, r, o, 2),
        v("x", "z", "y", 1, -1, e, i, -n, r, o, 3),
        v("x", "y", "z", 1, -1, e, n, i, r, s, 4),
        v("x", "y", "z", -1, -1, e, n, -i, r, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new Hi(c,3)),
        this.setAttribute("normal", new Hi(u,3)),
        this.setAttribute("uv", new Hi(d,2));
        function v(x, g, f, y, _, S, T, A, C, P, M) {
            const b = S / C
              , L = T / P
              , F = S / 2
              , H = T / 2
              , Z = A / 2
              , $ = C + 1
              , q = P + 1;
            let B = 0
              , D = 0;
            const G = new z;
            for (let Y = 0; Y < q; Y++) {
                const le = Y * L - H;
                for (let xe = 0; xe < $; xe++) {
                    const qe = xe * b - F;
                    G[x] = qe * y,
                    G[g] = le * _,
                    G[f] = Z,
                    c.push(G.x, G.y, G.z),
                    G[x] = 0,
                    G[g] = 0,
                    G[f] = A > 0 ? 1 : -1,
                    u.push(G.x, G.y, G.z),
                    d.push(xe / C),
                    d.push(1 - Y / P),
                    B += 1
                }
            }
            for (let Y = 0; Y < P; Y++)
                for (let le = 0; le < C; le++) {
                    const xe = h + le + $ * Y
                      , qe = h + le + $ * (Y + 1)
                      , Ke = h + (le + 1) + $ * (Y + 1)
                      , We = h + (le + 1) + $ * Y;
                    l.push(xe, qe, We),
                    l.push(qe, Ke, We),
                    D += 6
                }
            a.addGroup(p, D, M),
            p += D,
            h += B
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Pl(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function Bo(t) {
    const e = {};
    for (const n in t) {
        e[n] = {};
        for (const i in t[n]) {
            const r = t[n][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[n][i] = null) : e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
        }
    }
    return e
}
function on(t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const i = Bo(t[n]);
        for (const r in i)
            e[r] = i[r]
    }
    return e
}
function yL(t) {
    const e = [];
    for (let n = 0; n < t.length; n++)
        e.push(t[n].clone());
    return e
}
function dE(t) {
    const e = t.getRenderTarget();
    return e === null ? t.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Qe.workingColorSpace
}
const xL = {
    clone: Bo,
    merge: on
};
var SL = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , wL = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ir extends Rl {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = SL,
        this.fragmentShader = wL,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Bo(e.uniforms),
        this.uniformsGroups = yL(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        n.glslVersion = this.glslVersion,
        n.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? n.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? n.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? n.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? n.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? n.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? n.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? n.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : n.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (n.defines = this.defines),
        n.vertexShader = this.vertexShader,
        n.fragmentShader = this.fragmentShader,
        n.lights = this.lights,
        n.clipping = this.clipping;
        const i = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (n.extensions = i),
        n
    }
}
class hE extends bn {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Lt,
        this.projectionMatrix = new Lt,
        this.projectionMatrixInverse = new Lt,
        this.coordinateSystem = yi,
        this._reversedDepth = !1
    }
    get reversedDepth() {
        return this._reversedDepth
    }
    copy(e, n) {
        return super.copy(e, n),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, n) {
        super.updateWorldMatrix(e, n),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const lr = new z
  , ny = new st
  , iy = new st;
class jn extends hE {
    constructor(e=50, n=1, i=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = r,
        this.focus = 10,
        this.aspect = n,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, n) {
        return super.copy(e, n),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const n = .5 * this.getFilmHeight() / e;
        this.fov = Zp * 2 * Math.atan(n),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(lh * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Zp * 2 * Math.atan(Math.tan(lh * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, n, i) {
        lr.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        n.set(lr.x, lr.y).multiplyScalar(-e / lr.z),
        lr.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        i.set(lr.x, lr.y).multiplyScalar(-e / lr.z)
    }
    getViewSize(e, n) {
        return this.getViewBounds(e, ny, iy),
        n.subVectors(iy, ny)
    }
    setViewOffset(e, n, i, r, s, o) {
        this.aspect = e / n,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = n,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let n = e * Math.tan(lh * .5 * this.fov) / this.zoom
          , i = 2 * n
          , r = this.aspect * i
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            s += o.offsetX * r / l,
            n -= o.offsetY * i / c,
            r *= o.width / l,
            i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, n, n - i, e, this.far, this.coordinateSystem, this.reversedDepth),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.fov = this.fov,
        n.object.zoom = this.zoom,
        n.object.near = this.near,
        n.object.far = this.far,
        n.object.focus = this.focus,
        n.object.aspect = this.aspect,
        this.view !== null && (n.object.view = Object.assign({}, this.view)),
        n.object.filmGauge = this.filmGauge,
        n.object.filmOffset = this.filmOffset,
        n
    }
}
const $s = -90
  , Xs = 1;
class bL extends bn {
    constructor(e, n, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const r = new jn($s,Xs,e,n);
        r.layers = this.layers,
        this.add(r);
        const s = new jn($s,Xs,e,n);
        s.layers = this.layers,
        this.add(s);
        const o = new jn($s,Xs,e,n);
        o.layers = this.layers,
        this.add(o);
        const a = new jn($s,Xs,e,n);
        a.layers = this.layers,
        this.add(a);
        const l = new jn($s,Xs,e,n);
        l.layers = this.layers,
        this.add(l);
        const c = new jn($s,Xs,e,n);
        c.layers = this.layers,
        this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , n = this.children.concat()
          , [i,r,s,o,a,l] = n;
        for (const c of n)
            this.remove(c);
        if (e === yi)
            i.up.set(0, 1, 0),
            i.lookAt(1, 0, 0),
            r.up.set(0, 1, 0),
            r.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, -1);
        else if (e === Nu)
            i.up.set(0, -1, 0),
            i.lookAt(-1, 0, 0),
            r.up.set(0, -1, 0),
            r.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of n)
            this.add(c),
            c.updateMatrixWorld()
    }
    update(e, n) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: i, activeMipmapLevel: r} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,a,l,c,u] = this.children
          , d = e.getRenderTarget()
          , h = e.getActiveCubeFace()
          , p = e.getActiveMipmapLevel()
          , v = e.xr.enabled;
        e.xr.enabled = !1;
        const x = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0, r),
        e.render(n, s),
        e.setRenderTarget(i, 1, r),
        e.render(n, o),
        e.setRenderTarget(i, 2, r),
        e.render(n, a),
        e.setRenderTarget(i, 3, r),
        e.render(n, l),
        e.setRenderTarget(i, 4, r),
        e.render(n, c),
        i.texture.generateMipmaps = x,
        e.setRenderTarget(i, 5, r),
        e.render(n, u),
        e.setRenderTarget(d, h, p),
        e.xr.enabled = v,
        i.texture.needsPMREMUpdate = !0
    }
}
class fE extends wn {
    constructor(e=[], n=Uo, i, r, s, o, a, l, c, u) {
        super(e, n, i, r, s, o, a, l, c, u),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class EL extends bs {
    constructor(e=1, n={}) {
        super(e, e, n),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [i, i, i, i, i, i];
        this.texture = new fE(r),
        this._setTextureOptions(n),
        this.texture.isRenderTargetTexture = !0
    }
    fromEquirectangularTexture(e, n) {
        this.texture.type = n.type,
        this.texture.colorSpace = n.colorSpace,
        this.texture.generateMipmaps = n.generateMipmaps,
        this.texture.minFilter = n.minFilter,
        this.texture.magFilter = n.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , r = new Pl(5,5,5)
          , s = new Ir({
            name: "CubemapFromEquirect",
            uniforms: Bo(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: Sn,
            blending: Ar
        });
        s.uniforms.tEquirect.value = n;
        const o = new zi(r,s)
          , a = n.minFilter;
        return n.minFilter === hs && (n.minFilter = _i),
        new bL(1,10,this).update(e, o),
        n.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, n=!0, i=!0, r=!0) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(n, i, r);
        e.setRenderTarget(s)
    }
}
class wc extends bn {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const TL = {
    type: "move"
};
class Ph {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new wc,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new wc,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new z,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new z),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new wc,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new z,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new z),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const n = this._hand;
            if (n)
                for (const i of e.hand.values())
                    this._getHandJoint(n, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, n, i) {
        let r = null
          , s = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && n.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const x of e.hand.values()) {
                    const g = n.getJointPose(x, i)
                      , f = this._getHandJoint(c, x);
                    g !== null && (f.matrix.fromArray(g.transform.matrix),
                    f.matrix.decompose(f.position, f.rotation, f.scale),
                    f.matrixWorldNeedsUpdate = !0,
                    f.jointRadius = g.radius),
                    f.visible = g !== null
                }
                const u = c.joints["index-finger-tip"]
                  , d = c.joints["thumb-tip"]
                  , h = u.position.distanceTo(d.position)
                  , p = .02
                  , v = .005;
                c.inputState.pinching && h > p + v ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && h <= p - v && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (s = n.getPose(e.gripSpace, i),
                s !== null && (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                l.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                s.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (r = n.getPose(e.targetRaySpace, i),
            r === null && s !== null && (r = s),
            r !== null && (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            r.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
            r.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(TL)))
        }
        return a !== null && (a.visible = r !== null),
        l !== null && (l.visible = s !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, n) {
        if (e.joints[n.jointName] === void 0) {
            const i = new wc;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[n.jointName] = i,
            e.add(i)
        }
        return e.joints[n.jointName]
    }
}
class ML extends bn {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Zi,
        this.environmentIntensity = 1,
        this.environmentRotation = new Zi,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, n) {
        return super.copy(e, n),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return this.fog !== null && (n.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity),
        n.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity),
        n.object.environmentRotation = this.environmentRotation.toArray(),
        n
    }
}
const Nh = new z
  , AL = new z
  , CL = new ze;
class ts {
    constructor(e=new z(1,0,0), n=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = n
    }
    set(e, n) {
        return this.normal.copy(e),
        this.constant = n,
        this
    }
    setComponents(e, n, i, r) {
        return this.normal.set(e, n, i),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, n) {
        return this.normal.copy(e),
        this.constant = -n.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, n, i) {
        const r = Nh.subVectors(i, n).cross(AL.subVectors(e, n)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, n) {
        return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, n) {
        const i = e.delta(Nh)
          , r = this.normal.dot(i);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : n.copy(e.start).addScaledVector(i, s)
    }
    intersectsLine(e) {
        const n = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return n < 0 && i > 0 || i < 0 && n > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, n) {
        const i = n || CL.getNormalMatrix(e)
          , r = this.coplanarPoint(Nh).applyMatrix4(e)
          , s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const qr = new rd
  , RL = new st(.5,.5)
  , bc = new z;
class pE {
    constructor(e=new ts, n=new ts, i=new ts, r=new ts, s=new ts, o=new ts) {
        this.planes = [e, n, i, r, s, o]
    }
    set(e, n, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(n),
        a[2].copy(i),
        a[3].copy(r),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const n = this.planes;
        for (let i = 0; i < 6; i++)
            n[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, n=yi, i=!1) {
        const r = this.planes
          , s = e.elements
          , o = s[0]
          , a = s[1]
          , l = s[2]
          , c = s[3]
          , u = s[4]
          , d = s[5]
          , h = s[6]
          , p = s[7]
          , v = s[8]
          , x = s[9]
          , g = s[10]
          , f = s[11]
          , y = s[12]
          , _ = s[13]
          , S = s[14]
          , T = s[15];
        if (r[0].setComponents(c - o, p - u, f - v, T - y).normalize(),
        r[1].setComponents(c + o, p + u, f + v, T + y).normalize(),
        r[2].setComponents(c + a, p + d, f + x, T + _).normalize(),
        r[3].setComponents(c - a, p - d, f - x, T - _).normalize(),
        i)
            r[4].setComponents(l, h, g, S).normalize(),
            r[5].setComponents(c - l, p - h, f - g, T - S).normalize();
        else if (r[4].setComponents(c - l, p - h, f - g, T - S).normalize(),
        n === yi)
            r[5].setComponents(c + l, p + h, f + g, T + S).normalize();
        else if (n === Nu)
            r[5].setComponents(l, h, g, S).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            qr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const n = e.geometry;
            n.boundingSphere === null && n.computeBoundingSphere(),
            qr.copy(n.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(qr)
    }
    intersectsSprite(e) {
        qr.center.set(0, 0, 0);
        const n = RL.distanceTo(e.center);
        return qr.radius = .7071067811865476 + n,
        qr.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(qr)
    }
    intersectsSphere(e) {
        const n = this.planes
          , i = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (n[s].distanceToPoint(i) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const n = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = n[i];
            if (bc.x = r.normal.x > 0 ? e.max.x : e.min.x,
            bc.y = r.normal.y > 0 ? e.max.y : e.min.y,
            bc.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(bc) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const n = this.planes;
        for (let i = 0; i < 6; i++)
            if (n[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class mE extends Rl {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new tt(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const ry = new Lt
  , Jp = new sE
  , Ec = new rd
  , Tc = new z;
class PL extends bn {
    constructor(e=new Qi, n=new mE) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = n,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, n) {
        return super.copy(e, n),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, n) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Points.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        Ec.copy(i.boundingSphere),
        Ec.applyMatrix4(r),
        Ec.radius += s,
        e.ray.intersectsSphere(Ec) === !1)
            return;
        ry.copy(r).invert(),
        Jp.copy(e.ray).applyMatrix4(ry);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = i.index
          , d = i.attributes.position;
        if (c !== null) {
            const h = Math.max(0, o.start)
              , p = Math.min(c.count, o.start + o.count);
            for (let v = h, x = p; v < x; v++) {
                const g = c.getX(v);
                Tc.fromBufferAttribute(d, g),
                sy(Tc, g, l, r, e, n, this)
            }
        } else {
            const h = Math.max(0, o.start)
              , p = Math.min(d.count, o.start + o.count);
            for (let v = h, x = p; v < x; v++)
                Tc.fromBufferAttribute(d, v),
                sy(Tc, v, l, r, e, n, this)
        }
    }
    updateMorphTargets() {
        const n = this.geometry.morphAttributes
          , i = Object.keys(n);
        if (i.length > 0) {
            const r = n[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function sy(t, e, n, i, r, s, o) {
    const a = Jp.distanceSqToPoint(t);
    if (a < n) {
        const l = new z;
        Jp.closestPointToPoint(t, l),
        l.applyMatrix4(i);
        const c = r.ray.origin.distanceTo(l);
        if (c < r.near || c > r.far)
            return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: o
        })
    }
}
class gE extends wn {
    constructor(e, n, i=ws, r, s, o, a=ui, l=ui, c, u=cl, d=1) {
        if (u !== cl && u !== ul)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        const h = {
            width: e,
            height: n,
            depth: d
        };
        super(h, r, s, o, a, l, u, i, c),
        this.isDepthTexture = !0,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.source = new Og(Object.assign({}, e.image)),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return this.compareFunction !== null && (n.compareFunction = this.compareFunction),
        n
    }
}
class vE extends wn {
    constructor(e=null) {
        super(),
        this.sourceTexture = e,
        this.isExternalTexture = !0
    }
    copy(e) {
        return super.copy(e),
        this.sourceTexture = e.sourceTexture,
        this
    }
}
class sd extends Qi {
    constructor(e=1, n=1, i=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: n,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2
          , o = n / 2
          , a = Math.floor(i)
          , l = Math.floor(r)
          , c = a + 1
          , u = l + 1
          , d = e / a
          , h = n / l
          , p = []
          , v = []
          , x = []
          , g = [];
        for (let f = 0; f < u; f++) {
            const y = f * h - o;
            for (let _ = 0; _ < c; _++) {
                const S = _ * d - s;
                v.push(S, -y, 0),
                x.push(0, 0, 1),
                g.push(_ / a),
                g.push(1 - f / l)
            }
        }
        for (let f = 0; f < l; f++)
            for (let y = 0; y < a; y++) {
                const _ = y + c * f
                  , S = y + c * (f + 1)
                  , T = y + 1 + c * (f + 1)
                  , A = y + 1 + c * f;
                p.push(_, S, A),
                p.push(S, T, A)
            }
        this.setIndex(p),
        this.setAttribute("position", new Hi(v,3)),
        this.setAttribute("normal", new Hi(x,3)),
        this.setAttribute("uv", new Hi(g,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new sd(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
class NL extends Rl {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = jD,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class DL extends Rl {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
class LL extends hE {
    constructor(e=-1, n=1, i=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = n,
        this.top = i,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, n) {
        return super.copy(e, n),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, n, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = n,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , n = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = i - e
          , o = i + e
          , a = r + n
          , l = r - n;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX,
            o = s + c * this.view.width,
            a -= u * this.view.offsetY,
            l = a - u * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem, this.reversedDepth),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.zoom = this.zoom,
        n.object.left = this.left,
        n.object.right = this.right,
        n.object.top = this.top,
        n.object.bottom = this.bottom,
        n.object.near = this.near,
        n.object.far = this.far,
        this.view !== null && (n.object.view = Object.assign({}, this.view)),
        n
    }
}
class IL extends jn {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.isMultiViewCamera = !1,
        this.cameras = e
    }
}
class kL {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = performance.now(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const n = performance.now();
            e = (n - this.oldTime) / 1e3,
            this.oldTime = n,
            this.elapsedTime += e
        }
        return e
    }
}
function oy(t, e, n, i) {
    const r = UL(i);
    switch (n) {
    case Jb:
        return t * e;
    case eE:
        return t * e / r.components * r.byteLength;
    case Ig:
        return t * e / r.components * r.byteLength;
    case tE:
        return t * e * 2 / r.components * r.byteLength;
    case kg:
        return t * e * 2 / r.components * r.byteLength;
    case Qb:
        return t * e * 3 / r.components * r.byteLength;
    case ai:
        return t * e * 4 / r.components * r.byteLength;
    case Ug:
        return t * e * 4 / r.components * r.byteLength;
    case $c:
    case Xc:
        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case qc:
    case Kc:
        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Ep:
    case Mp:
        return Math.max(t, 16) * Math.max(e, 8) / 4;
    case bp:
    case Tp:
        return Math.max(t, 8) * Math.max(e, 8) / 2;
    case Ap:
    case Cp:
        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Rp:
        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Pp:
        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Np:
        return Math.floor((t + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Dp:
        return Math.floor((t + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Lp:
        return Math.floor((t + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Ip:
        return Math.floor((t + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case kp:
        return Math.floor((t + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Up:
        return Math.floor((t + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Op:
        return Math.floor((t + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Fp:
        return Math.floor((t + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Bp:
        return Math.floor((t + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case zp:
        return Math.floor((t + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Vp:
        return Math.floor((t + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case jp:
        return Math.floor((t + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Hp:
        return Math.floor((t + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Gp:
    case Wp:
    case $p:
        return Math.ceil(t / 4) * Math.ceil(e / 4) * 16;
    case Xp:
    case qp:
        return Math.ceil(t / 4) * Math.ceil(e / 4) * 8;
    case Kp:
    case Yp:
        return Math.ceil(t / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${n} format.`)
}
function UL(t) {
    switch (t) {
    case Yi:
    case qb:
        return {
            byteLength: 1,
            components: 1
        };
    case al:
    case Kb:
    case Tl:
        return {
            byteLength: 2,
            components: 1
        };
    case Dg:
    case Lg:
        return {
            byteLength: 2,
            components: 4
        };
    case ws:
    case Ng:
    case Bi:
        return {
            byteLength: 4,
            components: 1
        };
    case Yb:
    case Zb:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${t}.`)
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: Pg
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Pg);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function _E() {
    let t = null
      , e = !1
      , n = null
      , i = null;
    function r(s, o) {
        n(s, o),
        i = t.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && n !== null && (i = t.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            t.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(s) {
            n = s
        },
        setContext: function(s) {
            t = s
        }
    }
}
function OL(t) {
    const e = new WeakMap;
    function n(a, l) {
        const c = a.array
          , u = a.usage
          , d = c.byteLength
          , h = t.createBuffer();
        t.bindBuffer(l, h),
        t.bufferData(l, c, u),
        a.onUploadCallback();
        let p;
        if (c instanceof Float32Array)
            p = t.FLOAT;
        else if (typeof Float16Array < "u" && c instanceof Float16Array)
            p = t.HALF_FLOAT;
        else if (c instanceof Uint16Array)
            a.isFloat16BufferAttribute ? p = t.HALF_FLOAT : p = t.UNSIGNED_SHORT;
        else if (c instanceof Int16Array)
            p = t.SHORT;
        else if (c instanceof Uint32Array)
            p = t.UNSIGNED_INT;
        else if (c instanceof Int32Array)
            p = t.INT;
        else if (c instanceof Int8Array)
            p = t.BYTE;
        else if (c instanceof Uint8Array)
            p = t.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray)
            p = t.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
            buffer: h,
            type: p,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: d
        }
    }
    function i(a, l, c) {
        const u = l.array
          , d = l.updateRanges;
        if (t.bindBuffer(c, a),
        d.length === 0)
            t.bufferSubData(c, 0, u);
        else {
            d.sort( (p, v) => p.start - v.start);
            let h = 0;
            for (let p = 1; p < d.length; p++) {
                const v = d[h]
                  , x = d[p];
                x.start <= v.start + v.count + 1 ? v.count = Math.max(v.count, x.start + x.count - v.start) : (++h,
                d[h] = x)
            }
            d.length = h + 1;
            for (let p = 0, v = d.length; p < v; p++) {
                const x = d[p];
                t.bufferSubData(c, x.start * u.BYTES_PER_ELEMENT, u, x.start, x.count)
            }
            l.clearUpdateRanges()
        }
        l.onUploadCallback()
    }
    function r(a) {
        return a.isInterleavedBufferAttribute && (a = a.data),
        e.get(a)
    }
    function s(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const l = e.get(a);
        l && (t.deleteBuffer(l.buffer),
        e.delete(a))
    }
    function o(a, l) {
        if (a.isInterleavedBufferAttribute && (a = a.data),
        a.isGLBufferAttribute) {
            const u = e.get(a);
            (!u || u.version < a.version) && e.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        const c = e.get(a);
        if (c === void 0)
            e.set(a, n(a, l));
        else if (c.version < a.version) {
            if (c.size !== a.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            i(c.buffer, a, l),
            c.version = a.version
        }
    }
    return {
        get: r,
        remove: s,
        update: o
    }
}
var FL = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , BL = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , zL = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , VL = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , jL = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , HL = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , GL = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , WL = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , $L = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , XL = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , qL = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , KL = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , YL = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , ZL = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , JL = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , QL = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , eI = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , tI = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , nI = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , iI = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , rI = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , sI = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , oI = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , aI = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , lI = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , cI = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , uI = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , dI = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , hI = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , fI = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , pI = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , mI = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , gI = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , vI = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , _I = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , yI = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , xI = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , SI = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , wI = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , bI = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , EI = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , TI = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , MI = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , AI = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , CI = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , RI = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , PI = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , NI = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , DI = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , LI = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , II = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , kI = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , UI = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , OI = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , FI = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , BI = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , zI = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , VI = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , jI = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , HI = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , GI = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , WI = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , $I = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , XI = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , qI = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , KI = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , YI = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , ZI = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , JI = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , QI = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , e3 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , t3 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , n3 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , i3 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , r3 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , s3 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , o3 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , a3 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , l3 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , c3 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , u3 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , d3 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , h3 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , f3 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , p3 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , m3 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , g3 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , v3 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , _3 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , y3 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , x3 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , S3 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , w3 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , b3 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , E3 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , T3 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , M3 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , A3 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , C3 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , R3 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , P3 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , N3 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , D3 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , L3 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , I3 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , k3 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , U3 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const O3 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , F3 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , B3 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , z3 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , V3 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , j3 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , H3 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , G3 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , W3 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , $3 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , X3 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , q3 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , K3 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , Y3 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , Z3 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , J3 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , Q3 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , ek = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , tk = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , nk = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , ik = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , rk = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , sk = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , ok = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , ak = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , lk = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , ck = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , uk = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , dk = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , hk = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , fk = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , pk = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , mk = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , gk = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , je = {
    alphahash_fragment: FL,
    alphahash_pars_fragment: BL,
    alphamap_fragment: zL,
    alphamap_pars_fragment: VL,
    alphatest_fragment: jL,
    alphatest_pars_fragment: HL,
    aomap_fragment: GL,
    aomap_pars_fragment: WL,
    batching_pars_vertex: $L,
    batching_vertex: XL,
    begin_vertex: qL,
    beginnormal_vertex: KL,
    bsdfs: YL,
    iridescence_fragment: ZL,
    bumpmap_pars_fragment: JL,
    clipping_planes_fragment: QL,
    clipping_planes_pars_fragment: eI,
    clipping_planes_pars_vertex: tI,
    clipping_planes_vertex: nI,
    color_fragment: iI,
    color_pars_fragment: rI,
    color_pars_vertex: sI,
    color_vertex: oI,
    common: aI,
    cube_uv_reflection_fragment: lI,
    defaultnormal_vertex: cI,
    displacementmap_pars_vertex: uI,
    displacementmap_vertex: dI,
    emissivemap_fragment: hI,
    emissivemap_pars_fragment: fI,
    colorspace_fragment: pI,
    colorspace_pars_fragment: mI,
    envmap_fragment: gI,
    envmap_common_pars_fragment: vI,
    envmap_pars_fragment: _I,
    envmap_pars_vertex: yI,
    envmap_physical_pars_fragment: PI,
    envmap_vertex: xI,
    fog_vertex: SI,
    fog_pars_vertex: wI,
    fog_fragment: bI,
    fog_pars_fragment: EI,
    gradientmap_pars_fragment: TI,
    lightmap_pars_fragment: MI,
    lights_lambert_fragment: AI,
    lights_lambert_pars_fragment: CI,
    lights_pars_begin: RI,
    lights_toon_fragment: NI,
    lights_toon_pars_fragment: DI,
    lights_phong_fragment: LI,
    lights_phong_pars_fragment: II,
    lights_physical_fragment: kI,
    lights_physical_pars_fragment: UI,
    lights_fragment_begin: OI,
    lights_fragment_maps: FI,
    lights_fragment_end: BI,
    logdepthbuf_fragment: zI,
    logdepthbuf_pars_fragment: VI,
    logdepthbuf_pars_vertex: jI,
    logdepthbuf_vertex: HI,
    map_fragment: GI,
    map_pars_fragment: WI,
    map_particle_fragment: $I,
    map_particle_pars_fragment: XI,
    metalnessmap_fragment: qI,
    metalnessmap_pars_fragment: KI,
    morphinstance_vertex: YI,
    morphcolor_vertex: ZI,
    morphnormal_vertex: JI,
    morphtarget_pars_vertex: QI,
    morphtarget_vertex: e3,
    normal_fragment_begin: t3,
    normal_fragment_maps: n3,
    normal_pars_fragment: i3,
    normal_pars_vertex: r3,
    normal_vertex: s3,
    normalmap_pars_fragment: o3,
    clearcoat_normal_fragment_begin: a3,
    clearcoat_normal_fragment_maps: l3,
    clearcoat_pars_fragment: c3,
    iridescence_pars_fragment: u3,
    opaque_fragment: d3,
    packing: h3,
    premultiplied_alpha_fragment: f3,
    project_vertex: p3,
    dithering_fragment: m3,
    dithering_pars_fragment: g3,
    roughnessmap_fragment: v3,
    roughnessmap_pars_fragment: _3,
    shadowmap_pars_fragment: y3,
    shadowmap_pars_vertex: x3,
    shadowmap_vertex: S3,
    shadowmask_pars_fragment: w3,
    skinbase_vertex: b3,
    skinning_pars_vertex: E3,
    skinning_vertex: T3,
    skinnormal_vertex: M3,
    specularmap_fragment: A3,
    specularmap_pars_fragment: C3,
    tonemapping_fragment: R3,
    tonemapping_pars_fragment: P3,
    transmission_fragment: N3,
    transmission_pars_fragment: D3,
    uv_pars_fragment: L3,
    uv_pars_vertex: I3,
    uv_vertex: k3,
    worldpos_vertex: U3,
    background_vert: O3,
    background_frag: F3,
    backgroundCube_vert: B3,
    backgroundCube_frag: z3,
    cube_vert: V3,
    cube_frag: j3,
    depth_vert: H3,
    depth_frag: G3,
    distanceRGBA_vert: W3,
    distanceRGBA_frag: $3,
    equirect_vert: X3,
    equirect_frag: q3,
    linedashed_vert: K3,
    linedashed_frag: Y3,
    meshbasic_vert: Z3,
    meshbasic_frag: J3,
    meshlambert_vert: Q3,
    meshlambert_frag: ek,
    meshmatcap_vert: tk,
    meshmatcap_frag: nk,
    meshnormal_vert: ik,
    meshnormal_frag: rk,
    meshphong_vert: sk,
    meshphong_frag: ok,
    meshphysical_vert: ak,
    meshphysical_frag: lk,
    meshtoon_vert: ck,
    meshtoon_frag: uk,
    points_vert: dk,
    points_frag: hk,
    shadow_vert: fk,
    shadow_frag: pk,
    sprite_vert: mk,
    sprite_frag: gk
}
  , ue = {
    common: {
        diffuse: {
            value: new tt(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new ze
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new ze
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new ze
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new ze
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new ze
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new ze
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new ze
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new ze
        },
        normalScale: {
            value: new st(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new ze
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new ze
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new ze
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new ze
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new tt(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new tt(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new ze
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new ze
        }
    },
    sprite: {
        diffuse: {
            value: new tt(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new st(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new ze
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new ze
        },
        alphaTest: {
            value: 0
        }
    }
}
  , gi = {
    basic: {
        uniforms: on([ue.common, ue.specularmap, ue.envmap, ue.aomap, ue.lightmap, ue.fog]),
        vertexShader: je.meshbasic_vert,
        fragmentShader: je.meshbasic_frag
    },
    lambert: {
        uniforms: on([ue.common, ue.specularmap, ue.envmap, ue.aomap, ue.lightmap, ue.emissivemap, ue.bumpmap, ue.normalmap, ue.displacementmap, ue.fog, ue.lights, {
            emissive: {
                value: new tt(0)
            }
        }]),
        vertexShader: je.meshlambert_vert,
        fragmentShader: je.meshlambert_frag
    },
    phong: {
        uniforms: on([ue.common, ue.specularmap, ue.envmap, ue.aomap, ue.lightmap, ue.emissivemap, ue.bumpmap, ue.normalmap, ue.displacementmap, ue.fog, ue.lights, {
            emissive: {
                value: new tt(0)
            },
            specular: {
                value: new tt(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: je.meshphong_vert,
        fragmentShader: je.meshphong_frag
    },
    standard: {
        uniforms: on([ue.common, ue.envmap, ue.aomap, ue.lightmap, ue.emissivemap, ue.bumpmap, ue.normalmap, ue.displacementmap, ue.roughnessmap, ue.metalnessmap, ue.fog, ue.lights, {
            emissive: {
                value: new tt(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: je.meshphysical_vert,
        fragmentShader: je.meshphysical_frag
    },
    toon: {
        uniforms: on([ue.common, ue.aomap, ue.lightmap, ue.emissivemap, ue.bumpmap, ue.normalmap, ue.displacementmap, ue.gradientmap, ue.fog, ue.lights, {
            emissive: {
                value: new tt(0)
            }
        }]),
        vertexShader: je.meshtoon_vert,
        fragmentShader: je.meshtoon_frag
    },
    matcap: {
        uniforms: on([ue.common, ue.bumpmap, ue.normalmap, ue.displacementmap, ue.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: je.meshmatcap_vert,
        fragmentShader: je.meshmatcap_frag
    },
    points: {
        uniforms: on([ue.points, ue.fog]),
        vertexShader: je.points_vert,
        fragmentShader: je.points_frag
    },
    dashed: {
        uniforms: on([ue.common, ue.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: je.linedashed_vert,
        fragmentShader: je.linedashed_frag
    },
    depth: {
        uniforms: on([ue.common, ue.displacementmap]),
        vertexShader: je.depth_vert,
        fragmentShader: je.depth_frag
    },
    normal: {
        uniforms: on([ue.common, ue.bumpmap, ue.normalmap, ue.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: je.meshnormal_vert,
        fragmentShader: je.meshnormal_frag
    },
    sprite: {
        uniforms: on([ue.sprite, ue.fog]),
        vertexShader: je.sprite_vert,
        fragmentShader: je.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new ze
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: je.background_vert,
        fragmentShader: je.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new ze
            }
        },
        vertexShader: je.backgroundCube_vert,
        fragmentShader: je.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: je.cube_vert,
        fragmentShader: je.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: je.equirect_vert,
        fragmentShader: je.equirect_frag
    },
    distanceRGBA: {
        uniforms: on([ue.common, ue.displacementmap, {
            referencePosition: {
                value: new z
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: je.distanceRGBA_vert,
        fragmentShader: je.distanceRGBA_frag
    },
    shadow: {
        uniforms: on([ue.lights, ue.fog, {
            color: {
                value: new tt(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: je.shadow_vert,
        fragmentShader: je.shadow_frag
    }
};
gi.physical = {
    uniforms: on([gi.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new ze
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new ze
        },
        clearcoatNormalScale: {
            value: new st(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new ze
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new ze
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new ze
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new tt(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new ze
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new ze
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new ze
        },
        transmissionSamplerSize: {
            value: new st
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new ze
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new tt(0)
        },
        specularColor: {
            value: new tt(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new ze
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new ze
        },
        anisotropyVector: {
            value: new st
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new ze
        }
    }]),
    vertexShader: je.meshphysical_vert,
    fragmentShader: je.meshphysical_frag
};
const Mc = {
    r: 0,
    b: 0,
    g: 0
}
  , Kr = new Zi
  , vk = new Lt;
function _k(t, e, n, i, r, s, o) {
    const a = new tt(0);
    let l = s === !0 ? 0 : 1, c, u, d = null, h = 0, p = null;
    function v(_) {
        let S = _.isScene === !0 ? _.background : null;
        return S && S.isTexture && (S = (_.backgroundBlurriness > 0 ? n : e).get(S)),
        S
    }
    function x(_) {
        let S = !1;
        const T = v(_);
        T === null ? f(a, l) : T && T.isColor && (f(T, 1),
        S = !0);
        const A = t.xr.getEnvironmentBlendMode();
        A === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : A === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
        (t.autoClear || S) && (i.buffers.depth.setTest(!0),
        i.buffers.depth.setMask(!0),
        i.buffers.color.setMask(!0),
        t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil))
    }
    function g(_, S) {
        const T = v(S);
        T && (T.isCubeTexture || T.mapping === id) ? (u === void 0 && (u = new zi(new Pl(1,1,1),new Ir({
            name: "BackgroundCubeMaterial",
            uniforms: Bo(gi.backgroundCube.uniforms),
            vertexShader: gi.backgroundCube.vertexShader,
            fragmentShader: gi.backgroundCube.fragmentShader,
            side: Sn,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        u.geometry.deleteAttribute("normal"),
        u.geometry.deleteAttribute("uv"),
        u.onBeforeRender = function(A, C, P) {
            this.matrixWorld.copyPosition(P.matrixWorld)
        }
        ,
        Object.defineProperty(u.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(u)),
        Kr.copy(S.backgroundRotation),
        Kr.x *= -1,
        Kr.y *= -1,
        Kr.z *= -1,
        T.isCubeTexture && T.isRenderTargetTexture === !1 && (Kr.y *= -1,
        Kr.z *= -1),
        u.material.uniforms.envMap.value = T,
        u.material.uniforms.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === !1 ? -1 : 1,
        u.material.uniforms.backgroundBlurriness.value = S.backgroundBlurriness,
        u.material.uniforms.backgroundIntensity.value = S.backgroundIntensity,
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(vk.makeRotationFromEuler(Kr)),
        u.material.toneMapped = Qe.getTransfer(T.colorSpace) !== rt,
        (d !== T || h !== T.version || p !== t.toneMapping) && (u.material.needsUpdate = !0,
        d = T,
        h = T.version,
        p = t.toneMapping),
        u.layers.enableAll(),
        _.unshift(u, u.geometry, u.material, 0, 0, null)) : T && T.isTexture && (c === void 0 && (c = new zi(new sd(2,2),new Ir({
            name: "BackgroundMaterial",
            uniforms: Bo(gi.background.uniforms),
            vertexShader: gi.background.vertexShader,
            fragmentShader: gi.background.fragmentShader,
            side: Lr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(c)),
        c.material.uniforms.t2D.value = T,
        c.material.uniforms.backgroundIntensity.value = S.backgroundIntensity,
        c.material.toneMapped = Qe.getTransfer(T.colorSpace) !== rt,
        T.matrixAutoUpdate === !0 && T.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(T.matrix),
        (d !== T || h !== T.version || p !== t.toneMapping) && (c.material.needsUpdate = !0,
        d = T,
        h = T.version,
        p = t.toneMapping),
        c.layers.enableAll(),
        _.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function f(_, S) {
        _.getRGB(Mc, dE(t)),
        i.buffers.color.setClear(Mc.r, Mc.g, Mc.b, S, o)
    }
    function y() {
        u !== void 0 && (u.geometry.dispose(),
        u.material.dispose(),
        u = void 0),
        c !== void 0 && (c.geometry.dispose(),
        c.material.dispose(),
        c = void 0)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(_, S=1) {
            a.set(_),
            l = S,
            f(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(_) {
            l = _,
            f(a, l)
        },
        render: x,
        addToRenderList: g,
        dispose: y
    }
}
function yk(t, e) {
    const n = t.getParameter(t.MAX_VERTEX_ATTRIBS)
      , i = {}
      , r = h(null);
    let s = r
      , o = !1;
    function a(b, L, F, H, Z) {
        let $ = !1;
        const q = d(H, F, L);
        s !== q && (s = q,
        c(s.object)),
        $ = p(b, H, F, Z),
        $ && v(b, H, F, Z),
        Z !== null && e.update(Z, t.ELEMENT_ARRAY_BUFFER),
        ($ || o) && (o = !1,
        S(b, L, F, H),
        Z !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.get(Z).buffer))
    }
    function l() {
        return t.createVertexArray()
    }
    function c(b) {
        return t.bindVertexArray(b)
    }
    function u(b) {
        return t.deleteVertexArray(b)
    }
    function d(b, L, F) {
        const H = F.wireframe === !0;
        let Z = i[b.id];
        Z === void 0 && (Z = {},
        i[b.id] = Z);
        let $ = Z[L.id];
        $ === void 0 && ($ = {},
        Z[L.id] = $);
        let q = $[H];
        return q === void 0 && (q = h(l()),
        $[H] = q),
        q
    }
    function h(b) {
        const L = []
          , F = []
          , H = [];
        for (let Z = 0; Z < n; Z++)
            L[Z] = 0,
            F[Z] = 0,
            H[Z] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: L,
            enabledAttributes: F,
            attributeDivisors: H,
            object: b,
            attributes: {},
            index: null
        }
    }
    function p(b, L, F, H) {
        const Z = s.attributes
          , $ = L.attributes;
        let q = 0;
        const B = F.getAttributes();
        for (const D in B)
            if (B[D].location >= 0) {
                const Y = Z[D];
                let le = $[D];
                if (le === void 0 && (D === "instanceMatrix" && b.instanceMatrix && (le = b.instanceMatrix),
                D === "instanceColor" && b.instanceColor && (le = b.instanceColor)),
                Y === void 0 || Y.attribute !== le || le && Y.data !== le.data)
                    return !0;
                q++
            }
        return s.attributesNum !== q || s.index !== H
    }
    function v(b, L, F, H) {
        const Z = {}
          , $ = L.attributes;
        let q = 0;
        const B = F.getAttributes();
        for (const D in B)
            if (B[D].location >= 0) {
                let Y = $[D];
                Y === void 0 && (D === "instanceMatrix" && b.instanceMatrix && (Y = b.instanceMatrix),
                D === "instanceColor" && b.instanceColor && (Y = b.instanceColor));
                const le = {};
                le.attribute = Y,
                Y && Y.data && (le.data = Y.data),
                Z[D] = le,
                q++
            }
        s.attributes = Z,
        s.attributesNum = q,
        s.index = H
    }
    function x() {
        const b = s.newAttributes;
        for (let L = 0, F = b.length; L < F; L++)
            b[L] = 0
    }
    function g(b) {
        f(b, 0)
    }
    function f(b, L) {
        const F = s.newAttributes
          , H = s.enabledAttributes
          , Z = s.attributeDivisors;
        F[b] = 1,
        H[b] === 0 && (t.enableVertexAttribArray(b),
        H[b] = 1),
        Z[b] !== L && (t.vertexAttribDivisor(b, L),
        Z[b] = L)
    }
    function y() {
        const b = s.newAttributes
          , L = s.enabledAttributes;
        for (let F = 0, H = L.length; F < H; F++)
            L[F] !== b[F] && (t.disableVertexAttribArray(F),
            L[F] = 0)
    }
    function _(b, L, F, H, Z, $, q) {
        q === !0 ? t.vertexAttribIPointer(b, L, F, Z, $) : t.vertexAttribPointer(b, L, F, H, Z, $)
    }
    function S(b, L, F, H) {
        x();
        const Z = H.attributes
          , $ = F.getAttributes()
          , q = L.defaultAttributeValues;
        for (const B in $) {
            const D = $[B];
            if (D.location >= 0) {
                let G = Z[B];
                if (G === void 0 && (B === "instanceMatrix" && b.instanceMatrix && (G = b.instanceMatrix),
                B === "instanceColor" && b.instanceColor && (G = b.instanceColor)),
                G !== void 0) {
                    const Y = G.normalized
                      , le = G.itemSize
                      , xe = e.get(G);
                    if (xe === void 0)
                        continue;
                    const qe = xe.buffer
                      , Ke = xe.type
                      , We = xe.bytesPerElement
                      , X = Ke === t.INT || Ke === t.UNSIGNED_INT || G.gpuType === Ng;
                    if (G.isInterleavedBufferAttribute) {
                        const Q = G.data
                          , ge = Q.stride
                          , ke = G.offset;
                        if (Q.isInstancedInterleavedBuffer) {
                            for (let Ae = 0; Ae < D.locationSize; Ae++)
                                f(D.location + Ae, Q.meshPerAttribute);
                            b.isInstancedMesh !== !0 && H._maxInstanceCount === void 0 && (H._maxInstanceCount = Q.meshPerAttribute * Q.count)
                        } else
                            for (let Ae = 0; Ae < D.locationSize; Ae++)
                                g(D.location + Ae);
                        t.bindBuffer(t.ARRAY_BUFFER, qe);
                        for (let Ae = 0; Ae < D.locationSize; Ae++)
                            _(D.location + Ae, le / D.locationSize, Ke, Y, ge * We, (ke + le / D.locationSize * Ae) * We, X)
                    } else {
                        if (G.isInstancedBufferAttribute) {
                            for (let Q = 0; Q < D.locationSize; Q++)
                                f(D.location + Q, G.meshPerAttribute);
                            b.isInstancedMesh !== !0 && H._maxInstanceCount === void 0 && (H._maxInstanceCount = G.meshPerAttribute * G.count)
                        } else
                            for (let Q = 0; Q < D.locationSize; Q++)
                                g(D.location + Q);
                        t.bindBuffer(t.ARRAY_BUFFER, qe);
                        for (let Q = 0; Q < D.locationSize; Q++)
                            _(D.location + Q, le / D.locationSize, Ke, Y, le * We, le / D.locationSize * Q * We, X)
                    }
                } else if (q !== void 0) {
                    const Y = q[B];
                    if (Y !== void 0)
                        switch (Y.length) {
                        case 2:
                            t.vertexAttrib2fv(D.location, Y);
                            break;
                        case 3:
                            t.vertexAttrib3fv(D.location, Y);
                            break;
                        case 4:
                            t.vertexAttrib4fv(D.location, Y);
                            break;
                        default:
                            t.vertexAttrib1fv(D.location, Y)
                        }
                }
            }
        }
        y()
    }
    function T() {
        P();
        for (const b in i) {
            const L = i[b];
            for (const F in L) {
                const H = L[F];
                for (const Z in H)
                    u(H[Z].object),
                    delete H[Z];
                delete L[F]
            }
            delete i[b]
        }
    }
    function A(b) {
        if (i[b.id] === void 0)
            return;
        const L = i[b.id];
        for (const F in L) {
            const H = L[F];
            for (const Z in H)
                u(H[Z].object),
                delete H[Z];
            delete L[F]
        }
        delete i[b.id]
    }
    function C(b) {
        for (const L in i) {
            const F = i[L];
            if (F[b.id] === void 0)
                continue;
            const H = F[b.id];
            for (const Z in H)
                u(H[Z].object),
                delete H[Z];
            delete F[b.id]
        }
    }
    function P() {
        M(),
        o = !0,
        s !== r && (s = r,
        c(s.object))
    }
    function M() {
        r.geometry = null,
        r.program = null,
        r.wireframe = !1
    }
    return {
        setup: a,
        reset: P,
        resetDefaultState: M,
        dispose: T,
        releaseStatesOfGeometry: A,
        releaseStatesOfProgram: C,
        initAttributes: x,
        enableAttribute: g,
        disableUnusedAttributes: y
    }
}
function xk(t, e, n) {
    let i;
    function r(c) {
        i = c
    }
    function s(c, u) {
        t.drawArrays(i, c, u),
        n.update(u, i, 1)
    }
    function o(c, u, d) {
        d !== 0 && (t.drawArraysInstanced(i, c, u, d),
        n.update(u, i, d))
    }
    function a(c, u, d) {
        if (d === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, u, 0, d);
        let p = 0;
        for (let v = 0; v < d; v++)
            p += u[v];
        n.update(p, i, 1)
    }
    function l(c, u, d, h) {
        if (d === 0)
            return;
        const p = e.get("WEBGL_multi_draw");
        if (p === null)
            for (let v = 0; v < c.length; v++)
                o(c[v], u[v], h[v]);
        else {
            p.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, h, 0, d);
            let v = 0;
            for (let x = 0; x < d; x++)
                v += u[x] * h[x];
            n.update(v, i, 1)
        }
    }
    this.setMode = r,
    this.render = s,
    this.renderInstances = o,
    this.renderMultiDraw = a,
    this.renderMultiDrawInstances = l
}
function Sk(t, e, n, i) {
    let r;
    function s() {
        if (r !== void 0)
            return r;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const C = e.get("EXT_texture_filter_anisotropic");
            r = t.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            r = 0;
        return r
    }
    function o(C) {
        return !(C !== ai && i.convert(C) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function a(C) {
        const P = C === Tl && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(C !== Yi && i.convert(C) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) && C !== Bi && !P)
    }
    function l(C) {
        if (C === "highp") {
            if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
                return "highp";
            C = "mediump"
        }
        return C === "mediump" && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let c = n.precision !== void 0 ? n.precision : "highp";
    const u = l(c);
    u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."),
    c = u);
    const d = n.logarithmicDepthBuffer === !0
      , h = n.reversedDepthBuffer === !0 && e.has("EXT_clip_control")
      , p = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
      , v = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , x = t.getParameter(t.MAX_TEXTURE_SIZE)
      , g = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)
      , f = t.getParameter(t.MAX_VERTEX_ATTRIBS)
      , y = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)
      , _ = t.getParameter(t.MAX_VARYING_VECTORS)
      , S = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS)
      , T = v > 0
      , A = t.getParameter(t.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: l,
        textureFormatReadable: o,
        textureTypeReadable: a,
        precision: c,
        logarithmicDepthBuffer: d,
        reversedDepthBuffer: h,
        maxTextures: p,
        maxVertexTextures: v,
        maxTextureSize: x,
        maxCubemapSize: g,
        maxAttributes: f,
        maxVertexUniforms: y,
        maxVaryings: _,
        maxFragmentUniforms: S,
        vertexTextures: T,
        maxSamples: A
    }
}
function wk(t) {
    const e = this;
    let n = null
      , i = 0
      , r = !1
      , s = !1;
    const o = new ts
      , a = new ze
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(d, h) {
        const p = d.length !== 0 || h || i !== 0 || r;
        return r = h,
        i = d.length,
        p
    }
    ,
    this.beginShadows = function() {
        s = !0,
        u(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(d, h) {
        n = u(d, h, 0)
    }
    ,
    this.setState = function(d, h, p) {
        const v = d.clippingPlanes
          , x = d.clipIntersection
          , g = d.clipShadows
          , f = t.get(d);
        if (!r || v === null || v.length === 0 || s && !g)
            s ? u(null) : c();
        else {
            const y = s ? 0 : i
              , _ = y * 4;
            let S = f.clippingState || null;
            l.value = S,
            S = u(v, h, _, p);
            for (let T = 0; T !== _; ++T)
                S[T] = n[T];
            f.clippingState = S,
            this.numIntersection = x ? this.numPlanes : 0,
            this.numPlanes += y
        }
    }
    ;
    function c() {
        l.value !== n && (l.value = n,
        l.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function u(d, h, p, v) {
        const x = d !== null ? d.length : 0;
        let g = null;
        if (x !== 0) {
            if (g = l.value,
            v !== !0 || g === null) {
                const f = p + x * 4
                  , y = h.matrixWorldInverse;
                a.getNormalMatrix(y),
                (g === null || g.length < f) && (g = new Float32Array(f));
                for (let _ = 0, S = p; _ !== x; ++_,
                S += 4)
                    o.copy(d[_]).applyMatrix4(y, a),
                    o.normal.toArray(g, S),
                    g[S + 3] = o.constant
            }
            l.value = g,
            l.needsUpdate = !0
        }
        return e.numPlanes = x,
        e.numIntersection = 0,
        g
    }
}
function bk(t) {
    let e = new WeakMap;
    function n(o, a) {
        return a === yp ? o.mapping = Uo : a === xp && (o.mapping = Oo),
        o
    }
    function i(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === yp || a === xp)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return n(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new EL(l.height);
                        return c.fromEquirectangularTexture(t, o),
                        e.set(o, c),
                        o.addEventListener("dispose", r),
                        n(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
const mo = 4
  , ay = [.125, .215, .35, .446, .526, .582]
  , ss = 20
  , Dh = new LL
  , ly = new tt;
let Lh = null
  , Ih = 0
  , kh = 0
  , Uh = !1;
const ns = (1 + Math.sqrt(5)) / 2
  , qs = 1 / ns
  , cy = [new z(-ns,qs,0), new z(ns,qs,0), new z(-qs,0,ns), new z(qs,0,ns), new z(0,ns,-qs), new z(0,ns,qs), new z(-1,1,-1), new z(1,1,-1), new z(-1,1,1), new z(1,1,1)]
  , Ek = new z;
class uy {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, n=0, i=.1, r=100, s={}) {
        const {size: o=256, position: a=Ek} = s;
        Lh = this._renderer.getRenderTarget(),
        Ih = this._renderer.getActiveCubeFace(),
        kh = this._renderer.getActiveMipmapLevel(),
        Uh = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(o);
        const l = this._allocateTargets();
        return l.depthBuffer = !0,
        this._sceneToCubeUV(e, i, r, l, a),
        n > 0 && this._blur(l, 0, 0, n),
        this._applyPMREM(l),
        this._cleanup(l),
        l
    }
    fromEquirectangular(e, n=null) {
        return this._fromTexture(e, n)
    }
    fromCubemap(e, n=null) {
        return this._fromTexture(e, n)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = fy(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = hy(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Lh, Ih, kh),
        this._renderer.xr.enabled = Uh,
        e.scissorTest = !1,
        Ac(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, n) {
        e.mapping === Uo || e.mapping === Oo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        Lh = this._renderer.getRenderTarget(),
        Ih = this._renderer.getActiveCubeFace(),
        kh = this._renderer.getActiveMipmapLevel(),
        Uh = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const i = n || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , n = 4 * this._cubeSize
          , i = {
            magFilter: _i,
            minFilter: _i,
            generateMipmaps: !1,
            type: Tl,
            format: ai,
            colorSpace: Fo,
            depthBuffer: !1
        }
          , r = dy(e, n, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = dy(e, n, i);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = Tk(s)),
            this._blurMaterial = Mk(s, e, n)
        }
        return r
    }
    _compileMaterial(e) {
        const n = new zi(this._lodPlanes[0],e);
        this._renderer.compile(n, Dh)
    }
    _sceneToCubeUV(e, n, i, r, s) {
        const l = new jn(90,1,n,i)
          , c = [1, -1, 1, 1, 1, 1]
          , u = [1, 1, 1, -1, -1, -1]
          , d = this._renderer
          , h = d.autoClear
          , p = d.toneMapping;
        d.getClearColor(ly),
        d.toneMapping = Cr,
        d.autoClear = !1,
        d.state.buffers.depth.getReversed() && (d.setRenderTarget(r),
        d.clearDepth(),
        d.setRenderTarget(null));
        const x = new lE({
            name: "PMREM.Background",
            side: Sn,
            depthWrite: !1,
            depthTest: !1
        })
          , g = new zi(new Pl,x);
        let f = !1;
        const y = e.background;
        y ? y.isColor && (x.color.copy(y),
        e.background = null,
        f = !0) : (x.color.copy(ly),
        f = !0);
        for (let _ = 0; _ < 6; _++) {
            const S = _ % 3;
            S === 0 ? (l.up.set(0, c[_], 0),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x + u[_], s.y, s.z)) : S === 1 ? (l.up.set(0, 0, c[_]),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x, s.y + u[_], s.z)) : (l.up.set(0, c[_], 0),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x, s.y, s.z + u[_]));
            const T = this._cubeSize;
            Ac(r, S * T, _ > 2 ? T : 0, T, T),
            d.setRenderTarget(r),
            f && d.render(g, l),
            d.render(e, l)
        }
        g.geometry.dispose(),
        g.material.dispose(),
        d.toneMapping = p,
        d.autoClear = h,
        e.background = y
    }
    _textureToCubeUV(e, n) {
        const i = this._renderer
          , r = e.mapping === Uo || e.mapping === Oo;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = fy()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = hy());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new zi(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Ac(n, 0, 0, 3 * l, 2 * l),
        i.setRenderTarget(n),
        i.render(o, Dh)
    }
    _applyPMREM(e) {
        const n = this._renderer
          , i = n.autoClear;
        n.autoClear = !1;
        const r = this._lodPlanes.length;
        for (let s = 1; s < r; s++) {
            const o = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1])
              , a = cy[(r - s - 1) % cy.length];
            this._blur(e, s - 1, s, o, a)
        }
        n.autoClear = i
    }
    _blur(e, n, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, n, i, r, "latitudinal", s),
        this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, n, i, r, s, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3
          , d = new zi(this._lodPlanes[r],c)
          , h = c.uniforms
          , p = this._sizeLods[i] - 1
          , v = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * ss - 1)
          , x = s / v
          , g = isFinite(s) ? 1 + Math.floor(u * x) : ss;
        g > ss && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${ss}`);
        const f = [];
        let y = 0;
        for (let C = 0; C < ss; ++C) {
            const P = C / x
              , M = Math.exp(-P * P / 2);
            f.push(M),
            C === 0 ? y += M : C < g && (y += 2 * M)
        }
        for (let C = 0; C < f.length; C++)
            f[C] = f[C] / y;
        h.envMap.value = e.texture,
        h.samples.value = g,
        h.weights.value = f,
        h.latitudinal.value = o === "latitudinal",
        a && (h.poleAxis.value = a);
        const {_lodMax: _} = this;
        h.dTheta.value = v,
        h.mipInt.value = _ - i;
        const S = this._sizeLods[r]
          , T = 3 * S * (r > _ - mo ? r - _ + mo : 0)
          , A = 4 * (this._cubeSize - S);
        Ac(n, T, A, 3 * S, 2 * S),
        l.setRenderTarget(n),
        l.render(d, Dh)
    }
}
function Tk(t) {
    const e = []
      , n = []
      , i = [];
    let r = t;
    const s = t - mo + 1 + ay.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        n.push(a);
        let l = 1 / a;
        o > t - mo ? l = ay[o - t + mo - 1] : o === 0 && (l = 0),
        i.push(l);
        const c = 1 / (a - 2)
          , u = -c
          , d = 1 + c
          , h = [u, u, d, u, d, d, u, u, d, d, u, d]
          , p = 6
          , v = 6
          , x = 3
          , g = 2
          , f = 1
          , y = new Float32Array(x * v * p)
          , _ = new Float32Array(g * v * p)
          , S = new Float32Array(f * v * p);
        for (let A = 0; A < p; A++) {
            const C = A % 3 * 2 / 3 - 1
              , P = A > 2 ? 0 : -1
              , M = [C, P, 0, C + 2 / 3, P, 0, C + 2 / 3, P + 1, 0, C, P, 0, C + 2 / 3, P + 1, 0, C, P + 1, 0];
            y.set(M, x * v * A),
            _.set(h, g * v * A);
            const b = [A, A, A, A, A, A];
            S.set(b, f * v * A)
        }
        const T = new Qi;
        T.setAttribute("position", new Ei(y,x)),
        T.setAttribute("uv", new Ei(_,g)),
        T.setAttribute("faceIndex", new Ei(S,f)),
        e.push(T),
        r > mo && r--
    }
    return {
        lodPlanes: e,
        sizeLods: n,
        sigmas: i
    }
}
function dy(t, e, n) {
    const i = new bs(t,e,n);
    return i.texture.mapping = id,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function Ac(t, e, n, i, r) {
    t.viewport.set(e, n, i, r),
    t.scissor.set(e, n, i, r)
}
function Mk(t, e, n) {
    const i = new Float32Array(ss)
      , r = new z(0,1,0);
    return new Ir({
        name: "SphericalGaussianBlur",
        defines: {
            n: ss,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / n,
            CUBEUV_MAX_MIP: `${t}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: Fg(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Ar,
        depthTest: !1,
        depthWrite: !1
    })
}
function hy() {
    return new Ir({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: Fg(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Ar,
        depthTest: !1,
        depthWrite: !1
    })
}
function fy() {
    return new Ir({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: Fg(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Ar,
        depthTest: !1,
        depthWrite: !1
    })
}
function Fg() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function Ak(t) {
    let e = new WeakMap
      , n = null;
    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === yp || l === xp
              , u = l === Uo || l === Oo;
            if (c || u) {
                let d = e.get(a);
                const h = d !== void 0 ? d.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== h)
                    return n === null && (n = new uy(t)),
                    d = c ? n.fromEquirectangular(a, d) : n.fromCubemap(a, d),
                    d.texture.pmremVersion = a.pmremVersion,
                    e.set(a, d),
                    d.texture;
                if (d !== void 0)
                    return d.texture;
                {
                    const p = a.image;
                    return c && p && p.height > 0 || u && p && r(p) ? (n === null && (n = new uy(t)),
                    d = c ? n.fromEquirectangular(a) : n.fromCubemap(a),
                    d.texture.pmremVersion = a.pmremVersion,
                    e.set(a, d),
                    a.addEventListener("dispose", s),
                    d.texture) : null
                }
            }
        }
        return a
    }
    function r(a) {
        let l = 0;
        const c = 6;
        for (let u = 0; u < c; u++)
            a[u] !== void 0 && l++;
        return l === c
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        n !== null && (n.dispose(),
        n = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function Ck(t) {
    const e = {};
    function n(i) {
        if (e[i] !== void 0)
            return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = t.getExtension(i)
        }
        return e[i] = r,
        r
    }
    return {
        has: function(i) {
            return n(i) !== null
        },
        init: function() {
            n("EXT_color_buffer_float"),
            n("WEBGL_clip_cull_distance"),
            n("OES_texture_float_linear"),
            n("EXT_color_buffer_half_float"),
            n("WEBGL_multisampled_render_to_texture"),
            n("WEBGL_render_shared_exponent")
        },
        get: function(i) {
            const r = n(i);
            return r === null && dl("THREE.WebGLRenderer: " + i + " extension not supported."),
            r
        }
    }
}
function Rk(t, e, n, i) {
    const r = {}
      , s = new WeakMap;
    function o(d) {
        const h = d.target;
        h.index !== null && e.remove(h.index);
        for (const v in h.attributes)
            e.remove(h.attributes[v]);
        h.removeEventListener("dispose", o),
        delete r[h.id];
        const p = s.get(h);
        p && (e.remove(p),
        s.delete(h)),
        i.releaseStatesOfGeometry(h),
        h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount,
        n.memory.geometries--
    }
    function a(d, h) {
        return r[h.id] === !0 || (h.addEventListener("dispose", o),
        r[h.id] = !0,
        n.memory.geometries++),
        h
    }
    function l(d) {
        const h = d.attributes;
        for (const p in h)
            e.update(h[p], t.ARRAY_BUFFER)
    }
    function c(d) {
        const h = []
          , p = d.index
          , v = d.attributes.position;
        let x = 0;
        if (p !== null) {
            const y = p.array;
            x = p.version;
            for (let _ = 0, S = y.length; _ < S; _ += 3) {
                const T = y[_ + 0]
                  , A = y[_ + 1]
                  , C = y[_ + 2];
                h.push(T, A, A, C, C, T)
            }
        } else if (v !== void 0) {
            const y = v.array;
            x = v.version;
            for (let _ = 0, S = y.length / 3 - 1; _ < S; _ += 3) {
                const T = _ + 0
                  , A = _ + 1
                  , C = _ + 2;
                h.push(T, A, A, C, C, T)
            }
        } else
            return;
        const g = new (iE(h) ? uE : cE)(h,1);
        g.version = x;
        const f = s.get(d);
        f && e.remove(f),
        s.set(d, g)
    }
    function u(d) {
        const h = s.get(d);
        if (h) {
            const p = d.index;
            p !== null && h.version < p.version && c(d)
        } else
            c(d);
        return s.get(d)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: u
    }
}
function Pk(t, e, n) {
    let i;
    function r(h) {
        i = h
    }
    let s, o;
    function a(h) {
        s = h.type,
        o = h.bytesPerElement
    }
    function l(h, p) {
        t.drawElements(i, p, s, h * o),
        n.update(p, i, 1)
    }
    function c(h, p, v) {
        v !== 0 && (t.drawElementsInstanced(i, p, s, h * o, v),
        n.update(p, i, v))
    }
    function u(h, p, v) {
        if (v === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, p, 0, s, h, 0, v);
        let g = 0;
        for (let f = 0; f < v; f++)
            g += p[f];
        n.update(g, i, 1)
    }
    function d(h, p, v, x) {
        if (v === 0)
            return;
        const g = e.get("WEBGL_multi_draw");
        if (g === null)
            for (let f = 0; f < h.length; f++)
                c(h[f] / o, p[f], x[f]);
        else {
            g.multiDrawElementsInstancedWEBGL(i, p, 0, s, h, 0, x, 0, v);
            let f = 0;
            for (let y = 0; y < v; y++)
                f += p[y] * x[y];
            n.update(f, i, 1)
        }
    }
    this.setMode = r,
    this.setIndex = a,
    this.render = l,
    this.renderInstances = c,
    this.renderMultiDraw = u,
    this.renderMultiDrawInstances = d
}
function Nk(t) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , n = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(s, o, a) {
        switch (n.calls++,
        o) {
        case t.TRIANGLES:
            n.triangles += a * (s / 3);
            break;
        case t.LINES:
            n.lines += a * (s / 2);
            break;
        case t.LINE_STRIP:
            n.lines += a * (s - 1);
            break;
        case t.LINE_LOOP:
            n.lines += a * s;
            break;
        case t.POINTS:
            n.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        n.calls = 0,
        n.triangles = 0,
        n.points = 0,
        n.lines = 0
    }
    return {
        memory: e,
        render: n,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}
function Dk(t, e, n) {
    const i = new WeakMap
      , r = new Rt;
    function s(o, a, l) {
        const c = o.morphTargetInfluences
          , u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color
          , d = u !== void 0 ? u.length : 0;
        let h = i.get(a);
        if (h === void 0 || h.count !== d) {
            let b = function() {
                P.dispose(),
                i.delete(a),
                a.removeEventListener("dispose", b)
            };
            var p = b;
            h !== void 0 && h.texture.dispose();
            const v = a.morphAttributes.position !== void 0
              , x = a.morphAttributes.normal !== void 0
              , g = a.morphAttributes.color !== void 0
              , f = a.morphAttributes.position || []
              , y = a.morphAttributes.normal || []
              , _ = a.morphAttributes.color || [];
            let S = 0;
            v === !0 && (S = 1),
            x === !0 && (S = 2),
            g === !0 && (S = 3);
            let T = a.attributes.position.count * S
              , A = 1;
            T > e.maxTextureSize && (A = Math.ceil(T / e.maxTextureSize),
            T = e.maxTextureSize);
            const C = new Float32Array(T * A * 4 * d)
              , P = new rE(C,T,A,d);
            P.type = Bi,
            P.needsUpdate = !0;
            const M = S * 4;
            for (let L = 0; L < d; L++) {
                const F = f[L]
                  , H = y[L]
                  , Z = _[L]
                  , $ = T * A * 4 * L;
                for (let q = 0; q < F.count; q++) {
                    const B = q * M;
                    v === !0 && (r.fromBufferAttribute(F, q),
                    C[$ + B + 0] = r.x,
                    C[$ + B + 1] = r.y,
                    C[$ + B + 2] = r.z,
                    C[$ + B + 3] = 0),
                    x === !0 && (r.fromBufferAttribute(H, q),
                    C[$ + B + 4] = r.x,
                    C[$ + B + 5] = r.y,
                    C[$ + B + 6] = r.z,
                    C[$ + B + 7] = 0),
                    g === !0 && (r.fromBufferAttribute(Z, q),
                    C[$ + B + 8] = r.x,
                    C[$ + B + 9] = r.y,
                    C[$ + B + 10] = r.z,
                    C[$ + B + 11] = Z.itemSize === 4 ? r.w : 1)
                }
            }
            h = {
                count: d,
                texture: P,
                size: new st(T,A)
            },
            i.set(a, h),
            a.addEventListener("dispose", b)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
            l.getUniforms().setValue(t, "morphTexture", o.morphTexture, n);
        else {
            let v = 0;
            for (let g = 0; g < c.length; g++)
                v += c[g];
            const x = a.morphTargetsRelative ? 1 : 1 - v;
            l.getUniforms().setValue(t, "morphTargetBaseInfluence", x),
            l.getUniforms().setValue(t, "morphTargetInfluences", c)
        }
        l.getUniforms().setValue(t, "morphTargetsTexture", h.texture, n),
        l.getUniforms().setValue(t, "morphTargetsTextureSize", h.size)
    }
    return {
        update: s
    }
}
function Lk(t, e, n, i) {
    let r = new WeakMap;
    function s(l) {
        const c = i.render.frame
          , u = l.geometry
          , d = e.get(l, u);
        if (r.get(d) !== c && (e.update(d),
        r.set(d, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        r.get(l) !== c && (n.update(l.instanceMatrix, t.ARRAY_BUFFER),
        l.instanceColor !== null && n.update(l.instanceColor, t.ARRAY_BUFFER),
        r.set(l, c))),
        l.isSkinnedMesh) {
            const h = l.skeleton;
            r.get(h) !== c && (h.update(),
            r.set(h, c))
        }
        return d
    }
    function o() {
        r = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        n.remove(c.instanceMatrix),
        c.instanceColor !== null && n.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const yE = new wn
  , py = new gE(1,1)
  , xE = new rE
  , SE = new aL
  , wE = new fE
  , my = []
  , gy = []
  , vy = new Float32Array(16)
  , _y = new Float32Array(9)
  , yy = new Float32Array(4);
function Ko(t, e, n) {
    const i = t[0];
    if (i <= 0 || i > 0)
        return t;
    const r = e * n;
    let s = my[r];
    if (s === void 0 && (s = new Float32Array(r),
    my[r] = s),
    e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += n,
            t[o].toArray(s, a)
    }
    return s
}
function Bt(t, e) {
    if (t.length !== e.length)
        return !1;
    for (let n = 0, i = t.length; n < i; n++)
        if (t[n] !== e[n])
            return !1;
    return !0
}
function zt(t, e) {
    for (let n = 0, i = e.length; n < i; n++)
        t[n] = e[n]
}
function od(t, e) {
    let n = gy[e];
    n === void 0 && (n = new Int32Array(e),
    gy[e] = n);
    for (let i = 0; i !== e; ++i)
        n[i] = t.allocateTextureUnit();
    return n
}
function Ik(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1f(this.addr, e),
    n[0] = e)
}
function kk(t, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y),
        n[0] = e.x,
        n[1] = e.y);
    else {
        if (Bt(n, e))
            return;
        t.uniform2fv(this.addr, e),
        zt(n, e)
    }
}
function Uk(t, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z);
    else if (e.r !== void 0)
        (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b),
        n[0] = e.r,
        n[1] = e.g,
        n[2] = e.b);
    else {
        if (Bt(n, e))
            return;
        t.uniform3fv(this.addr, e),
        zt(n, e)
    }
}
function Ok(t, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z,
        n[3] = e.w);
    else {
        if (Bt(n, e))
            return;
        t.uniform4fv(this.addr, e),
        zt(n, e)
    }
}
function Fk(t, e) {
    const n = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Bt(n, e))
            return;
        t.uniformMatrix2fv(this.addr, !1, e),
        zt(n, e)
    } else {
        if (Bt(n, i))
            return;
        yy.set(i),
        t.uniformMatrix2fv(this.addr, !1, yy),
        zt(n, i)
    }
}
function Bk(t, e) {
    const n = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Bt(n, e))
            return;
        t.uniformMatrix3fv(this.addr, !1, e),
        zt(n, e)
    } else {
        if (Bt(n, i))
            return;
        _y.set(i),
        t.uniformMatrix3fv(this.addr, !1, _y),
        zt(n, i)
    }
}
function zk(t, e) {
    const n = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Bt(n, e))
            return;
        t.uniformMatrix4fv(this.addr, !1, e),
        zt(n, e)
    } else {
        if (Bt(n, i))
            return;
        vy.set(i),
        t.uniformMatrix4fv(this.addr, !1, vy),
        zt(n, i)
    }
}
function Vk(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1i(this.addr, e),
    n[0] = e)
}
function jk(t, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y) && (t.uniform2i(this.addr, e.x, e.y),
        n[0] = e.x,
        n[1] = e.y);
    else {
        if (Bt(n, e))
            return;
        t.uniform2iv(this.addr, e),
        zt(n, e)
    }
}
function Hk(t, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3i(this.addr, e.x, e.y, e.z),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z);
    else {
        if (Bt(n, e))
            return;
        t.uniform3iv(this.addr, e),
        zt(n, e)
    }
}
function Gk(t, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z,
        n[3] = e.w);
    else {
        if (Bt(n, e))
            return;
        t.uniform4iv(this.addr, e),
        zt(n, e)
    }
}
function Wk(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1ui(this.addr, e),
    n[0] = e)
}
function $k(t, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y) && (t.uniform2ui(this.addr, e.x, e.y),
        n[0] = e.x,
        n[1] = e.y);
    else {
        if (Bt(n, e))
            return;
        t.uniform2uiv(this.addr, e),
        zt(n, e)
    }
}
function Xk(t, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3ui(this.addr, e.x, e.y, e.z),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z);
    else {
        if (Bt(n, e))
            return;
        t.uniform3uiv(this.addr, e),
        zt(n, e)
    }
}
function qk(t, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z,
        n[3] = e.w);
    else {
        if (Bt(n, e))
            return;
        t.uniform4uiv(this.addr, e),
        zt(n, e)
    }
}
function Kk(t, e, n) {
    const i = this.cache
      , r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r),
    i[0] = r);
    let s;
    this.type === t.SAMPLER_2D_SHADOW ? (py.compareFunction = nE,
    s = py) : s = yE,
    n.setTexture2D(e || s, r)
}
function Yk(t, e, n) {
    const i = this.cache
      , r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r),
    i[0] = r),
    n.setTexture3D(e || SE, r)
}
function Zk(t, e, n) {
    const i = this.cache
      , r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r),
    i[0] = r),
    n.setTextureCube(e || wE, r)
}
function Jk(t, e, n) {
    const i = this.cache
      , r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r),
    i[0] = r),
    n.setTexture2DArray(e || xE, r)
}
function Qk(t) {
    switch (t) {
    case 5126:
        return Ik;
    case 35664:
        return kk;
    case 35665:
        return Uk;
    case 35666:
        return Ok;
    case 35674:
        return Fk;
    case 35675:
        return Bk;
    case 35676:
        return zk;
    case 5124:
    case 35670:
        return Vk;
    case 35667:
    case 35671:
        return jk;
    case 35668:
    case 35672:
        return Hk;
    case 35669:
    case 35673:
        return Gk;
    case 5125:
        return Wk;
    case 36294:
        return $k;
    case 36295:
        return Xk;
    case 36296:
        return qk;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return Kk;
    case 35679:
    case 36299:
    case 36307:
        return Yk;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return Zk;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return Jk
    }
}
function eU(t, e) {
    t.uniform1fv(this.addr, e)
}
function tU(t, e) {
    const n = Ko(e, this.size, 2);
    t.uniform2fv(this.addr, n)
}
function nU(t, e) {
    const n = Ko(e, this.size, 3);
    t.uniform3fv(this.addr, n)
}
function iU(t, e) {
    const n = Ko(e, this.size, 4);
    t.uniform4fv(this.addr, n)
}
function rU(t, e) {
    const n = Ko(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n)
}
function sU(t, e) {
    const n = Ko(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n)
}
function oU(t, e) {
    const n = Ko(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n)
}
function aU(t, e) {
    t.uniform1iv(this.addr, e)
}
function lU(t, e) {
    t.uniform2iv(this.addr, e)
}
function cU(t, e) {
    t.uniform3iv(this.addr, e)
}
function uU(t, e) {
    t.uniform4iv(this.addr, e)
}
function dU(t, e) {
    t.uniform1uiv(this.addr, e)
}
function hU(t, e) {
    t.uniform2uiv(this.addr, e)
}
function fU(t, e) {
    t.uniform3uiv(this.addr, e)
}
function pU(t, e) {
    t.uniform4uiv(this.addr, e)
}
function mU(t, e, n) {
    const i = this.cache
      , r = e.length
      , s = od(n, r);
    Bt(i, s) || (t.uniform1iv(this.addr, s),
    zt(i, s));
    for (let o = 0; o !== r; ++o)
        n.setTexture2D(e[o] || yE, s[o])
}
function gU(t, e, n) {
    const i = this.cache
      , r = e.length
      , s = od(n, r);
    Bt(i, s) || (t.uniform1iv(this.addr, s),
    zt(i, s));
    for (let o = 0; o !== r; ++o)
        n.setTexture3D(e[o] || SE, s[o])
}
function vU(t, e, n) {
    const i = this.cache
      , r = e.length
      , s = od(n, r);
    Bt(i, s) || (t.uniform1iv(this.addr, s),
    zt(i, s));
    for (let o = 0; o !== r; ++o)
        n.setTextureCube(e[o] || wE, s[o])
}
function _U(t, e, n) {
    const i = this.cache
      , r = e.length
      , s = od(n, r);
    Bt(i, s) || (t.uniform1iv(this.addr, s),
    zt(i, s));
    for (let o = 0; o !== r; ++o)
        n.setTexture2DArray(e[o] || xE, s[o])
}
function yU(t) {
    switch (t) {
    case 5126:
        return eU;
    case 35664:
        return tU;
    case 35665:
        return nU;
    case 35666:
        return iU;
    case 35674:
        return rU;
    case 35675:
        return sU;
    case 35676:
        return oU;
    case 5124:
    case 35670:
        return aU;
    case 35667:
    case 35671:
        return lU;
    case 35668:
    case 35672:
        return cU;
    case 35669:
    case 35673:
        return uU;
    case 5125:
        return dU;
    case 36294:
        return hU;
    case 36295:
        return fU;
    case 36296:
        return pU;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return mU;
    case 35679:
    case 36299:
    case 36307:
        return gU;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return vU;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return _U
    }
}
class xU {
    constructor(e, n, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = n.type,
        this.setValue = Qk(n.type)
    }
}
class SU {
    constructor(e, n, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = n.type,
        this.size = n.size,
        this.setValue = yU(n.type)
    }
}
class wU {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, n, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, n[a.id], i)
        }
    }
}
const Oh = /(\w+)(\])?(\[|\.)?/g;
function xy(t, e) {
    t.seq.push(e),
    t.map[e.id] = e
}
function bU(t, e, n) {
    const i = t.name
      , r = i.length;
    for (Oh.lastIndex = 0; ; ) {
        const s = Oh.exec(i)
          , o = Oh.lastIndex;
        let a = s[1];
        const l = s[2] === "]"
          , c = s[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === r) {
            xy(n, c === void 0 ? new xU(a,t,e) : new SU(a,t,e));
            break
        } else {
            let d = n.map[a];
            d === void 0 && (d = new wU(a),
            xy(n, d)),
            n = d
        }
    }
}
class Yc {
    constructor(e, n) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(n, r)
              , o = e.getUniformLocation(n, s.name);
            bU(s, o, this)
        }
    }
    setValue(e, n, i, r) {
        const s = this.map[n];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, n, i) {
        const r = n[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, n, i, r) {
        for (let s = 0, o = n.length; s !== o; ++s) {
            const a = n[s]
              , l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, r)
        }
    }
    static seqWithValue(e, n) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in n && i.push(o)
        }
        return i
    }
}
function Sy(t, e, n) {
    const i = t.createShader(e);
    return t.shaderSource(i, n),
    t.compileShader(i),
    i
}
const EU = 37297;
let TU = 0;
function MU(t, e) {
    const n = t.split(`
`)
      , i = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, n.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${n[o]}`)
    }
    return i.join(`
`)
}
const wy = new ze;
function AU(t) {
    Qe._getMatrix(wy, Qe.workingColorSpace, t);
    const e = `mat3( ${wy.elements.map(n => n.toFixed(4))} )`;
    switch (Qe.getTransfer(t)) {
    case Pu:
        return [e, "LinearTransferOETF"];
    case rt:
        return [e, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space: ", t),
        [e, "LinearTransferOETF"]
    }
}
function by(t, e, n) {
    const i = t.getShaderParameter(e, t.COMPILE_STATUS)
      , s = (t.getShaderInfoLog(e) || "").trim();
    if (i && s === "")
        return "";
    const o = /ERROR: 0:(\d+)/.exec(s);
    if (o) {
        const a = parseInt(o[1]);
        return n.toUpperCase() + `

` + s + `

` + MU(t.getShaderSource(e), a)
    } else
        return s
}
function CU(t, e) {
    const n = AU(e);
    return [`vec4 ${t}( vec4 value ) {`, `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join(`
`)
}
function RU(t, e) {
    let n;
    switch (e) {
    case ID:
        n = "Linear";
        break;
    case kD:
        n = "Reinhard";
        break;
    case UD:
        n = "Cineon";
        break;
    case OD:
        n = "ACESFilmic";
        break;
    case BD:
        n = "AgX";
        break;
    case zD:
        n = "Neutral";
        break;
    case FD:
        n = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        n = "Linear"
    }
    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
}
const Cc = new z;
function PU() {
    Qe.getLuminanceCoefficients(Cc);
    const t = Cc.x.toFixed(4)
      , e = Cc.y.toFixed(4)
      , n = Cc.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${t}, ${e}, ${n} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function NU(t) {
    return [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(ya).join(`
`)
}
function DU(t) {
    const e = [];
    for (const n in t) {
        const i = t[n];
        i !== !1 && e.push("#define " + n + " " + i)
    }
    return e.join(`
`)
}
function LU(t, e) {
    const n = {}
      , i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const s = t.getActiveAttrib(e, r)
          , o = s.name;
        let a = 1;
        s.type === t.FLOAT_MAT2 && (a = 2),
        s.type === t.FLOAT_MAT3 && (a = 3),
        s.type === t.FLOAT_MAT4 && (a = 4),
        n[o] = {
            type: s.type,
            location: t.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return n
}
function ya(t) {
    return t !== ""
}
function Ey(t, e) {
    const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function Ty(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const IU = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Qp(t) {
    return t.replace(IU, UU)
}
const kU = new Map;
function UU(t, e) {
    let n = je[e];
    if (n === void 0) {
        const i = kU.get(e);
        if (i !== void 0)
            n = je[i],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return Qp(n)
}
const OU = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function My(t) {
    return t.replace(OU, FU)
}
function FU(t, e, n, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(n); s++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function Ay(t) {
    let e = `precision ${t.precision} float;
	precision ${t.precision} int;
	precision ${t.precision} sampler2D;
	precision ${t.precision} samplerCube;
	precision ${t.precision} sampler3D;
	precision ${t.precision} sampler2DArray;
	precision ${t.precision} sampler2DShadow;
	precision ${t.precision} samplerCubeShadow;
	precision ${t.precision} sampler2DArrayShadow;
	precision ${t.precision} isampler2D;
	precision ${t.precision} isampler3D;
	precision ${t.precision} isamplerCube;
	precision ${t.precision} isampler2DArray;
	precision ${t.precision} usampler2D;
	precision ${t.precision} usampler3D;
	precision ${t.precision} usamplerCube;
	precision ${t.precision} usampler2DArray;
	`;
    return t.precision === "highp" ? e += `
#define HIGH_PRECISION` : t.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : t.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function BU(t) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return t.shadowMapType === Wb ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === fD ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === Di && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function zU(t) {
    let e = "ENVMAP_TYPE_CUBE";
    if (t.envMap)
        switch (t.envMapMode) {
        case Uo:
        case Oo:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case id:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function VU(t) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (t.envMap)
        switch (t.envMapMode) {
        case Oo:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function jU(t) {
    let e = "ENVMAP_BLENDING_NONE";
    if (t.envMap)
        switch (t.combine) {
        case $b:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case DD:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case LD:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function HU(t) {
    const e = t.envMapCubeUVHeight;
    if (e === null)
        return null;
    const n = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
        texelHeight: i,
        maxMip: n
    }
}
function GU(t, e, n, i) {
    const r = t.getContext()
      , s = n.defines;
    let o = n.vertexShader
      , a = n.fragmentShader;
    const l = BU(n)
      , c = zU(n)
      , u = VU(n)
      , d = jU(n)
      , h = HU(n)
      , p = NU(n)
      , v = DU(s)
      , x = r.createProgram();
    let g, f, y = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
    n.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter(ya).join(`
`),
    g.length > 0 && (g += `
`),
    f = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter(ya).join(`
`),
    f.length > 0 && (f += `
`)) : (g = [Ay(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(ya).join(`
`),
    f = [Ay(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + d : "", h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "", h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "", h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Cr ? "#define TONE_MAPPING" : "", n.toneMapping !== Cr ? je.tonemapping_pars_fragment : "", n.toneMapping !== Cr ? RU("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", je.colorspace_pars_fragment, CU("linearToOutputTexel", n.outputColorSpace), PU(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(ya).join(`
`)),
    o = Qp(o),
    o = Ey(o, n),
    o = Ty(o, n),
    a = Qp(a),
    a = Ey(a, n),
    a = Ty(a, n),
    o = My(o),
    a = My(a),
    n.isRawShaderMaterial !== !0 && (y = `#version 300 es
`,
    g = [p, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + g,
    f = ["#define varying in", n.glslVersion === z_ ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === z_ ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + f);
    const _ = y + g + o
      , S = y + f + a
      , T = Sy(r, r.VERTEX_SHADER, _)
      , A = Sy(r, r.FRAGMENT_SHADER, S);
    r.attachShader(x, T),
    r.attachShader(x, A),
    n.index0AttributeName !== void 0 ? r.bindAttribLocation(x, 0, n.index0AttributeName) : n.morphTargets === !0 && r.bindAttribLocation(x, 0, "position"),
    r.linkProgram(x);
    function C(L) {
        if (t.debug.checkShaderErrors) {
            const F = r.getProgramInfoLog(x) || ""
              , H = r.getShaderInfoLog(T) || ""
              , Z = r.getShaderInfoLog(A) || ""
              , $ = F.trim()
              , q = H.trim()
              , B = Z.trim();
            let D = !0
              , G = !0;
            if (r.getProgramParameter(x, r.LINK_STATUS) === !1)
                if (D = !1,
                typeof t.debug.onShaderError == "function")
                    t.debug.onShaderError(r, x, T, A);
                else {
                    const Y = by(r, T, "vertex")
                      , le = by(r, A, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(x, r.VALIDATE_STATUS) + `

Material Name: ` + L.name + `
Material Type: ` + L.type + `

Program Info Log: ` + $ + `
` + Y + `
` + le)
                }
            else
                $ !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", $) : (q === "" || B === "") && (G = !1);
            G && (L.diagnostics = {
                runnable: D,
                programLog: $,
                vertexShader: {
                    log: q,
                    prefix: g
                },
                fragmentShader: {
                    log: B,
                    prefix: f
                }
            })
        }
        r.deleteShader(T),
        r.deleteShader(A),
        P = new Yc(r,x),
        M = LU(r, x)
    }
    let P;
    this.getUniforms = function() {
        return P === void 0 && C(this),
        P
    }
    ;
    let M;
    this.getAttributes = function() {
        return M === void 0 && C(this),
        M
    }
    ;
    let b = n.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return b === !1 && (b = r.getProgramParameter(x, EU)),
        b
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(x),
        this.program = void 0
    }
    ,
    this.type = n.shaderType,
    this.name = n.shaderName,
    this.id = TU++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = x,
    this.vertexShader = T,
    this.fragmentShader = A,
    this
}
let WU = 0;
class $U {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const n = e.vertexShader
          , i = e.fragmentShader
          , r = this._getShaderStage(n)
          , s = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const n = this.materialCache.get(e);
        for (const i of n)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const n = this.materialCache;
        let i = n.get(e);
        return i === void 0 && (i = new Set,
        n.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const n = this.shaderCache;
        let i = n.get(e);
        return i === void 0 && (i = new XU(e),
        n.set(e, i)),
        i
    }
}
class XU {
    constructor(e) {
        this.id = WU++,
        this.code = e,
        this.usedTimes = 0
    }
}
function qU(t, e, n, i, r, s, o) {
    const a = new oE
      , l = new $U
      , c = new Set
      , u = []
      , d = r.logarithmicDepthBuffer
      , h = r.vertexTextures;
    let p = r.precision;
    const v = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function x(M) {
        return c.add(M),
        M === 0 ? "uv" : `uv${M}`
    }
    function g(M, b, L, F, H) {
        const Z = F.fog
          , $ = H.geometry
          , q = M.isMeshStandardMaterial ? F.environment : null
          , B = (M.isMeshStandardMaterial ? n : e).get(M.envMap || q)
          , D = B && B.mapping === id ? B.image.height : null
          , G = v[M.type];
        M.precision !== null && (p = r.getMaxPrecision(M.precision),
        p !== M.precision && console.warn("THREE.WebGLProgram.getParameters:", M.precision, "not supported, using", p, "instead."));
        const Y = $.morphAttributes.position || $.morphAttributes.normal || $.morphAttributes.color
          , le = Y !== void 0 ? Y.length : 0;
        let xe = 0;
        $.morphAttributes.position !== void 0 && (xe = 1),
        $.morphAttributes.normal !== void 0 && (xe = 2),
        $.morphAttributes.color !== void 0 && (xe = 3);
        let qe, Ke, We, X;
        if (G) {
            const et = gi[G];
            qe = et.vertexShader,
            Ke = et.fragmentShader
        } else
            qe = M.vertexShader,
            Ke = M.fragmentShader,
            l.update(M),
            We = l.getVertexShaderID(M),
            X = l.getFragmentShaderID(M);
        const Q = t.getRenderTarget()
          , ge = t.state.buffers.depth.getReversed()
          , ke = H.isInstancedMesh === !0
          , Ae = H.isBatchedMesh === !0
          , Ye = !!M.map
          , Kt = !!M.matcap
          , N = !!B
          , ft = !!M.aoMap
          , Oe = !!M.lightMap
          , Le = !!M.bumpMap
          , Se = !!M.normalMap
          , pt = !!M.displacementMap
          , we = !!M.emissiveMap
          , Ve = !!M.metalnessMap
          , Vt = !!M.roughnessMap
          , Mt = M.anisotropy > 0
          , R = M.clearcoat > 0
          , w = M.dispersion > 0
          , O = M.iridescence > 0
          , K = M.sheen > 0
          , ee = M.transmission > 0
          , W = Mt && !!M.anisotropyMap
          , Me = R && !!M.clearcoatMap
          , ae = R && !!M.clearcoatNormalMap
          , be = R && !!M.clearcoatRoughnessMap
          , Ee = O && !!M.iridescenceMap
          , re = O && !!M.iridescenceThicknessMap
          , fe = K && !!M.sheenColorMap
          , Ne = K && !!M.sheenRoughnessMap
          , Te = !!M.specularMap
          , de = !!M.specularColorMap
          , Be = !!M.specularIntensityMap
          , I = ee && !!M.transmissionMap
          , se = ee && !!M.thicknessMap
          , ce = !!M.gradientMap
          , ve = !!M.alphaMap
          , ne = M.alphaTest > 0
          , J = !!M.alphaHash
          , ye = !!M.extensions;
        let Ue = Cr;
        M.toneMapped && (Q === null || Q.isXRRenderTarget === !0) && (Ue = t.toneMapping);
        const at = {
            shaderID: G,
            shaderType: M.type,
            shaderName: M.name,
            vertexShader: qe,
            fragmentShader: Ke,
            defines: M.defines,
            customVertexShaderID: We,
            customFragmentShaderID: X,
            isRawShaderMaterial: M.isRawShaderMaterial === !0,
            glslVersion: M.glslVersion,
            precision: p,
            batching: Ae,
            batchingColor: Ae && H._colorsTexture !== null,
            instancing: ke,
            instancingColor: ke && H.instanceColor !== null,
            instancingMorph: ke && H.morphTexture !== null,
            supportsVertexTextures: h,
            outputColorSpace: Q === null ? t.outputColorSpace : Q.isXRRenderTarget === !0 ? Q.texture.colorSpace : Fo,
            alphaToCoverage: !!M.alphaToCoverage,
            map: Ye,
            matcap: Kt,
            envMap: N,
            envMapMode: N && B.mapping,
            envMapCubeUVHeight: D,
            aoMap: ft,
            lightMap: Oe,
            bumpMap: Le,
            normalMap: Se,
            displacementMap: h && pt,
            emissiveMap: we,
            normalMapObjectSpace: Se && M.normalMapType === WD,
            normalMapTangentSpace: Se && M.normalMapType === GD,
            metalnessMap: Ve,
            roughnessMap: Vt,
            anisotropy: Mt,
            anisotropyMap: W,
            clearcoat: R,
            clearcoatMap: Me,
            clearcoatNormalMap: ae,
            clearcoatRoughnessMap: be,
            dispersion: w,
            iridescence: O,
            iridescenceMap: Ee,
            iridescenceThicknessMap: re,
            sheen: K,
            sheenColorMap: fe,
            sheenRoughnessMap: Ne,
            specularMap: Te,
            specularColorMap: de,
            specularIntensityMap: Be,
            transmission: ee,
            transmissionMap: I,
            thicknessMap: se,
            gradientMap: ce,
            opaque: M.transparent === !1 && M.blending === bo && M.alphaToCoverage === !1,
            alphaMap: ve,
            alphaTest: ne,
            alphaHash: J,
            combine: M.combine,
            mapUv: Ye && x(M.map.channel),
            aoMapUv: ft && x(M.aoMap.channel),
            lightMapUv: Oe && x(M.lightMap.channel),
            bumpMapUv: Le && x(M.bumpMap.channel),
            normalMapUv: Se && x(M.normalMap.channel),
            displacementMapUv: pt && x(M.displacementMap.channel),
            emissiveMapUv: we && x(M.emissiveMap.channel),
            metalnessMapUv: Ve && x(M.metalnessMap.channel),
            roughnessMapUv: Vt && x(M.roughnessMap.channel),
            anisotropyMapUv: W && x(M.anisotropyMap.channel),
            clearcoatMapUv: Me && x(M.clearcoatMap.channel),
            clearcoatNormalMapUv: ae && x(M.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: be && x(M.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Ee && x(M.iridescenceMap.channel),
            iridescenceThicknessMapUv: re && x(M.iridescenceThicknessMap.channel),
            sheenColorMapUv: fe && x(M.sheenColorMap.channel),
            sheenRoughnessMapUv: Ne && x(M.sheenRoughnessMap.channel),
            specularMapUv: Te && x(M.specularMap.channel),
            specularColorMapUv: de && x(M.specularColorMap.channel),
            specularIntensityMapUv: Be && x(M.specularIntensityMap.channel),
            transmissionMapUv: I && x(M.transmissionMap.channel),
            thicknessMapUv: se && x(M.thicknessMap.channel),
            alphaMapUv: ve && x(M.alphaMap.channel),
            vertexTangents: !!$.attributes.tangent && (Se || Mt),
            vertexColors: M.vertexColors,
            vertexAlphas: M.vertexColors === !0 && !!$.attributes.color && $.attributes.color.itemSize === 4,
            pointsUvs: H.isPoints === !0 && !!$.attributes.uv && (Ye || ve),
            fog: !!Z,
            useFog: M.fog === !0,
            fogExp2: !!Z && Z.isFogExp2,
            flatShading: M.flatShading === !0 && M.wireframe === !1,
            sizeAttenuation: M.sizeAttenuation === !0,
            logarithmicDepthBuffer: d,
            reversedDepthBuffer: ge,
            skinning: H.isSkinnedMesh === !0,
            morphTargets: $.morphAttributes.position !== void 0,
            morphNormals: $.morphAttributes.normal !== void 0,
            morphColors: $.morphAttributes.color !== void 0,
            morphTargetsCount: le,
            morphTextureStride: xe,
            numDirLights: b.directional.length,
            numPointLights: b.point.length,
            numSpotLights: b.spot.length,
            numSpotLightMaps: b.spotLightMap.length,
            numRectAreaLights: b.rectArea.length,
            numHemiLights: b.hemi.length,
            numDirLightShadows: b.directionalShadowMap.length,
            numPointLightShadows: b.pointShadowMap.length,
            numSpotLightShadows: b.spotShadowMap.length,
            numSpotLightShadowsWithMaps: b.numSpotLightShadowsWithMaps,
            numLightProbes: b.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: M.dithering,
            shadowMapEnabled: t.shadowMap.enabled && L.length > 0,
            shadowMapType: t.shadowMap.type,
            toneMapping: Ue,
            decodeVideoTexture: Ye && M.map.isVideoTexture === !0 && Qe.getTransfer(M.map.colorSpace) === rt,
            decodeVideoTextureEmissive: we && M.emissiveMap.isVideoTexture === !0 && Qe.getTransfer(M.emissiveMap.colorSpace) === rt,
            premultipliedAlpha: M.premultipliedAlpha,
            doubleSided: M.side === Ui,
            flipSided: M.side === Sn,
            useDepthPacking: M.depthPacking >= 0,
            depthPacking: M.depthPacking || 0,
            index0AttributeName: M.index0AttributeName,
            extensionClipCullDistance: ye && M.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (ye && M.extensions.multiDraw === !0 || Ae) && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: M.customProgramCacheKey()
        };
        return at.vertexUv1s = c.has(1),
        at.vertexUv2s = c.has(2),
        at.vertexUv3s = c.has(3),
        c.clear(),
        at
    }
    function f(M) {
        const b = [];
        if (M.shaderID ? b.push(M.shaderID) : (b.push(M.customVertexShaderID),
        b.push(M.customFragmentShaderID)),
        M.defines !== void 0)
            for (const L in M.defines)
                b.push(L),
                b.push(M.defines[L]);
        return M.isRawShaderMaterial === !1 && (y(b, M),
        _(b, M),
        b.push(t.outputColorSpace)),
        b.push(M.customProgramCacheKey),
        b.join()
    }
    function y(M, b) {
        M.push(b.precision),
        M.push(b.outputColorSpace),
        M.push(b.envMapMode),
        M.push(b.envMapCubeUVHeight),
        M.push(b.mapUv),
        M.push(b.alphaMapUv),
        M.push(b.lightMapUv),
        M.push(b.aoMapUv),
        M.push(b.bumpMapUv),
        M.push(b.normalMapUv),
        M.push(b.displacementMapUv),
        M.push(b.emissiveMapUv),
        M.push(b.metalnessMapUv),
        M.push(b.roughnessMapUv),
        M.push(b.anisotropyMapUv),
        M.push(b.clearcoatMapUv),
        M.push(b.clearcoatNormalMapUv),
        M.push(b.clearcoatRoughnessMapUv),
        M.push(b.iridescenceMapUv),
        M.push(b.iridescenceThicknessMapUv),
        M.push(b.sheenColorMapUv),
        M.push(b.sheenRoughnessMapUv),
        M.push(b.specularMapUv),
        M.push(b.specularColorMapUv),
        M.push(b.specularIntensityMapUv),
        M.push(b.transmissionMapUv),
        M.push(b.thicknessMapUv),
        M.push(b.combine),
        M.push(b.fogExp2),
        M.push(b.sizeAttenuation),
        M.push(b.morphTargetsCount),
        M.push(b.morphAttributeCount),
        M.push(b.numDirLights),
        M.push(b.numPointLights),
        M.push(b.numSpotLights),
        M.push(b.numSpotLightMaps),
        M.push(b.numHemiLights),
        M.push(b.numRectAreaLights),
        M.push(b.numDirLightShadows),
        M.push(b.numPointLightShadows),
        M.push(b.numSpotLightShadows),
        M.push(b.numSpotLightShadowsWithMaps),
        M.push(b.numLightProbes),
        M.push(b.shadowMapType),
        M.push(b.toneMapping),
        M.push(b.numClippingPlanes),
        M.push(b.numClipIntersection),
        M.push(b.depthPacking)
    }
    function _(M, b) {
        a.disableAll(),
        b.supportsVertexTextures && a.enable(0),
        b.instancing && a.enable(1),
        b.instancingColor && a.enable(2),
        b.instancingMorph && a.enable(3),
        b.matcap && a.enable(4),
        b.envMap && a.enable(5),
        b.normalMapObjectSpace && a.enable(6),
        b.normalMapTangentSpace && a.enable(7),
        b.clearcoat && a.enable(8),
        b.iridescence && a.enable(9),
        b.alphaTest && a.enable(10),
        b.vertexColors && a.enable(11),
        b.vertexAlphas && a.enable(12),
        b.vertexUv1s && a.enable(13),
        b.vertexUv2s && a.enable(14),
        b.vertexUv3s && a.enable(15),
        b.vertexTangents && a.enable(16),
        b.anisotropy && a.enable(17),
        b.alphaHash && a.enable(18),
        b.batching && a.enable(19),
        b.dispersion && a.enable(20),
        b.batchingColor && a.enable(21),
        b.gradientMap && a.enable(22),
        M.push(a.mask),
        a.disableAll(),
        b.fog && a.enable(0),
        b.useFog && a.enable(1),
        b.flatShading && a.enable(2),
        b.logarithmicDepthBuffer && a.enable(3),
        b.reversedDepthBuffer && a.enable(4),
        b.skinning && a.enable(5),
        b.morphTargets && a.enable(6),
        b.morphNormals && a.enable(7),
        b.morphColors && a.enable(8),
        b.premultipliedAlpha && a.enable(9),
        b.shadowMapEnabled && a.enable(10),
        b.doubleSided && a.enable(11),
        b.flipSided && a.enable(12),
        b.useDepthPacking && a.enable(13),
        b.dithering && a.enable(14),
        b.transmission && a.enable(15),
        b.sheen && a.enable(16),
        b.opaque && a.enable(17),
        b.pointsUvs && a.enable(18),
        b.decodeVideoTexture && a.enable(19),
        b.decodeVideoTextureEmissive && a.enable(20),
        b.alphaToCoverage && a.enable(21),
        M.push(a.mask)
    }
    function S(M) {
        const b = v[M.type];
        let L;
        if (b) {
            const F = gi[b];
            L = xL.clone(F.uniforms)
        } else
            L = M.uniforms;
        return L
    }
    function T(M, b) {
        let L;
        for (let F = 0, H = u.length; F < H; F++) {
            const Z = u[F];
            if (Z.cacheKey === b) {
                L = Z,
                ++L.usedTimes;
                break
            }
        }
        return L === void 0 && (L = new GU(t,b,M,s),
        u.push(L)),
        L
    }
    function A(M) {
        if (--M.usedTimes === 0) {
            const b = u.indexOf(M);
            u[b] = u[u.length - 1],
            u.pop(),
            M.destroy()
        }
    }
    function C(M) {
        l.remove(M)
    }
    function P() {
        l.dispose()
    }
    return {
        getParameters: g,
        getProgramCacheKey: f,
        getUniforms: S,
        acquireProgram: T,
        releaseProgram: A,
        releaseShaderCache: C,
        programs: u,
        dispose: P
    }
}
function KU() {
    let t = new WeakMap;
    function e(o) {
        return t.has(o)
    }
    function n(o) {
        let a = t.get(o);
        return a === void 0 && (a = {},
        t.set(o, a)),
        a
    }
    function i(o) {
        t.delete(o)
    }
    function r(o, a, l) {
        t.get(o)[a] = l
    }
    function s() {
        t = new WeakMap
    }
    return {
        has: e,
        get: n,
        remove: i,
        update: r,
        dispose: s
    }
}
function YU(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
}
function Cy(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
}
function Ry() {
    const t = [];
    let e = 0;
    const n = []
      , i = []
      , r = [];
    function s() {
        e = 0,
        n.length = 0,
        i.length = 0,
        r.length = 0
    }
    function o(d, h, p, v, x, g) {
        let f = t[e];
        return f === void 0 ? (f = {
            id: d.id,
            object: d,
            geometry: h,
            material: p,
            groupOrder: v,
            renderOrder: d.renderOrder,
            z: x,
            group: g
        },
        t[e] = f) : (f.id = d.id,
        f.object = d,
        f.geometry = h,
        f.material = p,
        f.groupOrder = v,
        f.renderOrder = d.renderOrder,
        f.z = x,
        f.group = g),
        e++,
        f
    }
    function a(d, h, p, v, x, g) {
        const f = o(d, h, p, v, x, g);
        p.transmission > 0 ? i.push(f) : p.transparent === !0 ? r.push(f) : n.push(f)
    }
    function l(d, h, p, v, x, g) {
        const f = o(d, h, p, v, x, g);
        p.transmission > 0 ? i.unshift(f) : p.transparent === !0 ? r.unshift(f) : n.unshift(f)
    }
    function c(d, h) {
        n.length > 1 && n.sort(d || YU),
        i.length > 1 && i.sort(h || Cy),
        r.length > 1 && r.sort(h || Cy)
    }
    function u() {
        for (let d = e, h = t.length; d < h; d++) {
            const p = t[d];
            if (p.id === null)
                break;
            p.id = null,
            p.object = null,
            p.geometry = null,
            p.material = null,
            p.group = null
        }
    }
    return {
        opaque: n,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: l,
        finish: u,
        sort: c
    }
}
function ZU() {
    let t = new WeakMap;
    function e(i, r) {
        const s = t.get(i);
        let o;
        return s === void 0 ? (o = new Ry,
        t.set(i, [o])) : r >= s.length ? (o = new Ry,
        s.push(o)) : o = s[r],
        o
    }
    function n() {
        t = new WeakMap
    }
    return {
        get: e,
        dispose: n
    }
}
function JU() {
    const t = {};
    return {
        get: function(e) {
            if (t[e.id] !== void 0)
                return t[e.id];
            let n;
            switch (e.type) {
            case "DirectionalLight":
                n = {
                    direction: new z,
                    color: new tt
                };
                break;
            case "SpotLight":
                n = {
                    position: new z,
                    direction: new z,
                    color: new tt,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                n = {
                    position: new z,
                    color: new tt,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                n = {
                    direction: new z,
                    skyColor: new tt,
                    groundColor: new tt
                };
                break;
            case "RectAreaLight":
                n = {
                    color: new tt,
                    position: new z,
                    halfWidth: new z,
                    halfHeight: new z
                };
                break
            }
            return t[e.id] = n,
            n
        }
    }
}
function QU() {
    const t = {};
    return {
        get: function(e) {
            if (t[e.id] !== void 0)
                return t[e.id];
            let n;
            switch (e.type) {
            case "DirectionalLight":
                n = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new st
                };
                break;
            case "SpotLight":
                n = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new st
                };
                break;
            case "PointLight":
                n = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new st,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return t[e.id] = n,
            n
        }
    }
}
let eO = 0;
function tO(t, e) {
    return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
}
function nO(t) {
    const e = new JU
      , n = QU()
      , i = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let c = 0; c < 9; c++)
        i.probe.push(new z);
    const r = new z
      , s = new Lt
      , o = new Lt;
    function a(c) {
        let u = 0
          , d = 0
          , h = 0;
        for (let M = 0; M < 9; M++)
            i.probe[M].set(0, 0, 0);
        let p = 0
          , v = 0
          , x = 0
          , g = 0
          , f = 0
          , y = 0
          , _ = 0
          , S = 0
          , T = 0
          , A = 0
          , C = 0;
        c.sort(tO);
        for (let M = 0, b = c.length; M < b; M++) {
            const L = c[M]
              , F = L.color
              , H = L.intensity
              , Z = L.distance
              , $ = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
            if (L.isAmbientLight)
                u += F.r * H,
                d += F.g * H,
                h += F.b * H;
            else if (L.isLightProbe) {
                for (let q = 0; q < 9; q++)
                    i.probe[q].addScaledVector(L.sh.coefficients[q], H);
                C++
            } else if (L.isDirectionalLight) {
                const q = e.get(L);
                if (q.color.copy(L.color).multiplyScalar(L.intensity),
                L.castShadow) {
                    const B = L.shadow
                      , D = n.get(L);
                    D.shadowIntensity = B.intensity,
                    D.shadowBias = B.bias,
                    D.shadowNormalBias = B.normalBias,
                    D.shadowRadius = B.radius,
                    D.shadowMapSize = B.mapSize,
                    i.directionalShadow[p] = D,
                    i.directionalShadowMap[p] = $,
                    i.directionalShadowMatrix[p] = L.shadow.matrix,
                    y++
                }
                i.directional[p] = q,
                p++
            } else if (L.isSpotLight) {
                const q = e.get(L);
                q.position.setFromMatrixPosition(L.matrixWorld),
                q.color.copy(F).multiplyScalar(H),
                q.distance = Z,
                q.coneCos = Math.cos(L.angle),
                q.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)),
                q.decay = L.decay,
                i.spot[x] = q;
                const B = L.shadow;
                if (L.map && (i.spotLightMap[T] = L.map,
                T++,
                B.updateMatrices(L),
                L.castShadow && A++),
                i.spotLightMatrix[x] = B.matrix,
                L.castShadow) {
                    const D = n.get(L);
                    D.shadowIntensity = B.intensity,
                    D.shadowBias = B.bias,
                    D.shadowNormalBias = B.normalBias,
                    D.shadowRadius = B.radius,
                    D.shadowMapSize = B.mapSize,
                    i.spotShadow[x] = D,
                    i.spotShadowMap[x] = $,
                    S++
                }
                x++
            } else if (L.isRectAreaLight) {
                const q = e.get(L);
                q.color.copy(F).multiplyScalar(H),
                q.halfWidth.set(L.width * .5, 0, 0),
                q.halfHeight.set(0, L.height * .5, 0),
                i.rectArea[g] = q,
                g++
            } else if (L.isPointLight) {
                const q = e.get(L);
                if (q.color.copy(L.color).multiplyScalar(L.intensity),
                q.distance = L.distance,
                q.decay = L.decay,
                L.castShadow) {
                    const B = L.shadow
                      , D = n.get(L);
                    D.shadowIntensity = B.intensity,
                    D.shadowBias = B.bias,
                    D.shadowNormalBias = B.normalBias,
                    D.shadowRadius = B.radius,
                    D.shadowMapSize = B.mapSize,
                    D.shadowCameraNear = B.camera.near,
                    D.shadowCameraFar = B.camera.far,
                    i.pointShadow[v] = D,
                    i.pointShadowMap[v] = $,
                    i.pointShadowMatrix[v] = L.shadow.matrix,
                    _++
                }
                i.point[v] = q,
                v++
            } else if (L.isHemisphereLight) {
                const q = e.get(L);
                q.skyColor.copy(L.color).multiplyScalar(H),
                q.groundColor.copy(L.groundColor).multiplyScalar(H),
                i.hemi[f] = q,
                f++
            }
        }
        g > 0 && (t.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = ue.LTC_FLOAT_1,
        i.rectAreaLTC2 = ue.LTC_FLOAT_2) : (i.rectAreaLTC1 = ue.LTC_HALF_1,
        i.rectAreaLTC2 = ue.LTC_HALF_2)),
        i.ambient[0] = u,
        i.ambient[1] = d,
        i.ambient[2] = h;
        const P = i.hash;
        (P.directionalLength !== p || P.pointLength !== v || P.spotLength !== x || P.rectAreaLength !== g || P.hemiLength !== f || P.numDirectionalShadows !== y || P.numPointShadows !== _ || P.numSpotShadows !== S || P.numSpotMaps !== T || P.numLightProbes !== C) && (i.directional.length = p,
        i.spot.length = x,
        i.rectArea.length = g,
        i.point.length = v,
        i.hemi.length = f,
        i.directionalShadow.length = y,
        i.directionalShadowMap.length = y,
        i.pointShadow.length = _,
        i.pointShadowMap.length = _,
        i.spotShadow.length = S,
        i.spotShadowMap.length = S,
        i.directionalShadowMatrix.length = y,
        i.pointShadowMatrix.length = _,
        i.spotLightMatrix.length = S + T - A,
        i.spotLightMap.length = T,
        i.numSpotLightShadowsWithMaps = A,
        i.numLightProbes = C,
        P.directionalLength = p,
        P.pointLength = v,
        P.spotLength = x,
        P.rectAreaLength = g,
        P.hemiLength = f,
        P.numDirectionalShadows = y,
        P.numPointShadows = _,
        P.numSpotShadows = S,
        P.numSpotMaps = T,
        P.numLightProbes = C,
        i.version = eO++)
    }
    function l(c, u) {
        let d = 0
          , h = 0
          , p = 0
          , v = 0
          , x = 0;
        const g = u.matrixWorldInverse;
        for (let f = 0, y = c.length; f < y; f++) {
            const _ = c[f];
            if (_.isDirectionalLight) {
                const S = i.directional[d];
                S.direction.setFromMatrixPosition(_.matrixWorld),
                r.setFromMatrixPosition(_.target.matrixWorld),
                S.direction.sub(r),
                S.direction.transformDirection(g),
                d++
            } else if (_.isSpotLight) {
                const S = i.spot[p];
                S.position.setFromMatrixPosition(_.matrixWorld),
                S.position.applyMatrix4(g),
                S.direction.setFromMatrixPosition(_.matrixWorld),
                r.setFromMatrixPosition(_.target.matrixWorld),
                S.direction.sub(r),
                S.direction.transformDirection(g),
                p++
            } else if (_.isRectAreaLight) {
                const S = i.rectArea[v];
                S.position.setFromMatrixPosition(_.matrixWorld),
                S.position.applyMatrix4(g),
                o.identity(),
                s.copy(_.matrixWorld),
                s.premultiply(g),
                o.extractRotation(s),
                S.halfWidth.set(_.width * .5, 0, 0),
                S.halfHeight.set(0, _.height * .5, 0),
                S.halfWidth.applyMatrix4(o),
                S.halfHeight.applyMatrix4(o),
                v++
            } else if (_.isPointLight) {
                const S = i.point[h];
                S.position.setFromMatrixPosition(_.matrixWorld),
                S.position.applyMatrix4(g),
                h++
            } else if (_.isHemisphereLight) {
                const S = i.hemi[x];
                S.direction.setFromMatrixPosition(_.matrixWorld),
                S.direction.transformDirection(g),
                x++
            }
        }
    }
    return {
        setup: a,
        setupView: l,
        state: i
    }
}
function Py(t) {
    const e = new nO(t)
      , n = []
      , i = [];
    function r(u) {
        c.camera = u,
        n.length = 0,
        i.length = 0
    }
    function s(u) {
        n.push(u)
    }
    function o(u) {
        i.push(u)
    }
    function a() {
        e.setup(n)
    }
    function l(u) {
        e.setupView(n, u)
    }
    const c = {
        lightsArray: n,
        shadowsArray: i,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: r,
        state: c,
        setupLights: a,
        setupLightsView: l,
        pushLight: s,
        pushShadow: o
    }
}
function iO(t) {
    let e = new WeakMap;
    function n(r, s=0) {
        const o = e.get(r);
        let a;
        return o === void 0 ? (a = new Py(t),
        e.set(r, [a])) : s >= o.length ? (a = new Py(t),
        o.push(a)) : a = o[s],
        a
    }
    function i() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: i
    }
}
const rO = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , sO = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function oO(t, e, n) {
    let i = new pE;
    const r = new st
      , s = new st
      , o = new Rt
      , a = new NL({
        depthPacking: HD
    })
      , l = new DL
      , c = {}
      , u = n.maxTextureSize
      , d = {
        [Lr]: Sn,
        [Sn]: Lr,
        [Ui]: Ui
    }
      , h = new Ir({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new st
            },
            radius: {
                value: 4
            }
        },
        vertexShader: rO,
        fragmentShader: sO
    })
      , p = h.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const v = new Qi;
    v.setAttribute("position", new Ei(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const x = new zi(v,h)
      , g = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = Wb;
    let f = this.type;
    this.render = function(A, C, P) {
        if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || A.length === 0)
            return;
        const M = t.getRenderTarget()
          , b = t.getActiveCubeFace()
          , L = t.getActiveMipmapLevel()
          , F = t.state;
        F.setBlending(Ar),
        F.buffers.depth.getReversed() === !0 ? F.buffers.color.setClear(0, 0, 0, 0) : F.buffers.color.setClear(1, 1, 1, 1),
        F.buffers.depth.setTest(!0),
        F.setScissorTest(!1);
        const H = f !== Di && this.type === Di
          , Z = f === Di && this.type !== Di;
        for (let $ = 0, q = A.length; $ < q; $++) {
            const B = A[$]
              , D = B.shadow;
            if (D === void 0) {
                console.warn("THREE.WebGLShadowMap:", B, "has no shadow.");
                continue
            }
            if (D.autoUpdate === !1 && D.needsUpdate === !1)
                continue;
            r.copy(D.mapSize);
            const G = D.getFrameExtents();
            if (r.multiply(G),
            s.copy(D.mapSize),
            (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / G.x),
            r.x = s.x * G.x,
            D.mapSize.x = s.x),
            r.y > u && (s.y = Math.floor(u / G.y),
            r.y = s.y * G.y,
            D.mapSize.y = s.y)),
            D.map === null || H === !0 || Z === !0) {
                const le = this.type !== Di ? {
                    minFilter: ui,
                    magFilter: ui
                } : {};
                D.map !== null && D.map.dispose(),
                D.map = new bs(r.x,r.y,le),
                D.map.texture.name = B.name + ".shadowMap",
                D.camera.updateProjectionMatrix()
            }
            t.setRenderTarget(D.map),
            t.clear();
            const Y = D.getViewportCount();
            for (let le = 0; le < Y; le++) {
                const xe = D.getViewport(le);
                o.set(s.x * xe.x, s.y * xe.y, s.x * xe.z, s.y * xe.w),
                F.viewport(o),
                D.updateMatrices(B, le),
                i = D.getFrustum(),
                S(C, P, D.camera, B, this.type)
            }
            D.isPointLightShadow !== !0 && this.type === Di && y(D, P),
            D.needsUpdate = !1
        }
        f = this.type,
        g.needsUpdate = !1,
        t.setRenderTarget(M, b, L)
    }
    ;
    function y(A, C) {
        const P = e.update(x);
        h.defines.VSM_SAMPLES !== A.blurSamples && (h.defines.VSM_SAMPLES = A.blurSamples,
        p.defines.VSM_SAMPLES = A.blurSamples,
        h.needsUpdate = !0,
        p.needsUpdate = !0),
        A.mapPass === null && (A.mapPass = new bs(r.x,r.y)),
        h.uniforms.shadow_pass.value = A.map.texture,
        h.uniforms.resolution.value = A.mapSize,
        h.uniforms.radius.value = A.radius,
        t.setRenderTarget(A.mapPass),
        t.clear(),
        t.renderBufferDirect(C, null, P, h, x, null),
        p.uniforms.shadow_pass.value = A.mapPass.texture,
        p.uniforms.resolution.value = A.mapSize,
        p.uniforms.radius.value = A.radius,
        t.setRenderTarget(A.map),
        t.clear(),
        t.renderBufferDirect(C, null, P, p, x, null)
    }
    function _(A, C, P, M) {
        let b = null;
        const L = P.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
        if (L !== void 0)
            b = L;
        else if (b = P.isPointLight === !0 ? l : a,
        t.localClippingEnabled && C.clipShadows === !0 && Array.isArray(C.clippingPlanes) && C.clippingPlanes.length !== 0 || C.displacementMap && C.displacementScale !== 0 || C.alphaMap && C.alphaTest > 0 || C.map && C.alphaTest > 0 || C.alphaToCoverage === !0) {
            const F = b.uuid
              , H = C.uuid;
            let Z = c[F];
            Z === void 0 && (Z = {},
            c[F] = Z);
            let $ = Z[H];
            $ === void 0 && ($ = b.clone(),
            Z[H] = $,
            C.addEventListener("dispose", T)),
            b = $
        }
        if (b.visible = C.visible,
        b.wireframe = C.wireframe,
        M === Di ? b.side = C.shadowSide !== null ? C.shadowSide : C.side : b.side = C.shadowSide !== null ? C.shadowSide : d[C.side],
        b.alphaMap = C.alphaMap,
        b.alphaTest = C.alphaToCoverage === !0 ? .5 : C.alphaTest,
        b.map = C.map,
        b.clipShadows = C.clipShadows,
        b.clippingPlanes = C.clippingPlanes,
        b.clipIntersection = C.clipIntersection,
        b.displacementMap = C.displacementMap,
        b.displacementScale = C.displacementScale,
        b.displacementBias = C.displacementBias,
        b.wireframeLinewidth = C.wireframeLinewidth,
        b.linewidth = C.linewidth,
        P.isPointLight === !0 && b.isMeshDistanceMaterial === !0) {
            const F = t.properties.get(b);
            F.light = P
        }
        return b
    }
    function S(A, C, P, M, b) {
        if (A.visible === !1)
            return;
        if (A.layers.test(C.layers) && (A.isMesh || A.isLine || A.isPoints) && (A.castShadow || A.receiveShadow && b === Di) && (!A.frustumCulled || i.intersectsObject(A))) {
            A.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, A.matrixWorld);
            const H = e.update(A)
              , Z = A.material;
            if (Array.isArray(Z)) {
                const $ = H.groups;
                for (let q = 0, B = $.length; q < B; q++) {
                    const D = $[q]
                      , G = Z[D.materialIndex];
                    if (G && G.visible) {
                        const Y = _(A, G, M, b);
                        A.onBeforeShadow(t, A, C, P, H, Y, D),
                        t.renderBufferDirect(P, null, H, Y, A, D),
                        A.onAfterShadow(t, A, C, P, H, Y, D)
                    }
                }
            } else if (Z.visible) {
                const $ = _(A, Z, M, b);
                A.onBeforeShadow(t, A, C, P, H, $, null),
                t.renderBufferDirect(P, null, H, $, A, null),
                A.onAfterShadow(t, A, C, P, H, $, null)
            }
        }
        const F = A.children;
        for (let H = 0, Z = F.length; H < Z; H++)
            S(F[H], C, P, M, b)
    }
    function T(A) {
        A.target.removeEventListener("dispose", T);
        for (const P in c) {
            const M = c[P]
              , b = A.target.uuid;
            b in M && (M[b].dispose(),
            delete M[b])
        }
    }
}
const aO = {
    [hp]: fp,
    [pp]: vp,
    [mp]: _p,
    [ko]: gp,
    [fp]: hp,
    [vp]: pp,
    [_p]: mp,
    [gp]: ko
};
function lO(t, e) {
    function n() {
        let I = !1;
        const se = new Rt;
        let ce = null;
        const ve = new Rt(0,0,0,0);
        return {
            setMask: function(ne) {
                ce !== ne && !I && (t.colorMask(ne, ne, ne, ne),
                ce = ne)
            },
            setLocked: function(ne) {
                I = ne
            },
            setClear: function(ne, J, ye, Ue, at) {
                at === !0 && (ne *= Ue,
                J *= Ue,
                ye *= Ue),
                se.set(ne, J, ye, Ue),
                ve.equals(se) === !1 && (t.clearColor(ne, J, ye, Ue),
                ve.copy(se))
            },
            reset: function() {
                I = !1,
                ce = null,
                ve.set(-1, 0, 0, 0)
            }
        }
    }
    function i() {
        let I = !1
          , se = !1
          , ce = null
          , ve = null
          , ne = null;
        return {
            setReversed: function(J) {
                if (se !== J) {
                    const ye = e.get("EXT_clip_control");
                    J ? ye.clipControlEXT(ye.LOWER_LEFT_EXT, ye.ZERO_TO_ONE_EXT) : ye.clipControlEXT(ye.LOWER_LEFT_EXT, ye.NEGATIVE_ONE_TO_ONE_EXT),
                    se = J;
                    const Ue = ne;
                    ne = null,
                    this.setClear(Ue)
                }
            },
            getReversed: function() {
                return se
            },
            setTest: function(J) {
                J ? Q(t.DEPTH_TEST) : ge(t.DEPTH_TEST)
            },
            setMask: function(J) {
                ce !== J && !I && (t.depthMask(J),
                ce = J)
            },
            setFunc: function(J) {
                if (se && (J = aO[J]),
                ve !== J) {
                    switch (J) {
                    case hp:
                        t.depthFunc(t.NEVER);
                        break;
                    case fp:
                        t.depthFunc(t.ALWAYS);
                        break;
                    case pp:
                        t.depthFunc(t.LESS);
                        break;
                    case ko:
                        t.depthFunc(t.LEQUAL);
                        break;
                    case mp:
                        t.depthFunc(t.EQUAL);
                        break;
                    case gp:
                        t.depthFunc(t.GEQUAL);
                        break;
                    case vp:
                        t.depthFunc(t.GREATER);
                        break;
                    case _p:
                        t.depthFunc(t.NOTEQUAL);
                        break;
                    default:
                        t.depthFunc(t.LEQUAL)
                    }
                    ve = J
                }
            },
            setLocked: function(J) {
                I = J
            },
            setClear: function(J) {
                ne !== J && (se && (J = 1 - J),
                t.clearDepth(J),
                ne = J)
            },
            reset: function() {
                I = !1,
                ce = null,
                ve = null,
                ne = null,
                se = !1
            }
        }
    }
    function r() {
        let I = !1
          , se = null
          , ce = null
          , ve = null
          , ne = null
          , J = null
          , ye = null
          , Ue = null
          , at = null;
        return {
            setTest: function(et) {
                I || (et ? Q(t.STENCIL_TEST) : ge(t.STENCIL_TEST))
            },
            setMask: function(et) {
                se !== et && !I && (t.stencilMask(et),
                se = et)
            },
            setFunc: function(et, Ti, hi) {
                (ce !== et || ve !== Ti || ne !== hi) && (t.stencilFunc(et, Ti, hi),
                ce = et,
                ve = Ti,
                ne = hi)
            },
            setOp: function(et, Ti, hi) {
                (J !== et || ye !== Ti || Ue !== hi) && (t.stencilOp(et, Ti, hi),
                J = et,
                ye = Ti,
                Ue = hi)
            },
            setLocked: function(et) {
                I = et
            },
            setClear: function(et) {
                at !== et && (t.clearStencil(et),
                at = et)
            },
            reset: function() {
                I = !1,
                se = null,
                ce = null,
                ve = null,
                ne = null,
                J = null,
                ye = null,
                Ue = null,
                at = null
            }
        }
    }
    const s = new n
      , o = new i
      , a = new r
      , l = new WeakMap
      , c = new WeakMap;
    let u = {}
      , d = {}
      , h = new WeakMap
      , p = []
      , v = null
      , x = !1
      , g = null
      , f = null
      , y = null
      , _ = null
      , S = null
      , T = null
      , A = null
      , C = new tt(0,0,0)
      , P = 0
      , M = !1
      , b = null
      , L = null
      , F = null
      , H = null
      , Z = null;
    const $ = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let q = !1
      , B = 0;
    const D = t.getParameter(t.VERSION);
    D.indexOf("WebGL") !== -1 ? (B = parseFloat(/^WebGL (\d)/.exec(D)[1]),
    q = B >= 1) : D.indexOf("OpenGL ES") !== -1 && (B = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]),
    q = B >= 2);
    let G = null
      , Y = {};
    const le = t.getParameter(t.SCISSOR_BOX)
      , xe = t.getParameter(t.VIEWPORT)
      , qe = new Rt().fromArray(le)
      , Ke = new Rt().fromArray(xe);
    function We(I, se, ce, ve) {
        const ne = new Uint8Array(4)
          , J = t.createTexture();
        t.bindTexture(I, J),
        t.texParameteri(I, t.TEXTURE_MIN_FILTER, t.NEAREST),
        t.texParameteri(I, t.TEXTURE_MAG_FILTER, t.NEAREST);
        for (let ye = 0; ye < ce; ye++)
            I === t.TEXTURE_3D || I === t.TEXTURE_2D_ARRAY ? t.texImage3D(se, 0, t.RGBA, 1, 1, ve, 0, t.RGBA, t.UNSIGNED_BYTE, ne) : t.texImage2D(se + ye, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, ne);
        return J
    }
    const X = {};
    X[t.TEXTURE_2D] = We(t.TEXTURE_2D, t.TEXTURE_2D, 1),
    X[t.TEXTURE_CUBE_MAP] = We(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    X[t.TEXTURE_2D_ARRAY] = We(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1),
    X[t.TEXTURE_3D] = We(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    Q(t.DEPTH_TEST),
    o.setFunc(ko),
    Le(!1),
    Se(k_),
    Q(t.CULL_FACE),
    ft(Ar);
    function Q(I) {
        u[I] !== !0 && (t.enable(I),
        u[I] = !0)
    }
    function ge(I) {
        u[I] !== !1 && (t.disable(I),
        u[I] = !1)
    }
    function ke(I, se) {
        return d[I] !== se ? (t.bindFramebuffer(I, se),
        d[I] = se,
        I === t.DRAW_FRAMEBUFFER && (d[t.FRAMEBUFFER] = se),
        I === t.FRAMEBUFFER && (d[t.DRAW_FRAMEBUFFER] = se),
        !0) : !1
    }
    function Ae(I, se) {
        let ce = p
          , ve = !1;
        if (I) {
            ce = h.get(se),
            ce === void 0 && (ce = [],
            h.set(se, ce));
            const ne = I.textures;
            if (ce.length !== ne.length || ce[0] !== t.COLOR_ATTACHMENT0) {
                for (let J = 0, ye = ne.length; J < ye; J++)
                    ce[J] = t.COLOR_ATTACHMENT0 + J;
                ce.length = ne.length,
                ve = !0
            }
        } else
            ce[0] !== t.BACK && (ce[0] = t.BACK,
            ve = !0);
        ve && t.drawBuffers(ce)
    }
    function Ye(I) {
        return v !== I ? (t.useProgram(I),
        v = I,
        !0) : !1
    }
    const Kt = {
        [rs]: t.FUNC_ADD,
        [mD]: t.FUNC_SUBTRACT,
        [gD]: t.FUNC_REVERSE_SUBTRACT
    };
    Kt[vD] = t.MIN,
    Kt[_D] = t.MAX;
    const N = {
        [yD]: t.ZERO,
        [xD]: t.ONE,
        [SD]: t.SRC_COLOR,
        [up]: t.SRC_ALPHA,
        [AD]: t.SRC_ALPHA_SATURATE,
        [TD]: t.DST_COLOR,
        [bD]: t.DST_ALPHA,
        [wD]: t.ONE_MINUS_SRC_COLOR,
        [dp]: t.ONE_MINUS_SRC_ALPHA,
        [MD]: t.ONE_MINUS_DST_COLOR,
        [ED]: t.ONE_MINUS_DST_ALPHA,
        [CD]: t.CONSTANT_COLOR,
        [RD]: t.ONE_MINUS_CONSTANT_COLOR,
        [PD]: t.CONSTANT_ALPHA,
        [ND]: t.ONE_MINUS_CONSTANT_ALPHA
    };
    function ft(I, se, ce, ve, ne, J, ye, Ue, at, et) {
        if (I === Ar) {
            x === !0 && (ge(t.BLEND),
            x = !1);
            return
        }
        if (x === !1 && (Q(t.BLEND),
        x = !0),
        I !== pD) {
            if (I !== g || et !== M) {
                if ((f !== rs || S !== rs) && (t.blendEquation(t.FUNC_ADD),
                f = rs,
                S = rs),
                et)
                    switch (I) {
                    case bo:
                        t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                        break;
                    case cp:
                        t.blendFunc(t.ONE, t.ONE);
                        break;
                    case U_:
                        t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                        break;
                    case O_:
                        t.blendFuncSeparate(t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ZERO, t.ONE);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", I);
                        break
                    }
                else
                    switch (I) {
                    case bo:
                        t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                        break;
                    case cp:
                        t.blendFuncSeparate(t.SRC_ALPHA, t.ONE, t.ONE, t.ONE);
                        break;
                    case U_:
                        console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                        break;
                    case O_:
                        console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", I);
                        break
                    }
                y = null,
                _ = null,
                T = null,
                A = null,
                C.set(0, 0, 0),
                P = 0,
                g = I,
                M = et
            }
            return
        }
        ne = ne || se,
        J = J || ce,
        ye = ye || ve,
        (se !== f || ne !== S) && (t.blendEquationSeparate(Kt[se], Kt[ne]),
        f = se,
        S = ne),
        (ce !== y || ve !== _ || J !== T || ye !== A) && (t.blendFuncSeparate(N[ce], N[ve], N[J], N[ye]),
        y = ce,
        _ = ve,
        T = J,
        A = ye),
        (Ue.equals(C) === !1 || at !== P) && (t.blendColor(Ue.r, Ue.g, Ue.b, at),
        C.copy(Ue),
        P = at),
        g = I,
        M = !1
    }
    function Oe(I, se) {
        I.side === Ui ? ge(t.CULL_FACE) : Q(t.CULL_FACE);
        let ce = I.side === Sn;
        se && (ce = !ce),
        Le(ce),
        I.blending === bo && I.transparent === !1 ? ft(Ar) : ft(I.blending, I.blendEquation, I.blendSrc, I.blendDst, I.blendEquationAlpha, I.blendSrcAlpha, I.blendDstAlpha, I.blendColor, I.blendAlpha, I.premultipliedAlpha),
        o.setFunc(I.depthFunc),
        o.setTest(I.depthTest),
        o.setMask(I.depthWrite),
        s.setMask(I.colorWrite);
        const ve = I.stencilWrite;
        a.setTest(ve),
        ve && (a.setMask(I.stencilWriteMask),
        a.setFunc(I.stencilFunc, I.stencilRef, I.stencilFuncMask),
        a.setOp(I.stencilFail, I.stencilZFail, I.stencilZPass)),
        we(I.polygonOffset, I.polygonOffsetFactor, I.polygonOffsetUnits),
        I.alphaToCoverage === !0 ? Q(t.SAMPLE_ALPHA_TO_COVERAGE) : ge(t.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function Le(I) {
        b !== I && (I ? t.frontFace(t.CW) : t.frontFace(t.CCW),
        b = I)
    }
    function Se(I) {
        I !== dD ? (Q(t.CULL_FACE),
        I !== L && (I === k_ ? t.cullFace(t.BACK) : I === hD ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : ge(t.CULL_FACE),
        L = I
    }
    function pt(I) {
        I !== F && (q && t.lineWidth(I),
        F = I)
    }
    function we(I, se, ce) {
        I ? (Q(t.POLYGON_OFFSET_FILL),
        (H !== se || Z !== ce) && (t.polygonOffset(se, ce),
        H = se,
        Z = ce)) : ge(t.POLYGON_OFFSET_FILL)
    }
    function Ve(I) {
        I ? Q(t.SCISSOR_TEST) : ge(t.SCISSOR_TEST)
    }
    function Vt(I) {
        I === void 0 && (I = t.TEXTURE0 + $ - 1),
        G !== I && (t.activeTexture(I),
        G = I)
    }
    function Mt(I, se, ce) {
        ce === void 0 && (G === null ? ce = t.TEXTURE0 + $ - 1 : ce = G);
        let ve = Y[ce];
        ve === void 0 && (ve = {
            type: void 0,
            texture: void 0
        },
        Y[ce] = ve),
        (ve.type !== I || ve.texture !== se) && (G !== ce && (t.activeTexture(ce),
        G = ce),
        t.bindTexture(I, se || X[I]),
        ve.type = I,
        ve.texture = se)
    }
    function R() {
        const I = Y[G];
        I !== void 0 && I.type !== void 0 && (t.bindTexture(I.type, null),
        I.type = void 0,
        I.texture = void 0)
    }
    function w() {
        try {
            t.compressedTexImage2D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function O() {
        try {
            t.compressedTexImage3D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function K() {
        try {
            t.texSubImage2D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function ee() {
        try {
            t.texSubImage3D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function W() {
        try {
            t.compressedTexSubImage2D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function Me() {
        try {
            t.compressedTexSubImage3D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function ae() {
        try {
            t.texStorage2D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function be() {
        try {
            t.texStorage3D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function Ee() {
        try {
            t.texImage2D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function re() {
        try {
            t.texImage3D(...arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function fe(I) {
        qe.equals(I) === !1 && (t.scissor(I.x, I.y, I.z, I.w),
        qe.copy(I))
    }
    function Ne(I) {
        Ke.equals(I) === !1 && (t.viewport(I.x, I.y, I.z, I.w),
        Ke.copy(I))
    }
    function Te(I, se) {
        let ce = c.get(se);
        ce === void 0 && (ce = new WeakMap,
        c.set(se, ce));
        let ve = ce.get(I);
        ve === void 0 && (ve = t.getUniformBlockIndex(se, I.name),
        ce.set(I, ve))
    }
    function de(I, se) {
        const ve = c.get(se).get(I);
        l.get(se) !== ve && (t.uniformBlockBinding(se, ve, I.__bindingPointIndex),
        l.set(se, ve))
    }
    function Be() {
        t.disable(t.BLEND),
        t.disable(t.CULL_FACE),
        t.disable(t.DEPTH_TEST),
        t.disable(t.POLYGON_OFFSET_FILL),
        t.disable(t.SCISSOR_TEST),
        t.disable(t.STENCIL_TEST),
        t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
        t.blendEquation(t.FUNC_ADD),
        t.blendFunc(t.ONE, t.ZERO),
        t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
        t.blendColor(0, 0, 0, 0),
        t.colorMask(!0, !0, !0, !0),
        t.clearColor(0, 0, 0, 0),
        t.depthMask(!0),
        t.depthFunc(t.LESS),
        o.setReversed(!1),
        t.clearDepth(1),
        t.stencilMask(4294967295),
        t.stencilFunc(t.ALWAYS, 0, 4294967295),
        t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
        t.clearStencil(0),
        t.cullFace(t.BACK),
        t.frontFace(t.CCW),
        t.polygonOffset(0, 0),
        t.activeTexture(t.TEXTURE0),
        t.bindFramebuffer(t.FRAMEBUFFER, null),
        t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
        t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
        t.useProgram(null),
        t.lineWidth(1),
        t.scissor(0, 0, t.canvas.width, t.canvas.height),
        t.viewport(0, 0, t.canvas.width, t.canvas.height),
        u = {},
        G = null,
        Y = {},
        d = {},
        h = new WeakMap,
        p = [],
        v = null,
        x = !1,
        g = null,
        f = null,
        y = null,
        _ = null,
        S = null,
        T = null,
        A = null,
        C = new tt(0,0,0),
        P = 0,
        M = !1,
        b = null,
        L = null,
        F = null,
        H = null,
        Z = null,
        qe.set(0, 0, t.canvas.width, t.canvas.height),
        Ke.set(0, 0, t.canvas.width, t.canvas.height),
        s.reset(),
        o.reset(),
        a.reset()
    }
    return {
        buffers: {
            color: s,
            depth: o,
            stencil: a
        },
        enable: Q,
        disable: ge,
        bindFramebuffer: ke,
        drawBuffers: Ae,
        useProgram: Ye,
        setBlending: ft,
        setMaterial: Oe,
        setFlipSided: Le,
        setCullFace: Se,
        setLineWidth: pt,
        setPolygonOffset: we,
        setScissorTest: Ve,
        activeTexture: Vt,
        bindTexture: Mt,
        unbindTexture: R,
        compressedTexImage2D: w,
        compressedTexImage3D: O,
        texImage2D: Ee,
        texImage3D: re,
        updateUBOMapping: Te,
        uniformBlockBinding: de,
        texStorage2D: ae,
        texStorage3D: be,
        texSubImage2D: K,
        texSubImage3D: ee,
        compressedTexSubImage2D: W,
        compressedTexSubImage3D: Me,
        scissor: fe,
        viewport: Ne,
        reset: Be
    }
}
function cO(t, e, n, i, r, s, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , c = new st
      , u = new WeakMap;
    let d;
    const h = new WeakMap;
    let p = !1;
    try {
        p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function v(R, w) {
        return p ? new OffscreenCanvas(R,w) : Du("canvas")
    }
    function x(R, w, O) {
        let K = 1;
        const ee = Mt(R);
        if ((ee.width > O || ee.height > O) && (K = O / Math.max(ee.width, ee.height)),
        K < 1)
            if (typeof HTMLImageElement < "u" && R instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && R instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && R instanceof ImageBitmap || typeof VideoFrame < "u" && R instanceof VideoFrame) {
                const W = Math.floor(K * ee.width)
                  , Me = Math.floor(K * ee.height);
                d === void 0 && (d = v(W, Me));
                const ae = w ? v(W, Me) : d;
                return ae.width = W,
                ae.height = Me,
                ae.getContext("2d").drawImage(R, 0, 0, W, Me),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ee.width + "x" + ee.height + ") to (" + W + "x" + Me + ")."),
                ae
            } else
                return "data"in R && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ee.width + "x" + ee.height + ")."),
                R;
        return R
    }
    function g(R) {
        return R.generateMipmaps
    }
    function f(R) {
        t.generateMipmap(R)
    }
    function y(R) {
        return R.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : R.isWebGL3DRenderTarget ? t.TEXTURE_3D : R.isWebGLArrayRenderTarget || R.isCompressedArrayTexture ? t.TEXTURE_2D_ARRAY : t.TEXTURE_2D
    }
    function _(R, w, O, K, ee=!1) {
        if (R !== null) {
            if (t[R] !== void 0)
                return t[R];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + R + "'")
        }
        let W = w;
        if (w === t.RED && (O === t.FLOAT && (W = t.R32F),
        O === t.HALF_FLOAT && (W = t.R16F),
        O === t.UNSIGNED_BYTE && (W = t.R8)),
        w === t.RED_INTEGER && (O === t.UNSIGNED_BYTE && (W = t.R8UI),
        O === t.UNSIGNED_SHORT && (W = t.R16UI),
        O === t.UNSIGNED_INT && (W = t.R32UI),
        O === t.BYTE && (W = t.R8I),
        O === t.SHORT && (W = t.R16I),
        O === t.INT && (W = t.R32I)),
        w === t.RG && (O === t.FLOAT && (W = t.RG32F),
        O === t.HALF_FLOAT && (W = t.RG16F),
        O === t.UNSIGNED_BYTE && (W = t.RG8)),
        w === t.RG_INTEGER && (O === t.UNSIGNED_BYTE && (W = t.RG8UI),
        O === t.UNSIGNED_SHORT && (W = t.RG16UI),
        O === t.UNSIGNED_INT && (W = t.RG32UI),
        O === t.BYTE && (W = t.RG8I),
        O === t.SHORT && (W = t.RG16I),
        O === t.INT && (W = t.RG32I)),
        w === t.RGB_INTEGER && (O === t.UNSIGNED_BYTE && (W = t.RGB8UI),
        O === t.UNSIGNED_SHORT && (W = t.RGB16UI),
        O === t.UNSIGNED_INT && (W = t.RGB32UI),
        O === t.BYTE && (W = t.RGB8I),
        O === t.SHORT && (W = t.RGB16I),
        O === t.INT && (W = t.RGB32I)),
        w === t.RGBA_INTEGER && (O === t.UNSIGNED_BYTE && (W = t.RGBA8UI),
        O === t.UNSIGNED_SHORT && (W = t.RGBA16UI),
        O === t.UNSIGNED_INT && (W = t.RGBA32UI),
        O === t.BYTE && (W = t.RGBA8I),
        O === t.SHORT && (W = t.RGBA16I),
        O === t.INT && (W = t.RGBA32I)),
        w === t.RGB && (O === t.UNSIGNED_INT_5_9_9_9_REV && (W = t.RGB9_E5),
        O === t.UNSIGNED_INT_10F_11F_11F_REV && (W = t.R11F_G11F_B10F)),
        w === t.RGBA) {
            const Me = ee ? Pu : Qe.getTransfer(K);
            O === t.FLOAT && (W = t.RGBA32F),
            O === t.HALF_FLOAT && (W = t.RGBA16F),
            O === t.UNSIGNED_BYTE && (W = Me === rt ? t.SRGB8_ALPHA8 : t.RGBA8),
            O === t.UNSIGNED_SHORT_4_4_4_4 && (W = t.RGBA4),
            O === t.UNSIGNED_SHORT_5_5_5_1 && (W = t.RGB5_A1)
        }
        return (W === t.R16F || W === t.R32F || W === t.RG16F || W === t.RG32F || W === t.RGBA16F || W === t.RGBA32F) && e.get("EXT_color_buffer_float"),
        W
    }
    function S(R, w) {
        let O;
        return R ? w === null || w === ws || w === ll ? O = t.DEPTH24_STENCIL8 : w === Bi ? O = t.DEPTH32F_STENCIL8 : w === al && (O = t.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : w === null || w === ws || w === ll ? O = t.DEPTH_COMPONENT24 : w === Bi ? O = t.DEPTH_COMPONENT32F : w === al && (O = t.DEPTH_COMPONENT16),
        O
    }
    function T(R, w) {
        return g(R) === !0 || R.isFramebufferTexture && R.minFilter !== ui && R.minFilter !== _i ? Math.log2(Math.max(w.width, w.height)) + 1 : R.mipmaps !== void 0 && R.mipmaps.length > 0 ? R.mipmaps.length : R.isCompressedTexture && Array.isArray(R.image) ? w.mipmaps.length : 1
    }
    function A(R) {
        const w = R.target;
        w.removeEventListener("dispose", A),
        P(w),
        w.isVideoTexture && u.delete(w)
    }
    function C(R) {
        const w = R.target;
        w.removeEventListener("dispose", C),
        b(w)
    }
    function P(R) {
        const w = i.get(R);
        if (w.__webglInit === void 0)
            return;
        const O = R.source
          , K = h.get(O);
        if (K) {
            const ee = K[w.__cacheKey];
            ee.usedTimes--,
            ee.usedTimes === 0 && M(R),
            Object.keys(K).length === 0 && h.delete(O)
        }
        i.remove(R)
    }
    function M(R) {
        const w = i.get(R);
        t.deleteTexture(w.__webglTexture);
        const O = R.source
          , K = h.get(O);
        delete K[w.__cacheKey],
        o.memory.textures--
    }
    function b(R) {
        const w = i.get(R);
        if (R.depthTexture && (R.depthTexture.dispose(),
        i.remove(R.depthTexture)),
        R.isWebGLCubeRenderTarget)
            for (let K = 0; K < 6; K++) {
                if (Array.isArray(w.__webglFramebuffer[K]))
                    for (let ee = 0; ee < w.__webglFramebuffer[K].length; ee++)
                        t.deleteFramebuffer(w.__webglFramebuffer[K][ee]);
                else
                    t.deleteFramebuffer(w.__webglFramebuffer[K]);
                w.__webglDepthbuffer && t.deleteRenderbuffer(w.__webglDepthbuffer[K])
            }
        else {
            if (Array.isArray(w.__webglFramebuffer))
                for (let K = 0; K < w.__webglFramebuffer.length; K++)
                    t.deleteFramebuffer(w.__webglFramebuffer[K]);
            else
                t.deleteFramebuffer(w.__webglFramebuffer);
            if (w.__webglDepthbuffer && t.deleteRenderbuffer(w.__webglDepthbuffer),
            w.__webglMultisampledFramebuffer && t.deleteFramebuffer(w.__webglMultisampledFramebuffer),
            w.__webglColorRenderbuffer)
                for (let K = 0; K < w.__webglColorRenderbuffer.length; K++)
                    w.__webglColorRenderbuffer[K] && t.deleteRenderbuffer(w.__webglColorRenderbuffer[K]);
            w.__webglDepthRenderbuffer && t.deleteRenderbuffer(w.__webglDepthRenderbuffer)
        }
        const O = R.textures;
        for (let K = 0, ee = O.length; K < ee; K++) {
            const W = i.get(O[K]);
            W.__webglTexture && (t.deleteTexture(W.__webglTexture),
            o.memory.textures--),
            i.remove(O[K])
        }
        i.remove(R)
    }
    let L = 0;
    function F() {
        L = 0
    }
    function H() {
        const R = L;
        return R >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + R + " texture units while this GPU supports only " + r.maxTextures),
        L += 1,
        R
    }
    function Z(R) {
        const w = [];
        return w.push(R.wrapS),
        w.push(R.wrapT),
        w.push(R.wrapR || 0),
        w.push(R.magFilter),
        w.push(R.minFilter),
        w.push(R.anisotropy),
        w.push(R.internalFormat),
        w.push(R.format),
        w.push(R.type),
        w.push(R.generateMipmaps),
        w.push(R.premultiplyAlpha),
        w.push(R.flipY),
        w.push(R.unpackAlignment),
        w.push(R.colorSpace),
        w.join()
    }
    function $(R, w) {
        const O = i.get(R);
        if (R.isVideoTexture && Ve(R),
        R.isRenderTargetTexture === !1 && R.isExternalTexture !== !0 && R.version > 0 && O.__version !== R.version) {
            const K = R.image;
            if (K === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (K.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                X(O, R, w);
                return
            }
        } else
            R.isExternalTexture && (O.__webglTexture = R.sourceTexture ? R.sourceTexture : null);
        n.bindTexture(t.TEXTURE_2D, O.__webglTexture, t.TEXTURE0 + w)
    }
    function q(R, w) {
        const O = i.get(R);
        if (R.isRenderTargetTexture === !1 && R.version > 0 && O.__version !== R.version) {
            X(O, R, w);
            return
        }
        n.bindTexture(t.TEXTURE_2D_ARRAY, O.__webglTexture, t.TEXTURE0 + w)
    }
    function B(R, w) {
        const O = i.get(R);
        if (R.isRenderTargetTexture === !1 && R.version > 0 && O.__version !== R.version) {
            X(O, R, w);
            return
        }
        n.bindTexture(t.TEXTURE_3D, O.__webglTexture, t.TEXTURE0 + w)
    }
    function D(R, w) {
        const O = i.get(R);
        if (R.version > 0 && O.__version !== R.version) {
            Q(O, R, w);
            return
        }
        n.bindTexture(t.TEXTURE_CUBE_MAP, O.__webglTexture, t.TEXTURE0 + w)
    }
    const G = {
        [Sp]: t.REPEAT,
        [ds]: t.CLAMP_TO_EDGE,
        [wp]: t.MIRRORED_REPEAT
    }
      , Y = {
        [ui]: t.NEAREST,
        [VD]: t.NEAREST_MIPMAP_NEAREST,
        [sc]: t.NEAREST_MIPMAP_LINEAR,
        [_i]: t.LINEAR,
        [ah]: t.LINEAR_MIPMAP_NEAREST,
        [hs]: t.LINEAR_MIPMAP_LINEAR
    }
      , le = {
        [$D]: t.NEVER,
        [JD]: t.ALWAYS,
        [XD]: t.LESS,
        [nE]: t.LEQUAL,
        [qD]: t.EQUAL,
        [ZD]: t.GEQUAL,
        [KD]: t.GREATER,
        [YD]: t.NOTEQUAL
    };
    function xe(R, w) {
        if (w.type === Bi && e.has("OES_texture_float_linear") === !1 && (w.magFilter === _i || w.magFilter === ah || w.magFilter === sc || w.magFilter === hs || w.minFilter === _i || w.minFilter === ah || w.minFilter === sc || w.minFilter === hs) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        t.texParameteri(R, t.TEXTURE_WRAP_S, G[w.wrapS]),
        t.texParameteri(R, t.TEXTURE_WRAP_T, G[w.wrapT]),
        (R === t.TEXTURE_3D || R === t.TEXTURE_2D_ARRAY) && t.texParameteri(R, t.TEXTURE_WRAP_R, G[w.wrapR]),
        t.texParameteri(R, t.TEXTURE_MAG_FILTER, Y[w.magFilter]),
        t.texParameteri(R, t.TEXTURE_MIN_FILTER, Y[w.minFilter]),
        w.compareFunction && (t.texParameteri(R, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
        t.texParameteri(R, t.TEXTURE_COMPARE_FUNC, le[w.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (w.magFilter === ui || w.minFilter !== sc && w.minFilter !== hs || w.type === Bi && e.has("OES_texture_float_linear") === !1)
                return;
            if (w.anisotropy > 1 || i.get(w).__currentAnisotropy) {
                const O = e.get("EXT_texture_filter_anisotropic");
                t.texParameterf(R, O.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(w.anisotropy, r.getMaxAnisotropy())),
                i.get(w).__currentAnisotropy = w.anisotropy
            }
        }
    }
    function qe(R, w) {
        let O = !1;
        R.__webglInit === void 0 && (R.__webglInit = !0,
        w.addEventListener("dispose", A));
        const K = w.source;
        let ee = h.get(K);
        ee === void 0 && (ee = {},
        h.set(K, ee));
        const W = Z(w);
        if (W !== R.__cacheKey) {
            ee[W] === void 0 && (ee[W] = {
                texture: t.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            O = !0),
            ee[W].usedTimes++;
            const Me = ee[R.__cacheKey];
            Me !== void 0 && (ee[R.__cacheKey].usedTimes--,
            Me.usedTimes === 0 && M(w)),
            R.__cacheKey = W,
            R.__webglTexture = ee[W].texture
        }
        return O
    }
    function Ke(R, w, O) {
        return Math.floor(Math.floor(R / O) / w)
    }
    function We(R, w, O, K) {
        const W = R.updateRanges;
        if (W.length === 0)
            n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, w.width, w.height, O, K, w.data);
        else {
            W.sort( (re, fe) => re.start - fe.start);
            let Me = 0;
            for (let re = 1; re < W.length; re++) {
                const fe = W[Me]
                  , Ne = W[re]
                  , Te = fe.start + fe.count
                  , de = Ke(Ne.start, w.width, 4)
                  , Be = Ke(fe.start, w.width, 4);
                Ne.start <= Te + 1 && de === Be && Ke(Ne.start + Ne.count - 1, w.width, 4) === de ? fe.count = Math.max(fe.count, Ne.start + Ne.count - fe.start) : (++Me,
                W[Me] = Ne)
            }
            W.length = Me + 1;
            const ae = t.getParameter(t.UNPACK_ROW_LENGTH)
              , be = t.getParameter(t.UNPACK_SKIP_PIXELS)
              , Ee = t.getParameter(t.UNPACK_SKIP_ROWS);
            t.pixelStorei(t.UNPACK_ROW_LENGTH, w.width);
            for (let re = 0, fe = W.length; re < fe; re++) {
                const Ne = W[re]
                  , Te = Math.floor(Ne.start / 4)
                  , de = Math.ceil(Ne.count / 4)
                  , Be = Te % w.width
                  , I = Math.floor(Te / w.width)
                  , se = de
                  , ce = 1;
                t.pixelStorei(t.UNPACK_SKIP_PIXELS, Be),
                t.pixelStorei(t.UNPACK_SKIP_ROWS, I),
                n.texSubImage2D(t.TEXTURE_2D, 0, Be, I, se, ce, O, K, w.data)
            }
            R.clearUpdateRanges(),
            t.pixelStorei(t.UNPACK_ROW_LENGTH, ae),
            t.pixelStorei(t.UNPACK_SKIP_PIXELS, be),
            t.pixelStorei(t.UNPACK_SKIP_ROWS, Ee)
        }
    }
    function X(R, w, O) {
        let K = t.TEXTURE_2D;
        (w.isDataArrayTexture || w.isCompressedArrayTexture) && (K = t.TEXTURE_2D_ARRAY),
        w.isData3DTexture && (K = t.TEXTURE_3D);
        const ee = qe(R, w)
          , W = w.source;
        n.bindTexture(K, R.__webglTexture, t.TEXTURE0 + O);
        const Me = i.get(W);
        if (W.version !== Me.__version || ee === !0) {
            n.activeTexture(t.TEXTURE0 + O);
            const ae = Qe.getPrimaries(Qe.workingColorSpace)
              , be = w.colorSpace === gr ? null : Qe.getPrimaries(w.colorSpace)
              , Ee = w.colorSpace === gr || ae === be ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, w.flipY),
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, w.premultiplyAlpha),
            t.pixelStorei(t.UNPACK_ALIGNMENT, w.unpackAlignment),
            t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ee);
            let re = x(w.image, !1, r.maxTextureSize);
            re = Vt(w, re);
            const fe = s.convert(w.format, w.colorSpace)
              , Ne = s.convert(w.type);
            let Te = _(w.internalFormat, fe, Ne, w.colorSpace, w.isVideoTexture);
            xe(K, w);
            let de;
            const Be = w.mipmaps
              , I = w.isVideoTexture !== !0
              , se = Me.__version === void 0 || ee === !0
              , ce = W.dataReady
              , ve = T(w, re);
            if (w.isDepthTexture)
                Te = S(w.format === ul, w.type),
                se && (I ? n.texStorage2D(t.TEXTURE_2D, 1, Te, re.width, re.height) : n.texImage2D(t.TEXTURE_2D, 0, Te, re.width, re.height, 0, fe, Ne, null));
            else if (w.isDataTexture)
                if (Be.length > 0) {
                    I && se && n.texStorage2D(t.TEXTURE_2D, ve, Te, Be[0].width, Be[0].height);
                    for (let ne = 0, J = Be.length; ne < J; ne++)
                        de = Be[ne],
                        I ? ce && n.texSubImage2D(t.TEXTURE_2D, ne, 0, 0, de.width, de.height, fe, Ne, de.data) : n.texImage2D(t.TEXTURE_2D, ne, Te, de.width, de.height, 0, fe, Ne, de.data);
                    w.generateMipmaps = !1
                } else
                    I ? (se && n.texStorage2D(t.TEXTURE_2D, ve, Te, re.width, re.height),
                    ce && We(w, re, fe, Ne)) : n.texImage2D(t.TEXTURE_2D, 0, Te, re.width, re.height, 0, fe, Ne, re.data);
            else if (w.isCompressedTexture)
                if (w.isCompressedArrayTexture) {
                    I && se && n.texStorage3D(t.TEXTURE_2D_ARRAY, ve, Te, Be[0].width, Be[0].height, re.depth);
                    for (let ne = 0, J = Be.length; ne < J; ne++)
                        if (de = Be[ne],
                        w.format !== ai)
                            if (fe !== null)
                                if (I) {
                                    if (ce)
                                        if (w.layerUpdates.size > 0) {
                                            const ye = oy(de.width, de.height, w.format, w.type);
                                            for (const Ue of w.layerUpdates) {
                                                const at = de.data.subarray(Ue * ye / de.data.BYTES_PER_ELEMENT, (Ue + 1) * ye / de.data.BYTES_PER_ELEMENT);
                                                n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, ne, 0, 0, Ue, de.width, de.height, 1, fe, at)
                                            }
                                            w.clearLayerUpdates()
                                        } else
                                            n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, ne, 0, 0, 0, de.width, de.height, re.depth, fe, de.data)
                                } else
                                    n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, ne, Te, de.width, de.height, re.depth, 0, de.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            I ? ce && n.texSubImage3D(t.TEXTURE_2D_ARRAY, ne, 0, 0, 0, de.width, de.height, re.depth, fe, Ne, de.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, ne, Te, de.width, de.height, re.depth, 0, fe, Ne, de.data)
                } else {
                    I && se && n.texStorage2D(t.TEXTURE_2D, ve, Te, Be[0].width, Be[0].height);
                    for (let ne = 0, J = Be.length; ne < J; ne++)
                        de = Be[ne],
                        w.format !== ai ? fe !== null ? I ? ce && n.compressedTexSubImage2D(t.TEXTURE_2D, ne, 0, 0, de.width, de.height, fe, de.data) : n.compressedTexImage2D(t.TEXTURE_2D, ne, Te, de.width, de.height, 0, de.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : I ? ce && n.texSubImage2D(t.TEXTURE_2D, ne, 0, 0, de.width, de.height, fe, Ne, de.data) : n.texImage2D(t.TEXTURE_2D, ne, Te, de.width, de.height, 0, fe, Ne, de.data)
                }
            else if (w.isDataArrayTexture)
                if (I) {
                    if (se && n.texStorage3D(t.TEXTURE_2D_ARRAY, ve, Te, re.width, re.height, re.depth),
                    ce)
                        if (w.layerUpdates.size > 0) {
                            const ne = oy(re.width, re.height, w.format, w.type);
                            for (const J of w.layerUpdates) {
                                const ye = re.data.subarray(J * ne / re.data.BYTES_PER_ELEMENT, (J + 1) * ne / re.data.BYTES_PER_ELEMENT);
                                n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, J, re.width, re.height, 1, fe, Ne, ye)
                            }
                            w.clearLayerUpdates()
                        } else
                            n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, re.width, re.height, re.depth, fe, Ne, re.data)
                } else
                    n.texImage3D(t.TEXTURE_2D_ARRAY, 0, Te, re.width, re.height, re.depth, 0, fe, Ne, re.data);
            else if (w.isData3DTexture)
                I ? (se && n.texStorage3D(t.TEXTURE_3D, ve, Te, re.width, re.height, re.depth),
                ce && n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, re.width, re.height, re.depth, fe, Ne, re.data)) : n.texImage3D(t.TEXTURE_3D, 0, Te, re.width, re.height, re.depth, 0, fe, Ne, re.data);
            else if (w.isFramebufferTexture) {
                if (se)
                    if (I)
                        n.texStorage2D(t.TEXTURE_2D, ve, Te, re.width, re.height);
                    else {
                        let ne = re.width
                          , J = re.height;
                        for (let ye = 0; ye < ve; ye++)
                            n.texImage2D(t.TEXTURE_2D, ye, Te, ne, J, 0, fe, Ne, null),
                            ne >>= 1,
                            J >>= 1
                    }
            } else if (Be.length > 0) {
                if (I && se) {
                    const ne = Mt(Be[0]);
                    n.texStorage2D(t.TEXTURE_2D, ve, Te, ne.width, ne.height)
                }
                for (let ne = 0, J = Be.length; ne < J; ne++)
                    de = Be[ne],
                    I ? ce && n.texSubImage2D(t.TEXTURE_2D, ne, 0, 0, fe, Ne, de) : n.texImage2D(t.TEXTURE_2D, ne, Te, fe, Ne, de);
                w.generateMipmaps = !1
            } else if (I) {
                if (se) {
                    const ne = Mt(re);
                    n.texStorage2D(t.TEXTURE_2D, ve, Te, ne.width, ne.height)
                }
                ce && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, fe, Ne, re)
            } else
                n.texImage2D(t.TEXTURE_2D, 0, Te, fe, Ne, re);
            g(w) && f(K),
            Me.__version = W.version,
            w.onUpdate && w.onUpdate(w)
        }
        R.__version = w.version
    }
    function Q(R, w, O) {
        if (w.image.length !== 6)
            return;
        const K = qe(R, w)
          , ee = w.source;
        n.bindTexture(t.TEXTURE_CUBE_MAP, R.__webglTexture, t.TEXTURE0 + O);
        const W = i.get(ee);
        if (ee.version !== W.__version || K === !0) {
            n.activeTexture(t.TEXTURE0 + O);
            const Me = Qe.getPrimaries(Qe.workingColorSpace)
              , ae = w.colorSpace === gr ? null : Qe.getPrimaries(w.colorSpace)
              , be = w.colorSpace === gr || Me === ae ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, w.flipY),
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, w.premultiplyAlpha),
            t.pixelStorei(t.UNPACK_ALIGNMENT, w.unpackAlignment),
            t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, be);
            const Ee = w.isCompressedTexture || w.image[0].isCompressedTexture
              , re = w.image[0] && w.image[0].isDataTexture
              , fe = [];
            for (let J = 0; J < 6; J++)
                !Ee && !re ? fe[J] = x(w.image[J], !0, r.maxCubemapSize) : fe[J] = re ? w.image[J].image : w.image[J],
                fe[J] = Vt(w, fe[J]);
            const Ne = fe[0]
              , Te = s.convert(w.format, w.colorSpace)
              , de = s.convert(w.type)
              , Be = _(w.internalFormat, Te, de, w.colorSpace)
              , I = w.isVideoTexture !== !0
              , se = W.__version === void 0 || K === !0
              , ce = ee.dataReady;
            let ve = T(w, Ne);
            xe(t.TEXTURE_CUBE_MAP, w);
            let ne;
            if (Ee) {
                I && se && n.texStorage2D(t.TEXTURE_CUBE_MAP, ve, Be, Ne.width, Ne.height);
                for (let J = 0; J < 6; J++) {
                    ne = fe[J].mipmaps;
                    for (let ye = 0; ye < ne.length; ye++) {
                        const Ue = ne[ye];
                        w.format !== ai ? Te !== null ? I ? ce && n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, ye, 0, 0, Ue.width, Ue.height, Te, Ue.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, ye, Be, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : I ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, ye, 0, 0, Ue.width, Ue.height, Te, de, Ue.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, ye, Be, Ue.width, Ue.height, 0, Te, de, Ue.data)
                    }
                }
            } else {
                if (ne = w.mipmaps,
                I && se) {
                    ne.length > 0 && ve++;
                    const J = Mt(fe[0]);
                    n.texStorage2D(t.TEXTURE_CUBE_MAP, ve, Be, J.width, J.height)
                }
                for (let J = 0; J < 6; J++)
                    if (re) {
                        I ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, 0, 0, 0, fe[J].width, fe[J].height, Te, de, fe[J].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, 0, Be, fe[J].width, fe[J].height, 0, Te, de, fe[J].data);
                        for (let ye = 0; ye < ne.length; ye++) {
                            const at = ne[ye].image[J].image;
                            I ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, ye + 1, 0, 0, at.width, at.height, Te, de, at.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, ye + 1, Be, at.width, at.height, 0, Te, de, at.data)
                        }
                    } else {
                        I ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, 0, 0, 0, Te, de, fe[J]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, 0, Be, Te, de, fe[J]);
                        for (let ye = 0; ye < ne.length; ye++) {
                            const Ue = ne[ye];
                            I ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, ye + 1, 0, 0, Te, de, Ue.image[J]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + J, ye + 1, Be, Te, de, Ue.image[J])
                        }
                    }
            }
            g(w) && f(t.TEXTURE_CUBE_MAP),
            W.__version = ee.version,
            w.onUpdate && w.onUpdate(w)
        }
        R.__version = w.version
    }
    function ge(R, w, O, K, ee, W) {
        const Me = s.convert(O.format, O.colorSpace)
          , ae = s.convert(O.type)
          , be = _(O.internalFormat, Me, ae, O.colorSpace)
          , Ee = i.get(w)
          , re = i.get(O);
        if (re.__renderTarget = w,
        !Ee.__hasExternalTextures) {
            const fe = Math.max(1, w.width >> W)
              , Ne = Math.max(1, w.height >> W);
            ee === t.TEXTURE_3D || ee === t.TEXTURE_2D_ARRAY ? n.texImage3D(ee, W, be, fe, Ne, w.depth, 0, Me, ae, null) : n.texImage2D(ee, W, be, fe, Ne, 0, Me, ae, null)
        }
        n.bindFramebuffer(t.FRAMEBUFFER, R),
        we(w) ? a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, K, ee, re.__webglTexture, 0, pt(w)) : (ee === t.TEXTURE_2D || ee >= t.TEXTURE_CUBE_MAP_POSITIVE_X && ee <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, K, ee, re.__webglTexture, W),
        n.bindFramebuffer(t.FRAMEBUFFER, null)
    }
    function ke(R, w, O) {
        if (t.bindRenderbuffer(t.RENDERBUFFER, R),
        w.depthBuffer) {
            const K = w.depthTexture
              , ee = K && K.isDepthTexture ? K.type : null
              , W = S(w.stencilBuffer, ee)
              , Me = w.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT
              , ae = pt(w);
            we(w) ? a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, ae, W, w.width, w.height) : O ? t.renderbufferStorageMultisample(t.RENDERBUFFER, ae, W, w.width, w.height) : t.renderbufferStorage(t.RENDERBUFFER, W, w.width, w.height),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, Me, t.RENDERBUFFER, R)
        } else {
            const K = w.textures;
            for (let ee = 0; ee < K.length; ee++) {
                const W = K[ee]
                  , Me = s.convert(W.format, W.colorSpace)
                  , ae = s.convert(W.type)
                  , be = _(W.internalFormat, Me, ae, W.colorSpace)
                  , Ee = pt(w);
                O && we(w) === !1 ? t.renderbufferStorageMultisample(t.RENDERBUFFER, Ee, be, w.width, w.height) : we(w) ? a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, Ee, be, w.width, w.height) : t.renderbufferStorage(t.RENDERBUFFER, be, w.width, w.height)
            }
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null)
    }
    function Ae(R, w) {
        if (w && w.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (n.bindFramebuffer(t.FRAMEBUFFER, R),
        !(w.depthTexture && w.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const K = i.get(w.depthTexture);
        K.__renderTarget = w,
        (!K.__webglTexture || w.depthTexture.image.width !== w.width || w.depthTexture.image.height !== w.height) && (w.depthTexture.image.width = w.width,
        w.depthTexture.image.height = w.height,
        w.depthTexture.needsUpdate = !0),
        $(w.depthTexture, 0);
        const ee = K.__webglTexture
          , W = pt(w);
        if (w.depthTexture.format === cl)
            we(w) ? a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, ee, 0, W) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, ee, 0);
        else if (w.depthTexture.format === ul)
            we(w) ? a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, ee, 0, W) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, ee, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Ye(R) {
        const w = i.get(R)
          , O = R.isWebGLCubeRenderTarget === !0;
        if (w.__boundDepthTexture !== R.depthTexture) {
            const K = R.depthTexture;
            if (w.__depthDisposeCallback && w.__depthDisposeCallback(),
            K) {
                const ee = () => {
                    delete w.__boundDepthTexture,
                    delete w.__depthDisposeCallback,
                    K.removeEventListener("dispose", ee)
                }
                ;
                K.addEventListener("dispose", ee),
                w.__depthDisposeCallback = ee
            }
            w.__boundDepthTexture = K
        }
        if (R.depthTexture && !w.__autoAllocateDepthBuffer) {
            if (O)
                throw new Error("target.depthTexture not supported in Cube render targets");
            const K = R.texture.mipmaps;
            K && K.length > 0 ? Ae(w.__webglFramebuffer[0], R) : Ae(w.__webglFramebuffer, R)
        } else if (O) {
            w.__webglDepthbuffer = [];
            for (let K = 0; K < 6; K++)
                if (n.bindFramebuffer(t.FRAMEBUFFER, w.__webglFramebuffer[K]),
                w.__webglDepthbuffer[K] === void 0)
                    w.__webglDepthbuffer[K] = t.createRenderbuffer(),
                    ke(w.__webglDepthbuffer[K], R, !1);
                else {
                    const ee = R.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT
                      , W = w.__webglDepthbuffer[K];
                    t.bindRenderbuffer(t.RENDERBUFFER, W),
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, ee, t.RENDERBUFFER, W)
                }
        } else {
            const K = R.texture.mipmaps;
            if (K && K.length > 0 ? n.bindFramebuffer(t.FRAMEBUFFER, w.__webglFramebuffer[0]) : n.bindFramebuffer(t.FRAMEBUFFER, w.__webglFramebuffer),
            w.__webglDepthbuffer === void 0)
                w.__webglDepthbuffer = t.createRenderbuffer(),
                ke(w.__webglDepthbuffer, R, !1);
            else {
                const ee = R.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT
                  , W = w.__webglDepthbuffer;
                t.bindRenderbuffer(t.RENDERBUFFER, W),
                t.framebufferRenderbuffer(t.FRAMEBUFFER, ee, t.RENDERBUFFER, W)
            }
        }
        n.bindFramebuffer(t.FRAMEBUFFER, null)
    }
    function Kt(R, w, O) {
        const K = i.get(R);
        w !== void 0 && ge(K.__webglFramebuffer, R, R.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0),
        O !== void 0 && Ye(R)
    }
    function N(R) {
        const w = R.texture
          , O = i.get(R)
          , K = i.get(w);
        R.addEventListener("dispose", C);
        const ee = R.textures
          , W = R.isWebGLCubeRenderTarget === !0
          , Me = ee.length > 1;
        if (Me || (K.__webglTexture === void 0 && (K.__webglTexture = t.createTexture()),
        K.__version = w.version,
        o.memory.textures++),
        W) {
            O.__webglFramebuffer = [];
            for (let ae = 0; ae < 6; ae++)
                if (w.mipmaps && w.mipmaps.length > 0) {
                    O.__webglFramebuffer[ae] = [];
                    for (let be = 0; be < w.mipmaps.length; be++)
                        O.__webglFramebuffer[ae][be] = t.createFramebuffer()
                } else
                    O.__webglFramebuffer[ae] = t.createFramebuffer()
        } else {
            if (w.mipmaps && w.mipmaps.length > 0) {
                O.__webglFramebuffer = [];
                for (let ae = 0; ae < w.mipmaps.length; ae++)
                    O.__webglFramebuffer[ae] = t.createFramebuffer()
            } else
                O.__webglFramebuffer = t.createFramebuffer();
            if (Me)
                for (let ae = 0, be = ee.length; ae < be; ae++) {
                    const Ee = i.get(ee[ae]);
                    Ee.__webglTexture === void 0 && (Ee.__webglTexture = t.createTexture(),
                    o.memory.textures++)
                }
            if (R.samples > 0 && we(R) === !1) {
                O.__webglMultisampledFramebuffer = t.createFramebuffer(),
                O.__webglColorRenderbuffer = [],
                n.bindFramebuffer(t.FRAMEBUFFER, O.__webglMultisampledFramebuffer);
                for (let ae = 0; ae < ee.length; ae++) {
                    const be = ee[ae];
                    O.__webglColorRenderbuffer[ae] = t.createRenderbuffer(),
                    t.bindRenderbuffer(t.RENDERBUFFER, O.__webglColorRenderbuffer[ae]);
                    const Ee = s.convert(be.format, be.colorSpace)
                      , re = s.convert(be.type)
                      , fe = _(be.internalFormat, Ee, re, be.colorSpace, R.isXRRenderTarget === !0)
                      , Ne = pt(R);
                    t.renderbufferStorageMultisample(t.RENDERBUFFER, Ne, fe, R.width, R.height),
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + ae, t.RENDERBUFFER, O.__webglColorRenderbuffer[ae])
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null),
                R.depthBuffer && (O.__webglDepthRenderbuffer = t.createRenderbuffer(),
                ke(O.__webglDepthRenderbuffer, R, !0)),
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }
        }
        if (W) {
            n.bindTexture(t.TEXTURE_CUBE_MAP, K.__webglTexture),
            xe(t.TEXTURE_CUBE_MAP, w);
            for (let ae = 0; ae < 6; ae++)
                if (w.mipmaps && w.mipmaps.length > 0)
                    for (let be = 0; be < w.mipmaps.length; be++)
                        ge(O.__webglFramebuffer[ae][be], R, w, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + ae, be);
                else
                    ge(O.__webglFramebuffer[ae], R, w, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + ae, 0);
            g(w) && f(t.TEXTURE_CUBE_MAP),
            n.unbindTexture()
        } else if (Me) {
            for (let ae = 0, be = ee.length; ae < be; ae++) {
                const Ee = ee[ae]
                  , re = i.get(Ee);
                let fe = t.TEXTURE_2D;
                (R.isWebGL3DRenderTarget || R.isWebGLArrayRenderTarget) && (fe = R.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY),
                n.bindTexture(fe, re.__webglTexture),
                xe(fe, Ee),
                ge(O.__webglFramebuffer, R, Ee, t.COLOR_ATTACHMENT0 + ae, fe, 0),
                g(Ee) && f(fe)
            }
            n.unbindTexture()
        } else {
            let ae = t.TEXTURE_2D;
            if ((R.isWebGL3DRenderTarget || R.isWebGLArrayRenderTarget) && (ae = R.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY),
            n.bindTexture(ae, K.__webglTexture),
            xe(ae, w),
            w.mipmaps && w.mipmaps.length > 0)
                for (let be = 0; be < w.mipmaps.length; be++)
                    ge(O.__webglFramebuffer[be], R, w, t.COLOR_ATTACHMENT0, ae, be);
            else
                ge(O.__webglFramebuffer, R, w, t.COLOR_ATTACHMENT0, ae, 0);
            g(w) && f(ae),
            n.unbindTexture()
        }
        R.depthBuffer && Ye(R)
    }
    function ft(R) {
        const w = R.textures;
        for (let O = 0, K = w.length; O < K; O++) {
            const ee = w[O];
            if (g(ee)) {
                const W = y(R)
                  , Me = i.get(ee).__webglTexture;
                n.bindTexture(W, Me),
                f(W),
                n.unbindTexture()
            }
        }
    }
    const Oe = []
      , Le = [];
    function Se(R) {
        if (R.samples > 0) {
            if (we(R) === !1) {
                const w = R.textures
                  , O = R.width
                  , K = R.height;
                let ee = t.COLOR_BUFFER_BIT;
                const W = R.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT
                  , Me = i.get(R)
                  , ae = w.length > 1;
                if (ae)
                    for (let Ee = 0; Ee < w.length; Ee++)
                        n.bindFramebuffer(t.FRAMEBUFFER, Me.__webglMultisampledFramebuffer),
                        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Ee, t.RENDERBUFFER, null),
                        n.bindFramebuffer(t.FRAMEBUFFER, Me.__webglFramebuffer),
                        t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Ee, t.TEXTURE_2D, null, 0);
                n.bindFramebuffer(t.READ_FRAMEBUFFER, Me.__webglMultisampledFramebuffer);
                const be = R.texture.mipmaps;
                be && be.length > 0 ? n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Me.__webglFramebuffer[0]) : n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Me.__webglFramebuffer);
                for (let Ee = 0; Ee < w.length; Ee++) {
                    if (R.resolveDepthBuffer && (R.depthBuffer && (ee |= t.DEPTH_BUFFER_BIT),
                    R.stencilBuffer && R.resolveStencilBuffer && (ee |= t.STENCIL_BUFFER_BIT)),
                    ae) {
                        t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, Me.__webglColorRenderbuffer[Ee]);
                        const re = i.get(w[Ee]).__webglTexture;
                        t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, re, 0)
                    }
                    t.blitFramebuffer(0, 0, O, K, 0, 0, O, K, ee, t.NEAREST),
                    l === !0 && (Oe.length = 0,
                    Le.length = 0,
                    Oe.push(t.COLOR_ATTACHMENT0 + Ee),
                    R.depthBuffer && R.resolveDepthBuffer === !1 && (Oe.push(W),
                    Le.push(W),
                    t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, Le)),
                    t.invalidateFramebuffer(t.READ_FRAMEBUFFER, Oe))
                }
                if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                ae)
                    for (let Ee = 0; Ee < w.length; Ee++) {
                        n.bindFramebuffer(t.FRAMEBUFFER, Me.__webglMultisampledFramebuffer),
                        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Ee, t.RENDERBUFFER, Me.__webglColorRenderbuffer[Ee]);
                        const re = i.get(w[Ee]).__webglTexture;
                        n.bindFramebuffer(t.FRAMEBUFFER, Me.__webglFramebuffer),
                        t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Ee, t.TEXTURE_2D, re, 0)
                    }
                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Me.__webglMultisampledFramebuffer)
            } else if (R.depthBuffer && R.resolveDepthBuffer === !1 && l) {
                const w = R.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [w])
            }
        }
    }
    function pt(R) {
        return Math.min(r.maxSamples, R.samples)
    }
    function we(R) {
        const w = i.get(R);
        return R.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && w.__useRenderToTexture !== !1
    }
    function Ve(R) {
        const w = o.render.frame;
        u.get(R) !== w && (u.set(R, w),
        R.update())
    }
    function Vt(R, w) {
        const O = R.colorSpace
          , K = R.format
          , ee = R.type;
        return R.isCompressedTexture === !0 || R.isVideoTexture === !0 || O !== Fo && O !== gr && (Qe.getTransfer(O) === rt ? (K !== ai || ee !== Yi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", O)),
        w
    }
    function Mt(R) {
        return typeof HTMLImageElement < "u" && R instanceof HTMLImageElement ? (c.width = R.naturalWidth || R.width,
        c.height = R.naturalHeight || R.height) : typeof VideoFrame < "u" && R instanceof VideoFrame ? (c.width = R.displayWidth,
        c.height = R.displayHeight) : (c.width = R.width,
        c.height = R.height),
        c
    }
    this.allocateTextureUnit = H,
    this.resetTextureUnits = F,
    this.setTexture2D = $,
    this.setTexture2DArray = q,
    this.setTexture3D = B,
    this.setTextureCube = D,
    this.rebindTextures = Kt,
    this.setupRenderTarget = N,
    this.updateRenderTargetMipmap = ft,
    this.updateMultisampleRenderTarget = Se,
    this.setupDepthRenderbuffer = Ye,
    this.setupFrameBufferTexture = ge,
    this.useMultisampledRTT = we
}
function uO(t, e) {
    function n(i, r=gr) {
        let s;
        const o = Qe.getTransfer(r);
        if (i === Yi)
            return t.UNSIGNED_BYTE;
        if (i === Dg)
            return t.UNSIGNED_SHORT_4_4_4_4;
        if (i === Lg)
            return t.UNSIGNED_SHORT_5_5_5_1;
        if (i === Yb)
            return t.UNSIGNED_INT_5_9_9_9_REV;
        if (i === Zb)
            return t.UNSIGNED_INT_10F_11F_11F_REV;
        if (i === qb)
            return t.BYTE;
        if (i === Kb)
            return t.SHORT;
        if (i === al)
            return t.UNSIGNED_SHORT;
        if (i === Ng)
            return t.INT;
        if (i === ws)
            return t.UNSIGNED_INT;
        if (i === Bi)
            return t.FLOAT;
        if (i === Tl)
            return t.HALF_FLOAT;
        if (i === Jb)
            return t.ALPHA;
        if (i === Qb)
            return t.RGB;
        if (i === ai)
            return t.RGBA;
        if (i === cl)
            return t.DEPTH_COMPONENT;
        if (i === ul)
            return t.DEPTH_STENCIL;
        if (i === eE)
            return t.RED;
        if (i === Ig)
            return t.RED_INTEGER;
        if (i === tE)
            return t.RG;
        if (i === kg)
            return t.RG_INTEGER;
        if (i === Ug)
            return t.RGBA_INTEGER;
        if (i === $c || i === Xc || i === qc || i === Kc)
            if (o === rt)
                if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                s !== null) {
                    if (i === $c)
                        return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (i === Xc)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (i === qc)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (i === Kc)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (s = e.get("WEBGL_compressed_texture_s3tc"),
            s !== null) {
                if (i === $c)
                    return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (i === Xc)
                    return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (i === qc)
                    return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (i === Kc)
                    return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (i === bp || i === Ep || i === Tp || i === Mp)
            if (s = e.get("WEBGL_compressed_texture_pvrtc"),
            s !== null) {
                if (i === bp)
                    return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (i === Ep)
                    return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (i === Tp)
                    return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (i === Mp)
                    return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (i === Ap || i === Cp || i === Rp)
            if (s = e.get("WEBGL_compressed_texture_etc"),
            s !== null) {
                if (i === Ap || i === Cp)
                    return o === rt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (i === Rp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (i === Pp || i === Np || i === Dp || i === Lp || i === Ip || i === kp || i === Up || i === Op || i === Fp || i === Bp || i === zp || i === Vp || i === jp || i === Hp)
            if (s = e.get("WEBGL_compressed_texture_astc"),
            s !== null) {
                if (i === Pp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (i === Np)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (i === Dp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (i === Lp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (i === Ip)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (i === kp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (i === Up)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (i === Op)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (i === Fp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (i === Bp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (i === zp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (i === Vp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (i === jp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (i === Hp)
                    return o === rt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (i === Gp || i === Wp || i === $p)
            if (s = e.get("EXT_texture_compression_bptc"),
            s !== null) {
                if (i === Gp)
                    return o === rt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (i === Wp)
                    return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (i === $p)
                    return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (i === Xp || i === qp || i === Kp || i === Yp)
            if (s = e.get("EXT_texture_compression_rgtc"),
            s !== null) {
                if (i === Xp)
                    return s.COMPRESSED_RED_RGTC1_EXT;
                if (i === qp)
                    return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (i === Kp)
                    return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (i === Yp)
                    return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return i === ll ? t.UNSIGNED_INT_24_8 : t[i] !== void 0 ? t[i] : null
    }
    return {
        convert: n
    }
}
const dO = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , hO = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class fO {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, n) {
        if (this.texture === null) {
            const i = new vE(e.texture);
            (e.depthNear !== n.depthNear || e.depthFar !== n.depthFar) && (this.depthNear = e.depthNear,
            this.depthFar = e.depthFar),
            this.texture = i
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const n = e.cameras[0].viewport
              , i = new Ir({
                vertexShader: dO,
                fragmentShader: hO,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: n.z
                    },
                    depthHeight: {
                        value: n.w
                    }
                }
            });
            this.mesh = new zi(new sd(20,20),i)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class pO extends qo {
    constructor(e, n) {
        super();
        const i = this;
        let r = null
          , s = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , u = null
          , d = null
          , h = null
          , p = null
          , v = null;
        const x = typeof XRWebGLBinding < "u"
          , g = new fO
          , f = {}
          , y = n.getContextAttributes();
        let _ = null
          , S = null;
        const T = []
          , A = []
          , C = new st;
        let P = null;
        const M = new jn;
        M.viewport = new Rt;
        const b = new jn;
        b.viewport = new Rt;
        const L = [M, b]
          , F = new IL;
        let H = null
          , Z = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(X) {
            let Q = T[X];
            return Q === void 0 && (Q = new Ph,
            T[X] = Q),
            Q.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(X) {
            let Q = T[X];
            return Q === void 0 && (Q = new Ph,
            T[X] = Q),
            Q.getGripSpace()
        }
        ,
        this.getHand = function(X) {
            let Q = T[X];
            return Q === void 0 && (Q = new Ph,
            T[X] = Q),
            Q.getHandSpace()
        }
        ;
        function $(X) {
            const Q = A.indexOf(X.inputSource);
            if (Q === -1)
                return;
            const ge = T[Q];
            ge !== void 0 && (ge.update(X.inputSource, X.frame, c || o),
            ge.dispatchEvent({
                type: X.type,
                data: X.inputSource
            }))
        }
        function q() {
            r.removeEventListener("select", $),
            r.removeEventListener("selectstart", $),
            r.removeEventListener("selectend", $),
            r.removeEventListener("squeeze", $),
            r.removeEventListener("squeezestart", $),
            r.removeEventListener("squeezeend", $),
            r.removeEventListener("end", q),
            r.removeEventListener("inputsourceschange", B);
            for (let X = 0; X < T.length; X++) {
                const Q = A[X];
                Q !== null && (A[X] = null,
                T[X].disconnect(Q))
            }
            H = null,
            Z = null,
            g.reset();
            for (const X in f)
                delete f[X];
            e.setRenderTarget(_),
            p = null,
            h = null,
            d = null,
            r = null,
            S = null,
            We.stop(),
            i.isPresenting = !1,
            e.setPixelRatio(P),
            e.setSize(C.width, C.height, !1),
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(X) {
            s = X,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(X) {
            a = X,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(X) {
            c = X
        }
        ,
        this.getBaseLayer = function() {
            return h !== null ? h : p
        }
        ,
        this.getBinding = function() {
            return d === null && x && (d = new XRWebGLBinding(r,n)),
            d
        }
        ,
        this.getFrame = function() {
            return v
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(X) {
            if (r = X,
            r !== null) {
                if (_ = e.getRenderTarget(),
                r.addEventListener("select", $),
                r.addEventListener("selectstart", $),
                r.addEventListener("selectend", $),
                r.addEventListener("squeeze", $),
                r.addEventListener("squeezestart", $),
                r.addEventListener("squeezeend", $),
                r.addEventListener("end", q),
                r.addEventListener("inputsourceschange", B),
                y.xrCompatible !== !0 && await n.makeXRCompatible(),
                P = e.getPixelRatio(),
                e.getSize(C),
                x && "createProjectionLayer"in XRWebGLBinding.prototype) {
                    let ge = null
                      , ke = null
                      , Ae = null;
                    y.depth && (Ae = y.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24,
                    ge = y.stencil ? ul : cl,
                    ke = y.stencil ? ll : ws);
                    const Ye = {
                        colorFormat: n.RGBA8,
                        depthFormat: Ae,
                        scaleFactor: s
                    };
                    d = this.getBinding(),
                    h = d.createProjectionLayer(Ye),
                    r.updateRenderState({
                        layers: [h]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(h.textureWidth, h.textureHeight, !1),
                    S = new bs(h.textureWidth,h.textureHeight,{
                        format: ai,
                        type: Yi,
                        depthTexture: new gE(h.textureWidth,h.textureHeight,ke,void 0,void 0,void 0,void 0,void 0,void 0,ge),
                        stencilBuffer: y.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: y.antialias ? 4 : 0,
                        resolveDepthBuffer: h.ignoreDepthValues === !1,
                        resolveStencilBuffer: h.ignoreDepthValues === !1
                    })
                } else {
                    const ge = {
                        antialias: y.antialias,
                        alpha: !0,
                        depth: y.depth,
                        stencil: y.stencil,
                        framebufferScaleFactor: s
                    };
                    p = new XRWebGLLayer(r,n,ge),
                    r.updateRenderState({
                        baseLayer: p
                    }),
                    e.setPixelRatio(1),
                    e.setSize(p.framebufferWidth, p.framebufferHeight, !1),
                    S = new bs(p.framebufferWidth,p.framebufferHeight,{
                        format: ai,
                        type: Yi,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: y.stencil,
                        resolveDepthBuffer: p.ignoreDepthValues === !1,
                        resolveStencilBuffer: p.ignoreDepthValues === !1
                    })
                }
                S.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await r.requestReferenceSpace(a),
                We.setContext(r),
                We.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (r !== null)
                return r.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return g.getDepthTexture()
        }
        ;
        function B(X) {
            for (let Q = 0; Q < X.removed.length; Q++) {
                const ge = X.removed[Q]
                  , ke = A.indexOf(ge);
                ke >= 0 && (A[ke] = null,
                T[ke].disconnect(ge))
            }
            for (let Q = 0; Q < X.added.length; Q++) {
                const ge = X.added[Q];
                let ke = A.indexOf(ge);
                if (ke === -1) {
                    for (let Ye = 0; Ye < T.length; Ye++)
                        if (Ye >= A.length) {
                            A.push(ge),
                            ke = Ye;
                            break
                        } else if (A[Ye] === null) {
                            A[Ye] = ge,
                            ke = Ye;
                            break
                        }
                    if (ke === -1)
                        break
                }
                const Ae = T[ke];
                Ae && Ae.connect(ge)
            }
        }
        const D = new z
          , G = new z;
        function Y(X, Q, ge) {
            D.setFromMatrixPosition(Q.matrixWorld),
            G.setFromMatrixPosition(ge.matrixWorld);
            const ke = D.distanceTo(G)
              , Ae = Q.projectionMatrix.elements
              , Ye = ge.projectionMatrix.elements
              , Kt = Ae[14] / (Ae[10] - 1)
              , N = Ae[14] / (Ae[10] + 1)
              , ft = (Ae[9] + 1) / Ae[5]
              , Oe = (Ae[9] - 1) / Ae[5]
              , Le = (Ae[8] - 1) / Ae[0]
              , Se = (Ye[8] + 1) / Ye[0]
              , pt = Kt * Le
              , we = Kt * Se
              , Ve = ke / (-Le + Se)
              , Vt = Ve * -Le;
            if (Q.matrixWorld.decompose(X.position, X.quaternion, X.scale),
            X.translateX(Vt),
            X.translateZ(Ve),
            X.matrixWorld.compose(X.position, X.quaternion, X.scale),
            X.matrixWorldInverse.copy(X.matrixWorld).invert(),
            Ae[10] === -1)
                X.projectionMatrix.copy(Q.projectionMatrix),
                X.projectionMatrixInverse.copy(Q.projectionMatrixInverse);
            else {
                const Mt = Kt + Ve
                  , R = N + Ve
                  , w = pt - Vt
                  , O = we + (ke - Vt)
                  , K = ft * N / R * Mt
                  , ee = Oe * N / R * Mt;
                X.projectionMatrix.makePerspective(w, O, K, ee, Mt, R),
                X.projectionMatrixInverse.copy(X.projectionMatrix).invert()
            }
        }
        function le(X, Q) {
            Q === null ? X.matrixWorld.copy(X.matrix) : X.matrixWorld.multiplyMatrices(Q.matrixWorld, X.matrix),
            X.matrixWorldInverse.copy(X.matrixWorld).invert()
        }
        this.updateCamera = function(X) {
            if (r === null)
                return;
            let Q = X.near
              , ge = X.far;
            g.texture !== null && (g.depthNear > 0 && (Q = g.depthNear),
            g.depthFar > 0 && (ge = g.depthFar)),
            F.near = b.near = M.near = Q,
            F.far = b.far = M.far = ge,
            (H !== F.near || Z !== F.far) && (r.updateRenderState({
                depthNear: F.near,
                depthFar: F.far
            }),
            H = F.near,
            Z = F.far),
            F.layers.mask = X.layers.mask | 6,
            M.layers.mask = F.layers.mask & 3,
            b.layers.mask = F.layers.mask & 5;
            const ke = X.parent
              , Ae = F.cameras;
            le(F, ke);
            for (let Ye = 0; Ye < Ae.length; Ye++)
                le(Ae[Ye], ke);
            Ae.length === 2 ? Y(F, M, b) : F.projectionMatrix.copy(M.projectionMatrix),
            xe(X, F, ke)
        }
        ;
        function xe(X, Q, ge) {
            ge === null ? X.matrix.copy(Q.matrixWorld) : (X.matrix.copy(ge.matrixWorld),
            X.matrix.invert(),
            X.matrix.multiply(Q.matrixWorld)),
            X.matrix.decompose(X.position, X.quaternion, X.scale),
            X.updateMatrixWorld(!0),
            X.projectionMatrix.copy(Q.projectionMatrix),
            X.projectionMatrixInverse.copy(Q.projectionMatrixInverse),
            X.isPerspectiveCamera && (X.fov = Zp * 2 * Math.atan(1 / X.projectionMatrix.elements[5]),
            X.zoom = 1)
        }
        this.getCamera = function() {
            return F
        }
        ,
        this.getFoveation = function() {
            if (!(h === null && p === null))
                return l
        }
        ,
        this.setFoveation = function(X) {
            l = X,
            h !== null && (h.fixedFoveation = X),
            p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = X)
        }
        ,
        this.hasDepthSensing = function() {
            return g.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return g.getMesh(F)
        }
        ,
        this.getCameraTexture = function(X) {
            return f[X]
        }
        ;
        let qe = null;
        function Ke(X, Q) {
            if (u = Q.getViewerPose(c || o),
            v = Q,
            u !== null) {
                const ge = u.views;
                p !== null && (e.setRenderTargetFramebuffer(S, p.framebuffer),
                e.setRenderTarget(S));
                let ke = !1;
                ge.length !== F.cameras.length && (F.cameras.length = 0,
                ke = !0);
                for (let N = 0; N < ge.length; N++) {
                    const ft = ge[N];
                    let Oe = null;
                    if (p !== null)
                        Oe = p.getViewport(ft);
                    else {
                        const Se = d.getViewSubImage(h, ft);
                        Oe = Se.viewport,
                        N === 0 && (e.setRenderTargetTextures(S, Se.colorTexture, Se.depthStencilTexture),
                        e.setRenderTarget(S))
                    }
                    let Le = L[N];
                    Le === void 0 && (Le = new jn,
                    Le.layers.enable(N),
                    Le.viewport = new Rt,
                    L[N] = Le),
                    Le.matrix.fromArray(ft.transform.matrix),
                    Le.matrix.decompose(Le.position, Le.quaternion, Le.scale),
                    Le.projectionMatrix.fromArray(ft.projectionMatrix),
                    Le.projectionMatrixInverse.copy(Le.projectionMatrix).invert(),
                    Le.viewport.set(Oe.x, Oe.y, Oe.width, Oe.height),
                    N === 0 && (F.matrix.copy(Le.matrix),
                    F.matrix.decompose(F.position, F.quaternion, F.scale)),
                    ke === !0 && F.cameras.push(Le)
                }
                const Ae = r.enabledFeatures;
                if (Ae && Ae.includes("depth-sensing") && r.depthUsage == "gpu-optimized" && x) {
                    d = i.getBinding();
                    const N = d.getDepthInformation(ge[0]);
                    N && N.isValid && N.texture && g.init(N, r.renderState)
                }
                if (Ae && Ae.includes("camera-access") && x) {
                    e.state.unbindTexture(),
                    d = i.getBinding();
                    for (let N = 0; N < ge.length; N++) {
                        const ft = ge[N].camera;
                        if (ft) {
                            let Oe = f[ft];
                            Oe || (Oe = new vE,
                            f[ft] = Oe);
                            const Le = d.getCameraImage(ft);
                            Oe.sourceTexture = Le
                        }
                    }
                }
            }
            for (let ge = 0; ge < T.length; ge++) {
                const ke = A[ge]
                  , Ae = T[ge];
                ke !== null && Ae !== void 0 && Ae.update(ke, Q, c || o)
            }
            qe && qe(X, Q),
            Q.detectedPlanes && i.dispatchEvent({
                type: "planesdetected",
                data: Q
            }),
            v = null
        }
        const We = new _E;
        We.setAnimationLoop(Ke),
        this.setAnimationLoop = function(X) {
            qe = X
        }
        ,
        this.dispose = function() {}
    }
}
const Yr = new Zi
  , mO = new Lt;
function gO(t, e) {
    function n(g, f) {
        g.matrixAutoUpdate === !0 && g.updateMatrix(),
        f.value.copy(g.matrix)
    }
    function i(g, f) {
        f.color.getRGB(g.fogColor.value, dE(t)),
        f.isFog ? (g.fogNear.value = f.near,
        g.fogFar.value = f.far) : f.isFogExp2 && (g.fogDensity.value = f.density)
    }
    function r(g, f, y, _, S) {
        f.isMeshBasicMaterial || f.isMeshLambertMaterial ? s(g, f) : f.isMeshToonMaterial ? (s(g, f),
        d(g, f)) : f.isMeshPhongMaterial ? (s(g, f),
        u(g, f)) : f.isMeshStandardMaterial ? (s(g, f),
        h(g, f),
        f.isMeshPhysicalMaterial && p(g, f, S)) : f.isMeshMatcapMaterial ? (s(g, f),
        v(g, f)) : f.isMeshDepthMaterial ? s(g, f) : f.isMeshDistanceMaterial ? (s(g, f),
        x(g, f)) : f.isMeshNormalMaterial ? s(g, f) : f.isLineBasicMaterial ? (o(g, f),
        f.isLineDashedMaterial && a(g, f)) : f.isPointsMaterial ? l(g, f, y, _) : f.isSpriteMaterial ? c(g, f) : f.isShadowMaterial ? (g.color.value.copy(f.color),
        g.opacity.value = f.opacity) : f.isShaderMaterial && (f.uniformsNeedUpdate = !1)
    }
    function s(g, f) {
        g.opacity.value = f.opacity,
        f.color && g.diffuse.value.copy(f.color),
        f.emissive && g.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),
        f.map && (g.map.value = f.map,
        n(f.map, g.mapTransform)),
        f.alphaMap && (g.alphaMap.value = f.alphaMap,
        n(f.alphaMap, g.alphaMapTransform)),
        f.bumpMap && (g.bumpMap.value = f.bumpMap,
        n(f.bumpMap, g.bumpMapTransform),
        g.bumpScale.value = f.bumpScale,
        f.side === Sn && (g.bumpScale.value *= -1)),
        f.normalMap && (g.normalMap.value = f.normalMap,
        n(f.normalMap, g.normalMapTransform),
        g.normalScale.value.copy(f.normalScale),
        f.side === Sn && g.normalScale.value.negate()),
        f.displacementMap && (g.displacementMap.value = f.displacementMap,
        n(f.displacementMap, g.displacementMapTransform),
        g.displacementScale.value = f.displacementScale,
        g.displacementBias.value = f.displacementBias),
        f.emissiveMap && (g.emissiveMap.value = f.emissiveMap,
        n(f.emissiveMap, g.emissiveMapTransform)),
        f.specularMap && (g.specularMap.value = f.specularMap,
        n(f.specularMap, g.specularMapTransform)),
        f.alphaTest > 0 && (g.alphaTest.value = f.alphaTest);
        const y = e.get(f)
          , _ = y.envMap
          , S = y.envMapRotation;
        _ && (g.envMap.value = _,
        Yr.copy(S),
        Yr.x *= -1,
        Yr.y *= -1,
        Yr.z *= -1,
        _.isCubeTexture && _.isRenderTargetTexture === !1 && (Yr.y *= -1,
        Yr.z *= -1),
        g.envMapRotation.value.setFromMatrix4(mO.makeRotationFromEuler(Yr)),
        g.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1,
        g.reflectivity.value = f.reflectivity,
        g.ior.value = f.ior,
        g.refractionRatio.value = f.refractionRatio),
        f.lightMap && (g.lightMap.value = f.lightMap,
        g.lightMapIntensity.value = f.lightMapIntensity,
        n(f.lightMap, g.lightMapTransform)),
        f.aoMap && (g.aoMap.value = f.aoMap,
        g.aoMapIntensity.value = f.aoMapIntensity,
        n(f.aoMap, g.aoMapTransform))
    }
    function o(g, f) {
        g.diffuse.value.copy(f.color),
        g.opacity.value = f.opacity,
        f.map && (g.map.value = f.map,
        n(f.map, g.mapTransform))
    }
    function a(g, f) {
        g.dashSize.value = f.dashSize,
        g.totalSize.value = f.dashSize + f.gapSize,
        g.scale.value = f.scale
    }
    function l(g, f, y, _) {
        g.diffuse.value.copy(f.color),
        g.opacity.value = f.opacity,
        g.size.value = f.size * y,
        g.scale.value = _ * .5,
        f.map && (g.map.value = f.map,
        n(f.map, g.uvTransform)),
        f.alphaMap && (g.alphaMap.value = f.alphaMap,
        n(f.alphaMap, g.alphaMapTransform)),
        f.alphaTest > 0 && (g.alphaTest.value = f.alphaTest)
    }
    function c(g, f) {
        g.diffuse.value.copy(f.color),
        g.opacity.value = f.opacity,
        g.rotation.value = f.rotation,
        f.map && (g.map.value = f.map,
        n(f.map, g.mapTransform)),
        f.alphaMap && (g.alphaMap.value = f.alphaMap,
        n(f.alphaMap, g.alphaMapTransform)),
        f.alphaTest > 0 && (g.alphaTest.value = f.alphaTest)
    }
    function u(g, f) {
        g.specular.value.copy(f.specular),
        g.shininess.value = Math.max(f.shininess, 1e-4)
    }
    function d(g, f) {
        f.gradientMap && (g.gradientMap.value = f.gradientMap)
    }
    function h(g, f) {
        g.metalness.value = f.metalness,
        f.metalnessMap && (g.metalnessMap.value = f.metalnessMap,
        n(f.metalnessMap, g.metalnessMapTransform)),
        g.roughness.value = f.roughness,
        f.roughnessMap && (g.roughnessMap.value = f.roughnessMap,
        n(f.roughnessMap, g.roughnessMapTransform)),
        f.envMap && (g.envMapIntensity.value = f.envMapIntensity)
    }
    function p(g, f, y) {
        g.ior.value = f.ior,
        f.sheen > 0 && (g.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),
        g.sheenRoughness.value = f.sheenRoughness,
        f.sheenColorMap && (g.sheenColorMap.value = f.sheenColorMap,
        n(f.sheenColorMap, g.sheenColorMapTransform)),
        f.sheenRoughnessMap && (g.sheenRoughnessMap.value = f.sheenRoughnessMap,
        n(f.sheenRoughnessMap, g.sheenRoughnessMapTransform))),
        f.clearcoat > 0 && (g.clearcoat.value = f.clearcoat,
        g.clearcoatRoughness.value = f.clearcoatRoughness,
        f.clearcoatMap && (g.clearcoatMap.value = f.clearcoatMap,
        n(f.clearcoatMap, g.clearcoatMapTransform)),
        f.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = f.clearcoatRoughnessMap,
        n(f.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)),
        f.clearcoatNormalMap && (g.clearcoatNormalMap.value = f.clearcoatNormalMap,
        n(f.clearcoatNormalMap, g.clearcoatNormalMapTransform),
        g.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),
        f.side === Sn && g.clearcoatNormalScale.value.negate())),
        f.dispersion > 0 && (g.dispersion.value = f.dispersion),
        f.iridescence > 0 && (g.iridescence.value = f.iridescence,
        g.iridescenceIOR.value = f.iridescenceIOR,
        g.iridescenceThicknessMinimum.value = f.iridescenceThicknessRange[0],
        g.iridescenceThicknessMaximum.value = f.iridescenceThicknessRange[1],
        f.iridescenceMap && (g.iridescenceMap.value = f.iridescenceMap,
        n(f.iridescenceMap, g.iridescenceMapTransform)),
        f.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = f.iridescenceThicknessMap,
        n(f.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))),
        f.transmission > 0 && (g.transmission.value = f.transmission,
        g.transmissionSamplerMap.value = y.texture,
        g.transmissionSamplerSize.value.set(y.width, y.height),
        f.transmissionMap && (g.transmissionMap.value = f.transmissionMap,
        n(f.transmissionMap, g.transmissionMapTransform)),
        g.thickness.value = f.thickness,
        f.thicknessMap && (g.thicknessMap.value = f.thicknessMap,
        n(f.thicknessMap, g.thicknessMapTransform)),
        g.attenuationDistance.value = f.attenuationDistance,
        g.attenuationColor.value.copy(f.attenuationColor)),
        f.anisotropy > 0 && (g.anisotropyVector.value.set(f.anisotropy * Math.cos(f.anisotropyRotation), f.anisotropy * Math.sin(f.anisotropyRotation)),
        f.anisotropyMap && (g.anisotropyMap.value = f.anisotropyMap,
        n(f.anisotropyMap, g.anisotropyMapTransform))),
        g.specularIntensity.value = f.specularIntensity,
        g.specularColor.value.copy(f.specularColor),
        f.specularColorMap && (g.specularColorMap.value = f.specularColorMap,
        n(f.specularColorMap, g.specularColorMapTransform)),
        f.specularIntensityMap && (g.specularIntensityMap.value = f.specularIntensityMap,
        n(f.specularIntensityMap, g.specularIntensityMapTransform))
    }
    function v(g, f) {
        f.matcap && (g.matcap.value = f.matcap)
    }
    function x(g, f) {
        const y = e.get(f).light;
        g.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
        g.nearDistance.value = y.shadow.camera.near,
        g.farDistance.value = y.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: r
    }
}
function vO(t, e, n, i) {
    let r = {}
      , s = {}
      , o = [];
    const a = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(y, _) {
        const S = _.program;
        i.uniformBlockBinding(y, S)
    }
    function c(y, _) {
        let S = r[y.id];
        S === void 0 && (v(y),
        S = u(y),
        r[y.id] = S,
        y.addEventListener("dispose", g));
        const T = _.program;
        i.updateUBOMapping(y, T);
        const A = e.render.frame;
        s[y.id] !== A && (h(y),
        s[y.id] = A)
    }
    function u(y) {
        const _ = d();
        y.__bindingPointIndex = _;
        const S = t.createBuffer()
          , T = y.__size
          , A = y.usage;
        return t.bindBuffer(t.UNIFORM_BUFFER, S),
        t.bufferData(t.UNIFORM_BUFFER, T, A),
        t.bindBuffer(t.UNIFORM_BUFFER, null),
        t.bindBufferBase(t.UNIFORM_BUFFER, _, S),
        S
    }
    function d() {
        for (let y = 0; y < a; y++)
            if (o.indexOf(y) === -1)
                return o.push(y),
                y;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function h(y) {
        const _ = r[y.id]
          , S = y.uniforms
          , T = y.__cache;
        t.bindBuffer(t.UNIFORM_BUFFER, _);
        for (let A = 0, C = S.length; A < C; A++) {
            const P = Array.isArray(S[A]) ? S[A] : [S[A]];
            for (let M = 0, b = P.length; M < b; M++) {
                const L = P[M];
                if (p(L, A, M, T) === !0) {
                    const F = L.__offset
                      , H = Array.isArray(L.value) ? L.value : [L.value];
                    let Z = 0;
                    for (let $ = 0; $ < H.length; $++) {
                        const q = H[$]
                          , B = x(q);
                        typeof q == "number" || typeof q == "boolean" ? (L.__data[0] = q,
                        t.bufferSubData(t.UNIFORM_BUFFER, F + Z, L.__data)) : q.isMatrix3 ? (L.__data[0] = q.elements[0],
                        L.__data[1] = q.elements[1],
                        L.__data[2] = q.elements[2],
                        L.__data[3] = 0,
                        L.__data[4] = q.elements[3],
                        L.__data[5] = q.elements[4],
                        L.__data[6] = q.elements[5],
                        L.__data[7] = 0,
                        L.__data[8] = q.elements[6],
                        L.__data[9] = q.elements[7],
                        L.__data[10] = q.elements[8],
                        L.__data[11] = 0) : (q.toArray(L.__data, Z),
                        Z += B.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    t.bufferSubData(t.UNIFORM_BUFFER, F, L.__data)
                }
            }
        }
        t.bindBuffer(t.UNIFORM_BUFFER, null)
    }
    function p(y, _, S, T) {
        const A = y.value
          , C = _ + "_" + S;
        if (T[C] === void 0)
            return typeof A == "number" || typeof A == "boolean" ? T[C] = A : T[C] = A.clone(),
            !0;
        {
            const P = T[C];
            if (typeof A == "number" || typeof A == "boolean") {
                if (P !== A)
                    return T[C] = A,
                    !0
            } else if (P.equals(A) === !1)
                return P.copy(A),
                !0
        }
        return !1
    }
    function v(y) {
        const _ = y.uniforms;
        let S = 0;
        const T = 16;
        for (let C = 0, P = _.length; C < P; C++) {
            const M = Array.isArray(_[C]) ? _[C] : [_[C]];
            for (let b = 0, L = M.length; b < L; b++) {
                const F = M[b]
                  , H = Array.isArray(F.value) ? F.value : [F.value];
                for (let Z = 0, $ = H.length; Z < $; Z++) {
                    const q = H[Z]
                      , B = x(q)
                      , D = S % T
                      , G = D % B.boundary
                      , Y = D + G;
                    S += G,
                    Y !== 0 && T - Y < B.storage && (S += T - Y),
                    F.__data = new Float32Array(B.storage / Float32Array.BYTES_PER_ELEMENT),
                    F.__offset = S,
                    S += B.storage
                }
            }
        }
        const A = S % T;
        return A > 0 && (S += T - A),
        y.__size = S,
        y.__cache = {},
        this
    }
    function x(y) {
        const _ = {
            boundary: 0,
            storage: 0
        };
        return typeof y == "number" || typeof y == "boolean" ? (_.boundary = 4,
        _.storage = 4) : y.isVector2 ? (_.boundary = 8,
        _.storage = 8) : y.isVector3 || y.isColor ? (_.boundary = 16,
        _.storage = 12) : y.isVector4 ? (_.boundary = 16,
        _.storage = 16) : y.isMatrix3 ? (_.boundary = 48,
        _.storage = 48) : y.isMatrix4 ? (_.boundary = 64,
        _.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y),
        _
    }
    function g(y) {
        const _ = y.target;
        _.removeEventListener("dispose", g);
        const S = o.indexOf(_.__bindingPointIndex);
        o.splice(S, 1),
        t.deleteBuffer(r[_.id]),
        delete r[_.id],
        delete s[_.id]
    }
    function f() {
        for (const y in r)
            t.deleteBuffer(r[y]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: f
    }
}
class _O {
    constructor(e={}) {
        const {canvas: n=eL(), context: i=null, depth: r=!0, stencil: s=!1, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: u="default", failIfMajorPerformanceCaveat: d=!1, reversedDepthBuffer: h=!1} = e;
        this.isWebGLRenderer = !0;
        let p;
        if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            p = i.getContextAttributes().alpha
        } else
            p = o;
        const v = new Uint32Array(4)
          , x = new Int32Array(4);
        let g = null
          , f = null;
        const y = []
          , _ = [];
        this.domElement = n,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.toneMapping = Cr,
        this.toneMappingExposure = 1,
        this.transmissionResolutionScale = 1;
        const S = this;
        let T = !1;
        this._outputColorSpace = Bn;
        let A = 0
          , C = 0
          , P = null
          , M = -1
          , b = null;
        const L = new Rt
          , F = new Rt;
        let H = null;
        const Z = new tt(0);
        let $ = 0
          , q = n.width
          , B = n.height
          , D = 1
          , G = null
          , Y = null;
        const le = new Rt(0,0,q,B)
          , xe = new Rt(0,0,q,B);
        let qe = !1;
        const Ke = new pE;
        let We = !1
          , X = !1;
        const Q = new Lt
          , ge = new z
          , ke = new Rt
          , Ae = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let Ye = !1;
        function Kt() {
            return P === null ? D : 1
        }
        let N = i;
        function ft(E, k) {
            return n.getContext(E, k)
        }
        try {
            const E = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: u,
                failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute"in n && n.setAttribute("data-engine", `three.js r${Pg}`),
            n.addEventListener("webglcontextlost", ce, !1),
            n.addEventListener("webglcontextrestored", ve, !1),
            n.addEventListener("webglcontextcreationerror", ne, !1),
            N === null) {
                const k = "webgl2";
                if (N = ft(k, E),
                N === null)
                    throw ft(k) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (E) {
            throw console.error("THREE.WebGLRenderer: " + E.message),
            E
        }
        let Oe, Le, Se, pt, we, Ve, Vt, Mt, R, w, O, K, ee, W, Me, ae, be, Ee, re, fe, Ne, Te, de, Be;
        function I() {
            Oe = new Ck(N),
            Oe.init(),
            Te = new uO(N,Oe),
            Le = new Sk(N,Oe,e,Te),
            Se = new lO(N,Oe),
            Le.reversedDepthBuffer && h && Se.buffers.depth.setReversed(!0),
            pt = new Nk(N),
            we = new KU,
            Ve = new cO(N,Oe,Se,we,Le,Te,pt),
            Vt = new bk(S),
            Mt = new Ak(S),
            R = new OL(N),
            de = new yk(N,R),
            w = new Rk(N,R,pt,de),
            O = new Lk(N,w,R,pt),
            re = new Dk(N,Le,Ve),
            ae = new wk(we),
            K = new qU(S,Vt,Mt,Oe,Le,de,ae),
            ee = new gO(S,we),
            W = new ZU,
            Me = new iO(Oe),
            Ee = new _k(S,Vt,Mt,Se,O,p,l),
            be = new oO(S,O,Le),
            Be = new vO(N,pt,Le,Se),
            fe = new xk(N,Oe,pt),
            Ne = new Pk(N,Oe,pt),
            pt.programs = K.programs,
            S.capabilities = Le,
            S.extensions = Oe,
            S.properties = we,
            S.renderLists = W,
            S.shadowMap = be,
            S.state = Se,
            S.info = pt
        }
        I();
        const se = new pO(S,N);
        this.xr = se,
        this.getContext = function() {
            return N
        }
        ,
        this.getContextAttributes = function() {
            return N.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const E = Oe.get("WEBGL_lose_context");
            E && E.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const E = Oe.get("WEBGL_lose_context");
            E && E.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return D
        }
        ,
        this.setPixelRatio = function(E) {
            E !== void 0 && (D = E,
            this.setSize(q, B, !1))
        }
        ,
        this.getSize = function(E) {
            return E.set(q, B)
        }
        ,
        this.setSize = function(E, k, V=!0) {
            if (se.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            q = E,
            B = k,
            n.width = Math.floor(E * D),
            n.height = Math.floor(k * D),
            V === !0 && (n.style.width = E + "px",
            n.style.height = k + "px"),
            this.setViewport(0, 0, E, k)
        }
        ,
        this.getDrawingBufferSize = function(E) {
            return E.set(q * D, B * D).floor()
        }
        ,
        this.setDrawingBufferSize = function(E, k, V) {
            q = E,
            B = k,
            D = V,
            n.width = Math.floor(E * V),
            n.height = Math.floor(k * V),
            this.setViewport(0, 0, E, k)
        }
        ,
        this.getCurrentViewport = function(E) {
            return E.copy(L)
        }
        ,
        this.getViewport = function(E) {
            return E.copy(le)
        }
        ,
        this.setViewport = function(E, k, V, j) {
            E.isVector4 ? le.set(E.x, E.y, E.z, E.w) : le.set(E, k, V, j),
            Se.viewport(L.copy(le).multiplyScalar(D).round())
        }
        ,
        this.getScissor = function(E) {
            return E.copy(xe)
        }
        ,
        this.setScissor = function(E, k, V, j) {
            E.isVector4 ? xe.set(E.x, E.y, E.z, E.w) : xe.set(E, k, V, j),
            Se.scissor(F.copy(xe).multiplyScalar(D).round())
        }
        ,
        this.getScissorTest = function() {
            return qe
        }
        ,
        this.setScissorTest = function(E) {
            Se.setScissorTest(qe = E)
        }
        ,
        this.setOpaqueSort = function(E) {
            G = E
        }
        ,
        this.setTransparentSort = function(E) {
            Y = E
        }
        ,
        this.getClearColor = function(E) {
            return E.copy(Ee.getClearColor())
        }
        ,
        this.setClearColor = function() {
            Ee.setClearColor(...arguments)
        }
        ,
        this.getClearAlpha = function() {
            return Ee.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            Ee.setClearAlpha(...arguments)
        }
        ,
        this.clear = function(E=!0, k=!0, V=!0) {
            let j = 0;
            if (E) {
                let U = !1;
                if (P !== null) {
                    const ie = P.texture.format;
                    U = ie === Ug || ie === kg || ie === Ig
                }
                if (U) {
                    const ie = P.texture.type
                      , he = ie === Yi || ie === ws || ie === al || ie === ll || ie === Dg || ie === Lg
                      , _e = Ee.getClearColor()
                      , me = Ee.getClearAlpha()
                      , Pe = _e.r
                      , Ie = _e.g
                      , Ce = _e.b;
                    he ? (v[0] = Pe,
                    v[1] = Ie,
                    v[2] = Ce,
                    v[3] = me,
                    N.clearBufferuiv(N.COLOR, 0, v)) : (x[0] = Pe,
                    x[1] = Ie,
                    x[2] = Ce,
                    x[3] = me,
                    N.clearBufferiv(N.COLOR, 0, x))
                } else
                    j |= N.COLOR_BUFFER_BIT
            }
            k && (j |= N.DEPTH_BUFFER_BIT),
            V && (j |= N.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            N.clear(j)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            n.removeEventListener("webglcontextlost", ce, !1),
            n.removeEventListener("webglcontextrestored", ve, !1),
            n.removeEventListener("webglcontextcreationerror", ne, !1),
            Ee.dispose(),
            W.dispose(),
            Me.dispose(),
            we.dispose(),
            Vt.dispose(),
            Mt.dispose(),
            O.dispose(),
            de.dispose(),
            Be.dispose(),
            K.dispose(),
            se.dispose(),
            se.removeEventListener("sessionstart", hi),
            se.removeEventListener("sessionend", Bg),
            zr.stop()
        }
        ;
        function ce(E) {
            E.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            T = !0
        }
        function ve() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            T = !1;
            const E = pt.autoReset
              , k = be.enabled
              , V = be.autoUpdate
              , j = be.needsUpdate
              , U = be.type;
            I(),
            pt.autoReset = E,
            be.enabled = k,
            be.autoUpdate = V,
            be.needsUpdate = j,
            be.type = U
        }
        function ne(E) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", E.statusMessage)
        }
        function J(E) {
            const k = E.target;
            k.removeEventListener("dispose", J),
            ye(k)
        }
        function ye(E) {
            Ue(E),
            we.remove(E)
        }
        function Ue(E) {
            const k = we.get(E).programs;
            k !== void 0 && (k.forEach(function(V) {
                K.releaseProgram(V)
            }),
            E.isShaderMaterial && K.releaseShaderCache(E))
        }
        this.renderBufferDirect = function(E, k, V, j, U, ie) {
            k === null && (k = Ae);
            const he = U.isMesh && U.matrixWorld.determinant() < 0
              , _e = bE(E, k, V, j, U);
            Se.setMaterial(j, he);
            let me = V.index
              , Pe = 1;
            if (j.wireframe === !0) {
                if (me = w.getWireframeAttribute(V),
                me === void 0)
                    return;
                Pe = 2
            }
            const Ie = V.drawRange
              , Ce = V.attributes.position;
            let $e = Ie.start * Pe
              , it = (Ie.start + Ie.count) * Pe;
            ie !== null && ($e = Math.max($e, ie.start * Pe),
            it = Math.min(it, (ie.start + ie.count) * Pe)),
            me !== null ? ($e = Math.max($e, 0),
            it = Math.min(it, me.count)) : Ce != null && ($e = Math.max($e, 0),
            it = Math.min(it, Ce.count));
            const bt = it - $e;
            if (bt < 0 || bt === 1 / 0)
                return;
            de.setup(U, j, _e, V, me);
            let ut, ot = fe;
            if (me !== null && (ut = R.get(me),
            ot = Ne,
            ot.setIndex(ut)),
            U.isMesh)
                j.wireframe === !0 ? (Se.setLineWidth(j.wireframeLinewidth * Kt()),
                ot.setMode(N.LINES)) : ot.setMode(N.TRIANGLES);
            else if (U.isLine) {
                let Re = j.linewidth;
                Re === void 0 && (Re = 1),
                Se.setLineWidth(Re * Kt()),
                U.isLineSegments ? ot.setMode(N.LINES) : U.isLineLoop ? ot.setMode(N.LINE_LOOP) : ot.setMode(N.LINE_STRIP)
            } else
                U.isPoints ? ot.setMode(N.POINTS) : U.isSprite && ot.setMode(N.TRIANGLES);
            if (U.isBatchedMesh)
                if (U._multiDrawInstances !== null)
                    dl("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                    ot.renderMultiDrawInstances(U._multiDrawStarts, U._multiDrawCounts, U._multiDrawCount, U._multiDrawInstances);
                else if (Oe.get("WEBGL_multi_draw"))
                    ot.renderMultiDraw(U._multiDrawStarts, U._multiDrawCounts, U._multiDrawCount);
                else {
                    const Re = U._multiDrawStarts
                      , vt = U._multiDrawCounts
                      , Je = U._multiDrawCount
                      , En = me ? R.get(me).bytesPerElement : 1
                      , As = we.get(j).currentProgram.getUniforms();
                    for (let Tn = 0; Tn < Je; Tn++)
                        As.setValue(N, "_gl_DrawID", Tn),
                        ot.render(Re[Tn] / En, vt[Tn])
                }
            else if (U.isInstancedMesh)
                ot.renderInstances($e, bt, U.count);
            else if (V.isInstancedBufferGeometry) {
                const Re = V._maxInstanceCount !== void 0 ? V._maxInstanceCount : 1 / 0
                  , vt = Math.min(V.instanceCount, Re);
                ot.renderInstances($e, bt, vt)
            } else
                ot.render($e, bt)
        }
        ;
        function at(E, k, V) {
            E.transparent === !0 && E.side === Ui && E.forceSinglePass === !1 ? (E.side = Sn,
            E.needsUpdate = !0,
            Dl(E, k, V),
            E.side = Lr,
            E.needsUpdate = !0,
            Dl(E, k, V),
            E.side = Ui) : Dl(E, k, V)
        }
        this.compile = function(E, k, V=null) {
            V === null && (V = E),
            f = Me.get(V),
            f.init(k),
            _.push(f),
            V.traverseVisible(function(U) {
                U.isLight && U.layers.test(k.layers) && (f.pushLight(U),
                U.castShadow && f.pushShadow(U))
            }),
            E !== V && E.traverseVisible(function(U) {
                U.isLight && U.layers.test(k.layers) && (f.pushLight(U),
                U.castShadow && f.pushShadow(U))
            }),
            f.setupLights();
            const j = new Set;
            return E.traverse(function(U) {
                if (!(U.isMesh || U.isPoints || U.isLine || U.isSprite))
                    return;
                const ie = U.material;
                if (ie)
                    if (Array.isArray(ie))
                        for (let he = 0; he < ie.length; he++) {
                            const _e = ie[he];
                            at(_e, V, U),
                            j.add(_e)
                        }
                    else
                        at(ie, V, U),
                        j.add(ie)
            }),
            f = _.pop(),
            j
        }
        ,
        this.compileAsync = function(E, k, V=null) {
            const j = this.compile(E, k, V);
            return new Promise(U => {
                function ie() {
                    if (j.forEach(function(he) {
                        we.get(he).currentProgram.isReady() && j.delete(he)
                    }),
                    j.size === 0) {
                        U(E);
                        return
                    }
                    setTimeout(ie, 10)
                }
                Oe.get("KHR_parallel_shader_compile") !== null ? ie() : setTimeout(ie, 10)
            }
            )
        }
        ;
        let et = null;
        function Ti(E) {
            et && et(E)
        }
        function hi() {
            zr.stop()
        }
        function Bg() {
            zr.start()
        }
        const zr = new _E;
        zr.setAnimationLoop(Ti),
        typeof self < "u" && zr.setContext(self),
        this.setAnimationLoop = function(E) {
            et = E,
            se.setAnimationLoop(E),
            E === null ? zr.stop() : zr.start()
        }
        ,
        se.addEventListener("sessionstart", hi),
        se.addEventListener("sessionend", Bg),
        this.render = function(E, k) {
            if (k !== void 0 && k.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (T === !0)
                return;
            if (E.matrixWorldAutoUpdate === !0 && E.updateMatrixWorld(),
            k.parent === null && k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(),
            se.enabled === !0 && se.isPresenting === !0 && (se.cameraAutoUpdate === !0 && se.updateCamera(k),
            k = se.getCamera()),
            E.isScene === !0 && E.onBeforeRender(S, E, k, P),
            f = Me.get(E, _.length),
            f.init(k),
            _.push(f),
            Q.multiplyMatrices(k.projectionMatrix, k.matrixWorldInverse),
            Ke.setFromProjectionMatrix(Q, yi, k.reversedDepth),
            X = this.localClippingEnabled,
            We = ae.init(this.clippingPlanes, X),
            g = W.get(E, y.length),
            g.init(),
            y.push(g),
            se.enabled === !0 && se.isPresenting === !0) {
                const ie = S.xr.getDepthSensingMesh();
                ie !== null && ad(ie, k, -1 / 0, S.sortObjects)
            }
            ad(E, k, 0, S.sortObjects),
            g.finish(),
            S.sortObjects === !0 && g.sort(G, Y),
            Ye = se.enabled === !1 || se.isPresenting === !1 || se.hasDepthSensing() === !1,
            Ye && Ee.addToRenderList(g, E),
            this.info.render.frame++,
            We === !0 && ae.beginShadows();
            const V = f.state.shadowsArray;
            be.render(V, E, k),
            We === !0 && ae.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const j = g.opaque
              , U = g.transmissive;
            if (f.setupLights(),
            k.isArrayCamera) {
                const ie = k.cameras;
                if (U.length > 0)
                    for (let he = 0, _e = ie.length; he < _e; he++) {
                        const me = ie[he];
                        Vg(j, U, E, me)
                    }
                Ye && Ee.render(E);
                for (let he = 0, _e = ie.length; he < _e; he++) {
                    const me = ie[he];
                    zg(g, E, me, me.viewport)
                }
            } else
                U.length > 0 && Vg(j, U, E, k),
                Ye && Ee.render(E),
                zg(g, E, k);
            P !== null && C === 0 && (Ve.updateMultisampleRenderTarget(P),
            Ve.updateRenderTargetMipmap(P)),
            E.isScene === !0 && E.onAfterRender(S, E, k),
            de.resetDefaultState(),
            M = -1,
            b = null,
            _.pop(),
            _.length > 0 ? (f = _[_.length - 1],
            We === !0 && ae.setGlobalState(S.clippingPlanes, f.state.camera)) : f = null,
            y.pop(),
            y.length > 0 ? g = y[y.length - 1] : g = null
        }
        ;
        function ad(E, k, V, j) {
            if (E.visible === !1)
                return;
            if (E.layers.test(k.layers)) {
                if (E.isGroup)
                    V = E.renderOrder;
                else if (E.isLOD)
                    E.autoUpdate === !0 && E.update(k);
                else if (E.isLight)
                    f.pushLight(E),
                    E.castShadow && f.pushShadow(E);
                else if (E.isSprite) {
                    if (!E.frustumCulled || Ke.intersectsSprite(E)) {
                        j && ke.setFromMatrixPosition(E.matrixWorld).applyMatrix4(Q);
                        const he = O.update(E)
                          , _e = E.material;
                        _e.visible && g.push(E, he, _e, V, ke.z, null)
                    }
                } else if ((E.isMesh || E.isLine || E.isPoints) && (!E.frustumCulled || Ke.intersectsObject(E))) {
                    const he = O.update(E)
                      , _e = E.material;
                    if (j && (E.boundingSphere !== void 0 ? (E.boundingSphere === null && E.computeBoundingSphere(),
                    ke.copy(E.boundingSphere.center)) : (he.boundingSphere === null && he.computeBoundingSphere(),
                    ke.copy(he.boundingSphere.center)),
                    ke.applyMatrix4(E.matrixWorld).applyMatrix4(Q)),
                    Array.isArray(_e)) {
                        const me = he.groups;
                        for (let Pe = 0, Ie = me.length; Pe < Ie; Pe++) {
                            const Ce = me[Pe]
                              , $e = _e[Ce.materialIndex];
                            $e && $e.visible && g.push(E, he, $e, V, ke.z, Ce)
                        }
                    } else
                        _e.visible && g.push(E, he, _e, V, ke.z, null)
                }
            }
            const ie = E.children;
            for (let he = 0, _e = ie.length; he < _e; he++)
                ad(ie[he], k, V, j)
        }
        function zg(E, k, V, j) {
            const U = E.opaque
              , ie = E.transmissive
              , he = E.transparent;
            f.setupLightsView(V),
            We === !0 && ae.setGlobalState(S.clippingPlanes, V),
            j && Se.viewport(L.copy(j)),
            U.length > 0 && Nl(U, k, V),
            ie.length > 0 && Nl(ie, k, V),
            he.length > 0 && Nl(he, k, V),
            Se.buffers.depth.setTest(!0),
            Se.buffers.depth.setMask(!0),
            Se.buffers.color.setMask(!0),
            Se.setPolygonOffset(!1)
        }
        function Vg(E, k, V, j) {
            if ((V.isScene === !0 ? V.overrideMaterial : null) !== null)
                return;
            f.state.transmissionRenderTarget[j.id] === void 0 && (f.state.transmissionRenderTarget[j.id] = new bs(1,1,{
                generateMipmaps: !0,
                type: Oe.has("EXT_color_buffer_half_float") || Oe.has("EXT_color_buffer_float") ? Tl : Yi,
                minFilter: hs,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: Qe.workingColorSpace
            }));
            const ie = f.state.transmissionRenderTarget[j.id]
              , he = j.viewport || L;
            ie.setSize(he.z * S.transmissionResolutionScale, he.w * S.transmissionResolutionScale);
            const _e = S.getRenderTarget()
              , me = S.getActiveCubeFace()
              , Pe = S.getActiveMipmapLevel();
            S.setRenderTarget(ie),
            S.getClearColor(Z),
            $ = S.getClearAlpha(),
            $ < 1 && S.setClearColor(16777215, .5),
            S.clear(),
            Ye && Ee.render(V);
            const Ie = S.toneMapping;
            S.toneMapping = Cr;
            const Ce = j.viewport;
            if (j.viewport !== void 0 && (j.viewport = void 0),
            f.setupLightsView(j),
            We === !0 && ae.setGlobalState(S.clippingPlanes, j),
            Nl(E, V, j),
            Ve.updateMultisampleRenderTarget(ie),
            Ve.updateRenderTargetMipmap(ie),
            Oe.has("WEBGL_multisampled_render_to_texture") === !1) {
                let $e = !1;
                for (let it = 0, bt = k.length; it < bt; it++) {
                    const ut = k[it]
                      , ot = ut.object
                      , Re = ut.geometry
                      , vt = ut.material
                      , Je = ut.group;
                    if (vt.side === Ui && ot.layers.test(j.layers)) {
                        const En = vt.side;
                        vt.side = Sn,
                        vt.needsUpdate = !0,
                        jg(ot, V, j, Re, vt, Je),
                        vt.side = En,
                        vt.needsUpdate = !0,
                        $e = !0
                    }
                }
                $e === !0 && (Ve.updateMultisampleRenderTarget(ie),
                Ve.updateRenderTargetMipmap(ie))
            }
            S.setRenderTarget(_e, me, Pe),
            S.setClearColor(Z, $),
            Ce !== void 0 && (j.viewport = Ce),
            S.toneMapping = Ie
        }
        function Nl(E, k, V) {
            const j = k.isScene === !0 ? k.overrideMaterial : null;
            for (let U = 0, ie = E.length; U < ie; U++) {
                const he = E[U]
                  , _e = he.object
                  , me = he.geometry
                  , Pe = he.group;
                let Ie = he.material;
                Ie.allowOverride === !0 && j !== null && (Ie = j),
                _e.layers.test(V.layers) && jg(_e, k, V, me, Ie, Pe)
            }
        }
        function jg(E, k, V, j, U, ie) {
            E.onBeforeRender(S, k, V, j, U, ie),
            E.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse, E.matrixWorld),
            E.normalMatrix.getNormalMatrix(E.modelViewMatrix),
            U.onBeforeRender(S, k, V, j, E, ie),
            U.transparent === !0 && U.side === Ui && U.forceSinglePass === !1 ? (U.side = Sn,
            U.needsUpdate = !0,
            S.renderBufferDirect(V, k, j, U, E, ie),
            U.side = Lr,
            U.needsUpdate = !0,
            S.renderBufferDirect(V, k, j, U, E, ie),
            U.side = Ui) : S.renderBufferDirect(V, k, j, U, E, ie),
            E.onAfterRender(S, k, V, j, U, ie)
        }
        function Dl(E, k, V) {
            k.isScene !== !0 && (k = Ae);
            const j = we.get(E)
              , U = f.state.lights
              , ie = f.state.shadowsArray
              , he = U.state.version
              , _e = K.getParameters(E, U.state, ie, k, V)
              , me = K.getProgramCacheKey(_e);
            let Pe = j.programs;
            j.environment = E.isMeshStandardMaterial ? k.environment : null,
            j.fog = k.fog,
            j.envMap = (E.isMeshStandardMaterial ? Mt : Vt).get(E.envMap || j.environment),
            j.envMapRotation = j.environment !== null && E.envMap === null ? k.environmentRotation : E.envMapRotation,
            Pe === void 0 && (E.addEventListener("dispose", J),
            Pe = new Map,
            j.programs = Pe);
            let Ie = Pe.get(me);
            if (Ie !== void 0) {
                if (j.currentProgram === Ie && j.lightsStateVersion === he)
                    return Gg(E, _e),
                    Ie
            } else
                _e.uniforms = K.getUniforms(E),
                E.onBeforeCompile(_e, S),
                Ie = K.acquireProgram(_e, me),
                Pe.set(me, Ie),
                j.uniforms = _e.uniforms;
            const Ce = j.uniforms;
            return (!E.isShaderMaterial && !E.isRawShaderMaterial || E.clipping === !0) && (Ce.clippingPlanes = ae.uniform),
            Gg(E, _e),
            j.needsLights = TE(E),
            j.lightsStateVersion = he,
            j.needsLights && (Ce.ambientLightColor.value = U.state.ambient,
            Ce.lightProbe.value = U.state.probe,
            Ce.directionalLights.value = U.state.directional,
            Ce.directionalLightShadows.value = U.state.directionalShadow,
            Ce.spotLights.value = U.state.spot,
            Ce.spotLightShadows.value = U.state.spotShadow,
            Ce.rectAreaLights.value = U.state.rectArea,
            Ce.ltc_1.value = U.state.rectAreaLTC1,
            Ce.ltc_2.value = U.state.rectAreaLTC2,
            Ce.pointLights.value = U.state.point,
            Ce.pointLightShadows.value = U.state.pointShadow,
            Ce.hemisphereLights.value = U.state.hemi,
            Ce.directionalShadowMap.value = U.state.directionalShadowMap,
            Ce.directionalShadowMatrix.value = U.state.directionalShadowMatrix,
            Ce.spotShadowMap.value = U.state.spotShadowMap,
            Ce.spotLightMatrix.value = U.state.spotLightMatrix,
            Ce.spotLightMap.value = U.state.spotLightMap,
            Ce.pointShadowMap.value = U.state.pointShadowMap,
            Ce.pointShadowMatrix.value = U.state.pointShadowMatrix),
            j.currentProgram = Ie,
            j.uniformsList = null,
            Ie
        }
        function Hg(E) {
            if (E.uniformsList === null) {
                const k = E.currentProgram.getUniforms();
                E.uniformsList = Yc.seqWithValue(k.seq, E.uniforms)
            }
            return E.uniformsList
        }
        function Gg(E, k) {
            const V = we.get(E);
            V.outputColorSpace = k.outputColorSpace,
            V.batching = k.batching,
            V.batchingColor = k.batchingColor,
            V.instancing = k.instancing,
            V.instancingColor = k.instancingColor,
            V.instancingMorph = k.instancingMorph,
            V.skinning = k.skinning,
            V.morphTargets = k.morphTargets,
            V.morphNormals = k.morphNormals,
            V.morphColors = k.morphColors,
            V.morphTargetsCount = k.morphTargetsCount,
            V.numClippingPlanes = k.numClippingPlanes,
            V.numIntersection = k.numClipIntersection,
            V.vertexAlphas = k.vertexAlphas,
            V.vertexTangents = k.vertexTangents,
            V.toneMapping = k.toneMapping
        }
        function bE(E, k, V, j, U) {
            k.isScene !== !0 && (k = Ae),
            Ve.resetTextureUnits();
            const ie = k.fog
              , he = j.isMeshStandardMaterial ? k.environment : null
              , _e = P === null ? S.outputColorSpace : P.isXRRenderTarget === !0 ? P.texture.colorSpace : Fo
              , me = (j.isMeshStandardMaterial ? Mt : Vt).get(j.envMap || he)
              , Pe = j.vertexColors === !0 && !!V.attributes.color && V.attributes.color.itemSize === 4
              , Ie = !!V.attributes.tangent && (!!j.normalMap || j.anisotropy > 0)
              , Ce = !!V.morphAttributes.position
              , $e = !!V.morphAttributes.normal
              , it = !!V.morphAttributes.color;
            let bt = Cr;
            j.toneMapped && (P === null || P.isXRRenderTarget === !0) && (bt = S.toneMapping);
            const ut = V.morphAttributes.position || V.morphAttributes.normal || V.morphAttributes.color
              , ot = ut !== void 0 ? ut.length : 0
              , Re = we.get(j)
              , vt = f.state.lights;
            if (We === !0 && (X === !0 || E !== b)) {
                const rn = E === b && j.id === M;
                ae.setState(j, E, rn)
            }
            let Je = !1;
            j.version === Re.__version ? (Re.needsLights && Re.lightsStateVersion !== vt.state.version || Re.outputColorSpace !== _e || U.isBatchedMesh && Re.batching === !1 || !U.isBatchedMesh && Re.batching === !0 || U.isBatchedMesh && Re.batchingColor === !0 && U.colorTexture === null || U.isBatchedMesh && Re.batchingColor === !1 && U.colorTexture !== null || U.isInstancedMesh && Re.instancing === !1 || !U.isInstancedMesh && Re.instancing === !0 || U.isSkinnedMesh && Re.skinning === !1 || !U.isSkinnedMesh && Re.skinning === !0 || U.isInstancedMesh && Re.instancingColor === !0 && U.instanceColor === null || U.isInstancedMesh && Re.instancingColor === !1 && U.instanceColor !== null || U.isInstancedMesh && Re.instancingMorph === !0 && U.morphTexture === null || U.isInstancedMesh && Re.instancingMorph === !1 && U.morphTexture !== null || Re.envMap !== me || j.fog === !0 && Re.fog !== ie || Re.numClippingPlanes !== void 0 && (Re.numClippingPlanes !== ae.numPlanes || Re.numIntersection !== ae.numIntersection) || Re.vertexAlphas !== Pe || Re.vertexTangents !== Ie || Re.morphTargets !== Ce || Re.morphNormals !== $e || Re.morphColors !== it || Re.toneMapping !== bt || Re.morphTargetsCount !== ot) && (Je = !0) : (Je = !0,
            Re.__version = j.version);
            let En = Re.currentProgram;
            Je === !0 && (En = Dl(j, k, U));
            let As = !1
              , Tn = !1
              , Yo = !1;
            const _t = En.getUniforms()
              , In = Re.uniforms;
            if (Se.useProgram(En.program) && (As = !0,
            Tn = !0,
            Yo = !0),
            j.id !== M && (M = j.id,
            Tn = !0),
            As || b !== E) {
                Se.buffers.depth.getReversed() && E.reversedDepth !== !0 && (E._reversedDepth = !0,
                E.updateProjectionMatrix()),
                _t.setValue(N, "projectionMatrix", E.projectionMatrix),
                _t.setValue(N, "viewMatrix", E.matrixWorldInverse);
                const hn = _t.map.cameraPosition;
                hn !== void 0 && hn.setValue(N, ge.setFromMatrixPosition(E.matrixWorld)),
                Le.logarithmicDepthBuffer && _t.setValue(N, "logDepthBufFC", 2 / (Math.log(E.far + 1) / Math.LN2)),
                (j.isMeshPhongMaterial || j.isMeshToonMaterial || j.isMeshLambertMaterial || j.isMeshBasicMaterial || j.isMeshStandardMaterial || j.isShaderMaterial) && _t.setValue(N, "isOrthographic", E.isOrthographicCamera === !0),
                b !== E && (b = E,
                Tn = !0,
                Yo = !0)
            }
            if (U.isSkinnedMesh) {
                _t.setOptional(N, U, "bindMatrix"),
                _t.setOptional(N, U, "bindMatrixInverse");
                const rn = U.skeleton;
                rn && (rn.boneTexture === null && rn.computeBoneTexture(),
                _t.setValue(N, "boneTexture", rn.boneTexture, Ve))
            }
            U.isBatchedMesh && (_t.setOptional(N, U, "batchingTexture"),
            _t.setValue(N, "batchingTexture", U._matricesTexture, Ve),
            _t.setOptional(N, U, "batchingIdTexture"),
            _t.setValue(N, "batchingIdTexture", U._indirectTexture, Ve),
            _t.setOptional(N, U, "batchingColorTexture"),
            U._colorsTexture !== null && _t.setValue(N, "batchingColorTexture", U._colorsTexture, Ve));
            const kn = V.morphAttributes;
            if ((kn.position !== void 0 || kn.normal !== void 0 || kn.color !== void 0) && re.update(U, V, En),
            (Tn || Re.receiveShadow !== U.receiveShadow) && (Re.receiveShadow = U.receiveShadow,
            _t.setValue(N, "receiveShadow", U.receiveShadow)),
            j.isMeshGouraudMaterial && j.envMap !== null && (In.envMap.value = me,
            In.flipEnvMap.value = me.isCubeTexture && me.isRenderTargetTexture === !1 ? -1 : 1),
            j.isMeshStandardMaterial && j.envMap === null && k.environment !== null && (In.envMapIntensity.value = k.environmentIntensity),
            Tn && (_t.setValue(N, "toneMappingExposure", S.toneMappingExposure),
            Re.needsLights && EE(In, Yo),
            ie && j.fog === !0 && ee.refreshFogUniforms(In, ie),
            ee.refreshMaterialUniforms(In, j, D, B, f.state.transmissionRenderTarget[E.id]),
            Yc.upload(N, Hg(Re), In, Ve)),
            j.isShaderMaterial && j.uniformsNeedUpdate === !0 && (Yc.upload(N, Hg(Re), In, Ve),
            j.uniformsNeedUpdate = !1),
            j.isSpriteMaterial && _t.setValue(N, "center", U.center),
            _t.setValue(N, "modelViewMatrix", U.modelViewMatrix),
            _t.setValue(N, "normalMatrix", U.normalMatrix),
            _t.setValue(N, "modelMatrix", U.matrixWorld),
            j.isShaderMaterial || j.isRawShaderMaterial) {
                const rn = j.uniformsGroups;
                for (let hn = 0, ld = rn.length; hn < ld; hn++) {
                    const Vr = rn[hn];
                    Be.update(Vr, En),
                    Be.bind(Vr, En)
                }
            }
            return En
        }
        function EE(E, k) {
            E.ambientLightColor.needsUpdate = k,
            E.lightProbe.needsUpdate = k,
            E.directionalLights.needsUpdate = k,
            E.directionalLightShadows.needsUpdate = k,
            E.pointLights.needsUpdate = k,
            E.pointLightShadows.needsUpdate = k,
            E.spotLights.needsUpdate = k,
            E.spotLightShadows.needsUpdate = k,
            E.rectAreaLights.needsUpdate = k,
            E.hemisphereLights.needsUpdate = k
        }
        function TE(E) {
            return E.isMeshLambertMaterial || E.isMeshToonMaterial || E.isMeshPhongMaterial || E.isMeshStandardMaterial || E.isShadowMaterial || E.isShaderMaterial && E.lights === !0
        }
        this.getActiveCubeFace = function() {
            return A
        }
        ,
        this.getActiveMipmapLevel = function() {
            return C
        }
        ,
        this.getRenderTarget = function() {
            return P
        }
        ,
        this.setRenderTargetTextures = function(E, k, V) {
            const j = we.get(E);
            j.__autoAllocateDepthBuffer = E.resolveDepthBuffer === !1,
            j.__autoAllocateDepthBuffer === !1 && (j.__useRenderToTexture = !1),
            we.get(E.texture).__webglTexture = k,
            we.get(E.depthTexture).__webglTexture = j.__autoAllocateDepthBuffer ? void 0 : V,
            j.__hasExternalTextures = !0
        }
        ,
        this.setRenderTargetFramebuffer = function(E, k) {
            const V = we.get(E);
            V.__webglFramebuffer = k,
            V.__useDefaultFramebuffer = k === void 0
        }
        ;
        const ME = N.createFramebuffer();
        this.setRenderTarget = function(E, k=0, V=0) {
            P = E,
            A = k,
            C = V;
            let j = !0
              , U = null
              , ie = !1
              , he = !1;
            if (E) {
                const me = we.get(E);
                if (me.__useDefaultFramebuffer !== void 0)
                    Se.bindFramebuffer(N.FRAMEBUFFER, null),
                    j = !1;
                else if (me.__webglFramebuffer === void 0)
                    Ve.setupRenderTarget(E);
                else if (me.__hasExternalTextures)
                    Ve.rebindTextures(E, we.get(E.texture).__webglTexture, we.get(E.depthTexture).__webglTexture);
                else if (E.depthBuffer) {
                    const Ce = E.depthTexture;
                    if (me.__boundDepthTexture !== Ce) {
                        if (Ce !== null && we.has(Ce) && (E.width !== Ce.image.width || E.height !== Ce.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        Ve.setupDepthRenderbuffer(E)
                    }
                }
                const Pe = E.texture;
                (Pe.isData3DTexture || Pe.isDataArrayTexture || Pe.isCompressedArrayTexture) && (he = !0);
                const Ie = we.get(E).__webglFramebuffer;
                E.isWebGLCubeRenderTarget ? (Array.isArray(Ie[k]) ? U = Ie[k][V] : U = Ie[k],
                ie = !0) : E.samples > 0 && Ve.useMultisampledRTT(E) === !1 ? U = we.get(E).__webglMultisampledFramebuffer : Array.isArray(Ie) ? U = Ie[V] : U = Ie,
                L.copy(E.viewport),
                F.copy(E.scissor),
                H = E.scissorTest
            } else
                L.copy(le).multiplyScalar(D).floor(),
                F.copy(xe).multiplyScalar(D).floor(),
                H = qe;
            if (V !== 0 && (U = ME),
            Se.bindFramebuffer(N.FRAMEBUFFER, U) && j && Se.drawBuffers(E, U),
            Se.viewport(L),
            Se.scissor(F),
            Se.setScissorTest(H),
            ie) {
                const me = we.get(E.texture);
                N.framebufferTexture2D(N.FRAMEBUFFER, N.COLOR_ATTACHMENT0, N.TEXTURE_CUBE_MAP_POSITIVE_X + k, me.__webglTexture, V)
            } else if (he) {
                const me = k;
                for (let Pe = 0; Pe < E.textures.length; Pe++) {
                    const Ie = we.get(E.textures[Pe]);
                    N.framebufferTextureLayer(N.FRAMEBUFFER, N.COLOR_ATTACHMENT0 + Pe, Ie.__webglTexture, V, me)
                }
            } else if (E !== null && V !== 0) {
                const me = we.get(E.texture);
                N.framebufferTexture2D(N.FRAMEBUFFER, N.COLOR_ATTACHMENT0, N.TEXTURE_2D, me.__webglTexture, V)
            }
            M = -1
        }
        ,
        this.readRenderTargetPixels = function(E, k, V, j, U, ie, he, _e=0) {
            if (!(E && E.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let me = we.get(E).__webglFramebuffer;
            if (E.isWebGLCubeRenderTarget && he !== void 0 && (me = me[he]),
            me) {
                Se.bindFramebuffer(N.FRAMEBUFFER, me);
                try {
                    const Pe = E.textures[_e]
                      , Ie = Pe.format
                      , Ce = Pe.type;
                    if (!Le.textureFormatReadable(Ie)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!Le.textureTypeReadable(Ce)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    k >= 0 && k <= E.width - j && V >= 0 && V <= E.height - U && (E.textures.length > 1 && N.readBuffer(N.COLOR_ATTACHMENT0 + _e),
                    N.readPixels(k, V, j, U, Te.convert(Ie), Te.convert(Ce), ie))
                } finally {
                    const Pe = P !== null ? we.get(P).__webglFramebuffer : null;
                    Se.bindFramebuffer(N.FRAMEBUFFER, Pe)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(E, k, V, j, U, ie, he, _e=0) {
            if (!(E && E.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let me = we.get(E).__webglFramebuffer;
            if (E.isWebGLCubeRenderTarget && he !== void 0 && (me = me[he]),
            me)
                if (k >= 0 && k <= E.width - j && V >= 0 && V <= E.height - U) {
                    Se.bindFramebuffer(N.FRAMEBUFFER, me);
                    const Pe = E.textures[_e]
                      , Ie = Pe.format
                      , Ce = Pe.type;
                    if (!Le.textureFormatReadable(Ie))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!Le.textureTypeReadable(Ce))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const $e = N.createBuffer();
                    N.bindBuffer(N.PIXEL_PACK_BUFFER, $e),
                    N.bufferData(N.PIXEL_PACK_BUFFER, ie.byteLength, N.STREAM_READ),
                    E.textures.length > 1 && N.readBuffer(N.COLOR_ATTACHMENT0 + _e),
                    N.readPixels(k, V, j, U, Te.convert(Ie), Te.convert(Ce), 0);
                    const it = P !== null ? we.get(P).__webglFramebuffer : null;
                    Se.bindFramebuffer(N.FRAMEBUFFER, it);
                    const bt = N.fenceSync(N.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return N.flush(),
                    await tL(N, bt, 4),
                    N.bindBuffer(N.PIXEL_PACK_BUFFER, $e),
                    N.getBufferSubData(N.PIXEL_PACK_BUFFER, 0, ie),
                    N.deleteBuffer($e),
                    N.deleteSync(bt),
                    ie
                } else
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
        }
        ,
        this.copyFramebufferToTexture = function(E, k=null, V=0) {
            const j = Math.pow(2, -V)
              , U = Math.floor(E.image.width * j)
              , ie = Math.floor(E.image.height * j)
              , he = k !== null ? k.x : 0
              , _e = k !== null ? k.y : 0;
            Ve.setTexture2D(E, 0),
            N.copyTexSubImage2D(N.TEXTURE_2D, V, 0, 0, he, _e, U, ie),
            Se.unbindTexture()
        }
        ;
        const AE = N.createFramebuffer()
          , CE = N.createFramebuffer();
        this.copyTextureToTexture = function(E, k, V=null, j=null, U=0, ie=null) {
            ie === null && (U !== 0 ? (dl("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
            ie = U,
            U = 0) : ie = 0);
            let he, _e, me, Pe, Ie, Ce, $e, it, bt;
            const ut = E.isCompressedTexture ? E.mipmaps[ie] : E.image;
            if (V !== null)
                he = V.max.x - V.min.x,
                _e = V.max.y - V.min.y,
                me = V.isBox3 ? V.max.z - V.min.z : 1,
                Pe = V.min.x,
                Ie = V.min.y,
                Ce = V.isBox3 ? V.min.z : 0;
            else {
                const kn = Math.pow(2, -U);
                he = Math.floor(ut.width * kn),
                _e = Math.floor(ut.height * kn),
                E.isDataArrayTexture ? me = ut.depth : E.isData3DTexture ? me = Math.floor(ut.depth * kn) : me = 1,
                Pe = 0,
                Ie = 0,
                Ce = 0
            }
            j !== null ? ($e = j.x,
            it = j.y,
            bt = j.z) : ($e = 0,
            it = 0,
            bt = 0);
            const ot = Te.convert(k.format)
              , Re = Te.convert(k.type);
            let vt;
            k.isData3DTexture ? (Ve.setTexture3D(k, 0),
            vt = N.TEXTURE_3D) : k.isDataArrayTexture || k.isCompressedArrayTexture ? (Ve.setTexture2DArray(k, 0),
            vt = N.TEXTURE_2D_ARRAY) : (Ve.setTexture2D(k, 0),
            vt = N.TEXTURE_2D),
            N.pixelStorei(N.UNPACK_FLIP_Y_WEBGL, k.flipY),
            N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
            N.pixelStorei(N.UNPACK_ALIGNMENT, k.unpackAlignment);
            const Je = N.getParameter(N.UNPACK_ROW_LENGTH)
              , En = N.getParameter(N.UNPACK_IMAGE_HEIGHT)
              , As = N.getParameter(N.UNPACK_SKIP_PIXELS)
              , Tn = N.getParameter(N.UNPACK_SKIP_ROWS)
              , Yo = N.getParameter(N.UNPACK_SKIP_IMAGES);
            N.pixelStorei(N.UNPACK_ROW_LENGTH, ut.width),
            N.pixelStorei(N.UNPACK_IMAGE_HEIGHT, ut.height),
            N.pixelStorei(N.UNPACK_SKIP_PIXELS, Pe),
            N.pixelStorei(N.UNPACK_SKIP_ROWS, Ie),
            N.pixelStorei(N.UNPACK_SKIP_IMAGES, Ce);
            const _t = E.isDataArrayTexture || E.isData3DTexture
              , In = k.isDataArrayTexture || k.isData3DTexture;
            if (E.isDepthTexture) {
                const kn = we.get(E)
                  , rn = we.get(k)
                  , hn = we.get(kn.__renderTarget)
                  , ld = we.get(rn.__renderTarget);
                Se.bindFramebuffer(N.READ_FRAMEBUFFER, hn.__webglFramebuffer),
                Se.bindFramebuffer(N.DRAW_FRAMEBUFFER, ld.__webglFramebuffer);
                for (let Vr = 0; Vr < me; Vr++)
                    _t && (N.framebufferTextureLayer(N.READ_FRAMEBUFFER, N.COLOR_ATTACHMENT0, we.get(E).__webglTexture, U, Ce + Vr),
                    N.framebufferTextureLayer(N.DRAW_FRAMEBUFFER, N.COLOR_ATTACHMENT0, we.get(k).__webglTexture, ie, bt + Vr)),
                    N.blitFramebuffer(Pe, Ie, he, _e, $e, it, he, _e, N.DEPTH_BUFFER_BIT, N.NEAREST);
                Se.bindFramebuffer(N.READ_FRAMEBUFFER, null),
                Se.bindFramebuffer(N.DRAW_FRAMEBUFFER, null)
            } else if (U !== 0 || E.isRenderTargetTexture || we.has(E)) {
                const kn = we.get(E)
                  , rn = we.get(k);
                Se.bindFramebuffer(N.READ_FRAMEBUFFER, AE),
                Se.bindFramebuffer(N.DRAW_FRAMEBUFFER, CE);
                for (let hn = 0; hn < me; hn++)
                    _t ? N.framebufferTextureLayer(N.READ_FRAMEBUFFER, N.COLOR_ATTACHMENT0, kn.__webglTexture, U, Ce + hn) : N.framebufferTexture2D(N.READ_FRAMEBUFFER, N.COLOR_ATTACHMENT0, N.TEXTURE_2D, kn.__webglTexture, U),
                    In ? N.framebufferTextureLayer(N.DRAW_FRAMEBUFFER, N.COLOR_ATTACHMENT0, rn.__webglTexture, ie, bt + hn) : N.framebufferTexture2D(N.DRAW_FRAMEBUFFER, N.COLOR_ATTACHMENT0, N.TEXTURE_2D, rn.__webglTexture, ie),
                    U !== 0 ? N.blitFramebuffer(Pe, Ie, he, _e, $e, it, he, _e, N.COLOR_BUFFER_BIT, N.NEAREST) : In ? N.copyTexSubImage3D(vt, ie, $e, it, bt + hn, Pe, Ie, he, _e) : N.copyTexSubImage2D(vt, ie, $e, it, Pe, Ie, he, _e);
                Se.bindFramebuffer(N.READ_FRAMEBUFFER, null),
                Se.bindFramebuffer(N.DRAW_FRAMEBUFFER, null)
            } else
                In ? E.isDataTexture || E.isData3DTexture ? N.texSubImage3D(vt, ie, $e, it, bt, he, _e, me, ot, Re, ut.data) : k.isCompressedArrayTexture ? N.compressedTexSubImage3D(vt, ie, $e, it, bt, he, _e, me, ot, ut.data) : N.texSubImage3D(vt, ie, $e, it, bt, he, _e, me, ot, Re, ut) : E.isDataTexture ? N.texSubImage2D(N.TEXTURE_2D, ie, $e, it, he, _e, ot, Re, ut.data) : E.isCompressedTexture ? N.compressedTexSubImage2D(N.TEXTURE_2D, ie, $e, it, ut.width, ut.height, ot, ut.data) : N.texSubImage2D(N.TEXTURE_2D, ie, $e, it, he, _e, ot, Re, ut);
            N.pixelStorei(N.UNPACK_ROW_LENGTH, Je),
            N.pixelStorei(N.UNPACK_IMAGE_HEIGHT, En),
            N.pixelStorei(N.UNPACK_SKIP_PIXELS, As),
            N.pixelStorei(N.UNPACK_SKIP_ROWS, Tn),
            N.pixelStorei(N.UNPACK_SKIP_IMAGES, Yo),
            ie === 0 && k.generateMipmaps && N.generateMipmap(vt),
            Se.unbindTexture()
        }
        ,
        this.initRenderTarget = function(E) {
            we.get(E).__webglFramebuffer === void 0 && Ve.setupRenderTarget(E)
        }
        ,
        this.initTexture = function(E) {
            E.isCubeTexture ? Ve.setTextureCube(E, 0) : E.isData3DTexture ? Ve.setTexture3D(E, 0) : E.isDataArrayTexture || E.isCompressedArrayTexture ? Ve.setTexture2DArray(E, 0) : Ve.setTexture2D(E, 0),
            Se.unbindTexture()
        }
        ,
        this.resetState = function() {
            A = 0,
            C = 0,
            P = null,
            Se.reset(),
            de.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return yi
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const n = this.getContext();
        n.drawingBufferColorSpace = Qe._getDrawingBufferColorSpace(e),
        n.unpackColorSpace = Qe._getUnpackColorSpace()
    }
}
function yO({settings: t}) {
    const e = oe.useRef(null);
    return oe.useEffect( () => {
        if (!e.current)
            return;
        const n = new ML
          , i = new jn(60,window.innerWidth / window.innerHeight,1,1e3);
        i.position.set(0, 4, 21);
        const r = new _O({
            alpha: !0,
            antialias: !0
        });
        r.setSize(window.innerWidth, window.innerHeight),
        r.setClearColor(0, 0),
        e.current.appendChild(r.domElement);
        const s = {
            time: {
                value: 0
            }
        }
          , o = []
          , a = []
          , l = () => {
            a.push(Math.random() * Math.PI, Math.random() * Math.PI * 2, (Math.random() * .9 + .1) * Math.PI * .1, Math.random() * .9 + .1)
        }
          , c = [];
        for (let S = 0; S < 5e4; S++)
            o.push(Math.random() * 1.5 + .5),
            l(),
            c.push(new z().randomDirection().multiplyScalar(Math.random() * .5 + 9.5));
        for (let S = 0; S < 1e5; S++) {
            const C = Math.pow(Math.random(), 1.5)
              , P = Math.sqrt(40 * 40 * C + (1 - C) * 10 * 10);
            c.push(new z().setFromCylindricalCoords(P, Math.random() * 2 * Math.PI, (Math.random() - .5) * 2)),
            o.push(Math.random() * 1.5 + .5),
            l()
        }
        const u = new Qi().setFromPoints(c);
        u.setAttribute("sizes", new Hi(o,1)),
        u.setAttribute("shift", new Hi(a,4));
        const d = new mE({
            size: .125,
            transparent: !0,
            depthTest: !1,
            blending: cp,
            onBeforeCompile: S => {
                S.uniforms.time = s.time,
                S.uniforms.userColor = {
                    value: new tt(t.color)
                },
                S.uniforms.userBrightness = {
                    value: t.brightness / 100
                },
                S.uniforms.userSize = {
                    value: t.size / 50
                },
                S.uniforms.userBlur = {
                    value: t.blur / 100
                },
                S.vertexShader = `
          uniform float time;
          uniform float userSize;
          attribute float sizes;
          attribute vec4 shift;
          varying vec3 vColor;
          ${S.vertexShader}
        `.replace("gl_PointSize = size;", "gl_PointSize = size * sizes * userSize;").replace("#include <color_vertex>", `#include <color_vertex>
            float d = length(abs(position) / vec3(40., 10., 40));
            d = clamp(d, 0., 1.);
            vColor = mix(vec3(227., 155., 0.), vec3(100., 50., 255.), d) / 255.;
          `).replace("#include <begin_vertex>", `#include <begin_vertex>
            float t = time;
            float moveT = mod(shift.x + shift.z * t, 6.28318530718);
            float moveS = mod(shift.y + shift.z * t, 6.28318530718);
            transformed += vec3(cos(moveS) * sin(moveT), cos(moveT), sin(moveS) * sin(moveT)) * shift.w;
          `),
                S.fragmentShader = `
          uniform vec3 userColor;
          uniform float userBrightness;
          uniform float userBlur;
          varying vec3 vColor;
          ${S.fragmentShader}
        `.replace("vec4 diffuseColor = vec4( diffuse, opacity );", `float d = length(gl_PointCoord.xy - 0.5);
          vec4 diffuseColor = vec4( vColor * userColor, smoothstep(0.5, 0.1 * userBlur, d) * userBrightness );`)
            }
        })
          , h = new PL(u,d);
        h.rotation.order = "ZYX",
        h.rotation.z = .2,
        n.add(h);
        const p = new kL;
        let v = 0
          , x = 0;
        const g = S => {
            v = S.clientX / window.innerWidth * 2 - 1,
            x = -(S.clientY / window.innerHeight) * 2 + 1
        }
          , f = S => {
            if (S.touches.length > 0) {
                const T = S.touches[0];
                v = T.clientX / window.innerWidth * 2 - 1,
                x = -(T.clientY / window.innerHeight) * 2 + 1
            }
        }
        ;
        window.addEventListener("mousemove", g),
        window.addEventListener("touchmove", f, {
            passive: !0
        });
        const y = () => {
            requestAnimationFrame(y);
            const S = p.getElapsedTime() * .5 * (t.speed / 50);
            if (s.time.value = S * Math.PI,
            h.rotation.y = S * .05,
            t.clickReactive) {
                h.rotation.x += x * .001,
                h.rotation.z += v * .001;
                const T = 21 * (100 / t.zoom);
                i.position.z += (T - i.position.z) * .05
            } else
                i.position.z += (21 - i.position.z) * .05;
            r.render(n, i)
        }
        ;
        y();
        const _ = () => {
            i.aspect = window.innerWidth / window.innerHeight,
            i.updateProjectionMatrix(),
            r.setSize(window.innerWidth, window.innerHeight)
        }
        ;
        return window.addEventListener("resize", _),
        () => {
            window.removeEventListener("mousemove", g),
            window.removeEventListener("touchmove", f),
            window.removeEventListener("resize", _),
            e.current && r.domElement.parentNode === e.current && e.current.removeChild(r.domElement),
            u.dispose(),
            d.dispose()
        }
    }
    , [t]),
    m.jsx("div", {
        ref: e,
        className: "fixed inset-0 pointer-events-none",
        style: {
            zIndex: 2
        }
    })
}
function xO() {
    return m.jsx("div", {
        className: "gradient-bg absolute top-0 left-0 w-full pointer-events-none",
        style: {
            background: "linear-gradient(180deg, #ffffff 0%, #434343 33%, #012445 66%, #b2b2b2 100%)",
            height: "100%",
            minHeight: "100vh",
            zIndex: 1
        }
    })
}
function SO() {
    const [t,e] = oe.useState(!1)
      , [n,i] = oe.useState(!1)
      , [r,s] = oe.useState(!1)
      , [o,a] = oe.useState({
        enabled: !1,
        particleSize: 2,
        speed: 1.5,
        opacity: 1,
        brightness: 70,
        hueShift: 180
    })
      , [l,c] = oe.useState(Wc)
      , [u,d] = oe.useState(1)
      , [h,p] = oe.useState(1)
      , [v,x] = oe.useState(1)
      , [g,f] = oe.useState(1)
      , [y,_] = oe.useState(.8)
      , [S,T] = oe.useState(0)
      , [A,C] = oe.useState(0)
      , [P,M] = oe.useState(0)
      , b = oe.useRef(null)
      , L = oe.useRef(null)
      , F = oe.useRef(null)
      , H = oe.useRef(null)
      , Z = oe.useRef(null)
      , $ = oe.useRef(null)
      , q = () => {
        $.current || ($.current = new Audio("/submarine-sonar-ping.mp3"),
        $.current.volume = .5),
        $.current.currentTime = 0,
        $.current.play().catch(B => console.log("Audio play failed:", B))
    }
    ;
    return oe.useEffect( () => {
        const B = () => {
            const D = window.scrollY;
            T(D * -.15),
            C(D * -.4),
            M(D * -.1),
            [{
                ref: b,
                setter: d
            }, {
                ref: L,
                setter: p
            }, {
                ref: F,
                setter: x
            }, {
                ref: H,
                setter: f
            }, {
                ref: Z,
                setter: _
            }].forEach( ({ref: Y, setter: le}) => {
                if (!Y.current)
                    return;
                const xe = Y.current.getBoundingClientRect()
                  , qe = window.innerHeight
                  , Ke = xe.top + xe.height / 2
                  , We = qe / 2
                  , ge = 1.2 - Math.abs(Ke - We) / qe * .4;
                le(Math.max(.8, Math.min(1.2, ge)))
            }
            )
        }
        ;
        return window.addEventListener("scroll", B),
        B(),
        () => window.removeEventListener("scroll", B)
    }
    , []),
    m.jsxs("div", {
        className: "min-h-screen text-white relative",
        style: {
            backgroundColor: "#0a1628"
        },
        children: [m.jsx(lD, {
            settings: o
        }), m.jsx(uD, {
            onSettingsChange: c
        }), m.jsx(cD, {
            onSettingsChange: a
        }), m.jsx(oD, {}), m.jsx(aD, {}), m.jsx(xO, {}), m.jsx(yO, {
            settings: l
        }), m.jsx("header", {
            className: "fixed top-0 w-full bg-white/10 backdrop-blur-2xl border-b border-white/20 z-50",
            style: {
                perspective: "1000px",
                boxShadow: "0 8px 32px rgba(0,0,0,0.1)"
            },
            children: m.jsxs("nav", {
                className: "max-w-7xl mx-auto px-6 py-5 flex items-center justify-between",
                children: [m.jsxs("div", {
                    className: "flex items-start gap-3 group cursor-pointer",
                    onMouseEnter: q,
                    onClick: q,
                    children: [m.jsxs("div", {
                        className: "relative",
                        children: [m.jsx(Rs.div, {
                            className: "absolute inset-0 bg-cyan-400/30 blur-2xl rounded-full",
                            animate: {
                                scale: [1, 1.2, 1],
                                opacity: [.3, .6, .3]
                            },
                            transition: {
                                duration: 3,
                                repeat: 1 / 0,
                                ease: "easeInOut"
                            }
                        }), m.jsx(Rs.img, {
                            src: "/lighthouse-logo-3.png",
                            alt: "Lighthouse AI",
                            className: "w-24 h-24 object-contain relative z-10 drop-shadow-[0_0_15px_rgba(34,211,238,0.6)] group-hover:drop-shadow-[0_0_25px_rgba(34,211,238,1)] transition-all duration-500",
                            whileHover: {
                                rotate: [0, -5, 5, -5, 5, 0],
                                scale: 1.1
                            },
                            transition: {
                                duration: .5
                            }
                        })]
                    }), m.jsx("span", {
                        className: "text-2xl font-bold bg-gradient-to-r from-cyan-400 via-blue-400 to-teal-400 bg-clip-text text-transparent mt-7",
                        children: "Lighthouse AI"
                    })]
                }), m.jsxs("div", {
                    className: "flex items-center gap-8",
                    children: [m.jsxs("div", {
                        className: "hidden md:flex items-center gap-8",
                        children: [m.jsxs("a", {
                            href: "#services",
                            className: "text-gray-300 hover:text-white transition-colors relative group",
                            children: ["Services", m.jsx("span", {
                                className: "absolute -bottom-1 left-0 w-0 h-0.5 bg-gradient-to-r from-cyan-400 to-blue-500 group-hover:w-full transition-all duration-300"
                            })]
                        }), m.jsxs("a", {
                            href: "#capabilities",
                            className: "text-gray-300 hover:text-white transition-colors relative group",
                            children: ["Capabilities", m.jsx("span", {
                                className: "absolute -bottom-1 left-0 w-0 h-0.5 bg-gradient-to-r from-cyan-400 to-blue-500 group-hover:w-full transition-all duration-300"
                            })]
                        }), m.jsxs("a", {
                            href: "#portfolio",
                            className: "text-gray-300 hover:text-white transition-colors relative group",
                            children: ["Portfolio", m.jsx("span", {
                                className: "absolute -bottom-1 left-0 w-0 h-0.5 bg-gradient-to-r from-cyan-400 to-blue-500 group-hover:w-full transition-all duration-300"
                            })]
                        }), m.jsxs("a", {
                            href: "#about",
                            className: "text-gray-300 hover:text-white transition-colors relative group",
                            children: ["About", m.jsx("span", {
                                className: "absolute -bottom-1 left-0 w-0 h-0.5 bg-gradient-to-r from-cyan-400 to-blue-500 group-hover:w-full transition-all duration-300"
                            })]
                        }), m.jsxs("button", {
                            onClick: () => e(!0),
                            className: "relative group overflow-hidden bg-gradient-to-r from-cyan-500 to-blue-600 text-white px-6 py-2.5 rounded-lg font-medium card-3d-subtle button-hover-lift",
                            children: [m.jsx("span", {
                                className: "relative z-10",
                                children: "Get Started"
                            }), m.jsx("div", {
                                className: "absolute inset-0 bg-gradient-to-r from-cyan-400 to-blue-500 opacity-0 group-hover:opacity-100 transition-opacity"
                            })]
                        })]
                    }), m.jsx("button", {
                        onClick: () => s(!0),
                        className: "md:hidden text-white hover:text-cyan-400 transition-colors",
                        "aria-label": "Open menu",
                        children: m.jsx("svg", {
                            className: "w-6 h-6",
                            fill: "none",
                            stroke: "currentColor",
                            viewBox: "0 0 24 24",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                strokeWidth: 2,
                                d: "M4 6h16M4 12h16M4 18h16"
                            })
                        })
                    }), m.jsx(sD, {
                        isOpen: r,
                        onClose: () => s(!1),
                        onContactClick: () => e(!0),
                        onBookingClick: () => i(!0)
                    })]
                })]
            })
        }), m.jsx("section", {
            className: "relative pt-56 pb-32 px-6",
            children: m.jsx("div", {
                className: "max-w-7xl mx-auto relative z-10",
                children: m.jsxs("div", {
                    className: "max-w-5xl mx-auto text-center",
                    children: [m.jsxs(Rs.h1, {
                        initial: {
                            opacity: 0,
                            y: 20
                        },
                        animate: {
                            opacity: 1,
                            y: 0
                        },
                        transition: {
                            delay: .2,
                            duration: .8
                        },
                        className: "text-6xl md:text-7xl lg:text-8xl font-black mb-8 leading-tight",
                        children: [m.jsx("span", {
                            className: "bg-gradient-to-r from-slate-900 via-slate-700 to-slate-600 bg-clip-text text-transparent",
                            style: {
                                textShadow: "0 2px 4px rgba(0,0,0,0.3)"
                            },
                            children: "Build, Learn,"
                        }), m.jsx("br", {}), m.jsx("span", {
                            className: "bg-gradient-to-r from-slate-800 via-slate-700 to-slate-600 bg-clip-text text-transparent",
                            style: {
                                textShadow: "0 2px 4px rgba(0,0,0,0.3)"
                            },
                            children: "Transform"
                        })]
                    }), m.jsxs(Rs.p, {
                        initial: {
                            opacity: 0,
                            y: 20
                        },
                        animate: {
                            opacity: 1,
                            y: 0
                        },
                        transition: {
                            delay: .5,
                            duration: .8
                        },
                        className: "text-xl md:text-2xl text-gray-600 mb-12 leading-relaxed max-w-3xl mx-auto",
                        children: ["Expert guidance to help individuals and companies ", m.jsx("span", {
                            className: "text-cyan-600 font-semibold",
                            children: "leverage AI"
                        }), "  without falling behind or feeling overwhelmed. From app development to video to automation, I'll ", m.jsx("span", {
                            className: "text-blue-600 font-semibold",
                            children: "build it"
                        }), " for you or ", m.jsx("span", {
                            className: "text-teal-700 font-semibold",
                            children: "teach you how"
                        }), "."]
                    }), m.jsxs(Rs.div, {
                        initial: {
                            opacity: 0,
                            y: 20
                        },
                        animate: {
                            opacity: 1,
                            y: 0
                        },
                        transition: {
                            delay: .8,
                            duration: .8
                        },
                        className: "flex flex-col sm:flex-row gap-8 justify-center items-center",
                        style: {
                            perspective: "1000px"
                        },
                        children: [m.jsx("button", {
                            onClick: () => e(!0),
                            className: "group relative overflow-hidden bg-white/10 backdrop-blur-md border-2 border-cyan-400/30 text-white font-bold text-base hover:bg-white/20 hover:border-cyan-400 transition-all card-3d button-hover-lift w-56 h-16 flex items-center justify-center",
                            style: {
                                borderRadius: "100px",
                                boxShadow: "0 8px 32px rgba(6, 182, 212, 0.1)"
                            },
                            children: m.jsxs("div", {
                                className: "flex items-center justify-center gap-2 px-5 text-center",
                                children: [m.jsx("span", {
                                    className: "leading-tight",
                                    children: "I'll Build It For You"
                                }), m.jsx(tr, {
                                    className: "w-5 h-5 group-hover:translate-x-2 transition-transform"
                                })]
                            })
                        }), m.jsx("button", {
                            onClick: () => i(!0),
                            className: "group relative overflow-hidden bg-white/10 backdrop-blur-md border-2 border-cyan-400/30 text-white font-bold text-base hover:bg-white/20 hover:border-cyan-400 transition-all card-3d button-hover-lift w-56 h-16 flex items-center justify-center",
                            style: {
                                borderRadius: "100px",
                                boxShadow: "0 8px 32px rgba(6, 182, 212, 0.1)"
                            },
                            children: m.jsxs("div", {
                                className: "flex items-center justify-center gap-2 px-5 text-center",
                                children: [m.jsx("span", {
                                    className: "leading-tight",
                                    children: "I'll Teach You How"
                                }), m.jsx(Zl, {
                                    className: "w-5 h-5 group-hover:rotate-12 transition-transform"
                                })]
                            })
                        })]
                    })]
                })
            })
        }), m.jsx("section", {
            className: "relative py-32 px-6 overflow-hidden",
            children: m.jsx("div", {
                className: "max-w-5xl mx-auto relative z-10",
                children: m.jsx("div", {
                    ref: Z,
                    className: "text-center transition-all duration-300 ease-out px-4",
                    style: {
                        transform: `scale(${y})`,
                        opacity: Math.max(.3, Math.min(1, (y - .7) / .5))
                    },
                    children: m.jsxs("h2", {
                        className: "text-3xl md:text-4xl lg:text-5xl font-black leading-tight",
                        children: [m.jsx("span", {
                            className: "bg-gradient-to-r from-cyan-400 via-blue-500 to-teal-400 bg-clip-text text-transparent",
                            style: {
                                filter: `brightness(${Math.max(.7, Math.min(1.3, y * 1.2))})`
                            },
                            children: "My vision is to bridge creativity and intelligence"
                        }), m.jsx("span", {
                            className: "block mt-4 bg-gradient-to-r from-slate-200 via-slate-300 to-slate-400 bg-clip-text text-transparent",
                            style: {
                                filter: `brightness(${Math.max(.7, Math.min(1.5, y * 1.3))}) contrast(${Math.max(1, Math.min(1.5, y * 1.2))})`
                            },
                            children: " empowering people and brands to harness AI as a tool for imagination, efficiency, and transformation."
                        })]
                    })
                })
            })
        }), m.jsx("section", {
            id: "services",
            className: "relative py-24 px-6",
            children: m.jsxs("div", {
                className: "max-w-7xl mx-auto relative z-10",
                children: [m.jsxs("div", {
                    className: "text-center mb-20",
                    children: [m.jsxs("div", {
                        className: "inline-flex items-center gap-2 bg-cyan-500/20 border border-cyan-400/50 px-4 py-2 rounded-full mb-4",
                        children: [m.jsx(iv, {
                            className: "w-4 h-4 text-cyan-500"
                        }), m.jsx("span", {
                            className: "text-sm font-medium text-cyan-700",
                            children: "Two Paths to Success"
                        })]
                    }), m.jsx("h2", {
                        className: "text-5xl md:text-6xl font-black bg-gradient-to-r from-slate-600 via-slate-500 to-slate-400 bg-clip-text text-transparent mb-5",
                        children: "Choose Your Journey"
                    }), m.jsx("p", {
                        className: "text-xl text-slate-600",
                        children: "The approach that fits your needs"
                    })]
                }), m.jsxs("div", {
                    className: "grid md:grid-cols-2 gap-8 max-w-6xl mx-auto",
                    style: {
                        perspective: "1200px"
                    },
                    children: [m.jsxs("div", {
                        className: "group relative card-3d",
                        children: [m.jsx("div", {
                            className: "absolute inset-0 bg-gradient-to-br from-cyan-500/20 to-blue-600/20 rounded-3xl blur-xl group-hover:blur-2xl transition-all"
                        }), m.jsxs("div", {
                            className: "relative bg-gradient-to-br from-slate-800/40 to-slate-900/40 backdrop-blur-xl rounded-3xl p-10 border border-white/20 group-hover:border-cyan-400/50 transition-all hover:scale-[1.02]",
                            children: [m.jsxs("div", {
                                className: "relative inline-flex mb-8",
                                children: [m.jsx("div", {
                                    className: "absolute inset-0 bg-gradient-to-br from-cyan-400 to-blue-500 rounded-2xl blur-md opacity-50"
                                }), m.jsx("div", {
                                    className: "relative bg-gradient-to-br from-cyan-500 to-blue-600 p-4 rounded-2xl",
                                    children: m.jsx(tv, {
                                        className: "w-8 h-8 text-white",
                                        strokeWidth: 2.5
                                    })
                                })]
                            }), m.jsx("h3", {
                                className: "text-3xl font-black text-white mb-5 bg-gradient-to-r from-cyan-400 to-blue-400 bg-clip-text text-transparent",
                                children: "Hire Me to Build It"
                            }), m.jsx("p", {
                                className: "text-gray-300 mb-8 leading-relaxed text-lg",
                                children: "Get AI-powered solutions crafted for you. Apps, automation, videos, websites  built with deep expertise in traditional media and cutting-edge AI."
                            }), m.jsx("div", {
                                className: "space-y-4 mb-10",
                                children: [{
                                    icon: Yl,
                                    text: "Custom app development"
                                }, {
                                    icon: Od,
                                    text: "AI automation & efficiency solutions"
                                }, {
                                    icon: sa,
                                    text: "Video production & animation"
                                }, {
                                    icon: kd,
                                    text: "Web design & multimedia"
                                }].map( (B, D) => m.jsxs("div", {
                                    className: "flex items-center gap-4 group/item",
                                    children: [m.jsxs("div", {
                                        className: "relative",
                                        children: [m.jsx("div", {
                                            className: "absolute inset-0 bg-cyan-400 rounded-lg blur-sm opacity-0 group-hover/item:opacity-50 transition-opacity"
                                        }), m.jsx("div", {
                                            className: "relative bg-white/5 p-2 rounded-lg border border-white/10 group-hover/item:border-cyan-400/50 transition-colors",
                                            children: m.jsx(B.icon, {
                                                className: "w-5 h-5 text-cyan-400"
                                            })
                                        })]
                                    }), m.jsx("span", {
                                        className: "text-gray-200 font-medium",
                                        children: B.text
                                    })]
                                }, D))
                            }), m.jsx("div", {
                                className: "flex justify-center",
                                children: m.jsxs("button", {
                                    onClick: () => e(!0),
                                    className: "relative overflow-hidden bg-gradient-to-r from-cyan-500 to-blue-600 text-white font-bold text-base shadow-lg shadow-cyan-500/30 hover:shadow-xl hover:shadow-cyan-500/50 transition-all group/btn button-hover-lift w-56 h-16 flex items-center justify-center",
                                    style: {
                                        borderRadius: "100px"
                                    },
                                    children: [m.jsxs("div", {
                                        className: "flex items-center justify-center gap-2 px-6 text-center",
                                        children: [m.jsx("span", {
                                            className: "relative z-10 leading-tight",
                                            children: "Start Your Project"
                                        }), m.jsx(nv, {
                                            className: "w-5 h-5 group-hover/btn:translate-y-[-2px] transition-transform relative z-10"
                                        })]
                                    }), m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-r from-cyan-400 to-blue-500 opacity-0 group-hover/btn:opacity-100 transition-opacity"
                                    })]
                                })
                            })]
                        })]
                    }), m.jsxs("div", {
                        className: "group relative card-3d",
                        children: [m.jsx("div", {
                            className: "absolute inset-0 bg-gradient-to-br from-teal-500/20 to-emerald-600/20 rounded-3xl blur-xl group-hover:blur-2xl transition-all"
                        }), m.jsxs("div", {
                            className: "relative bg-gradient-to-br from-slate-800/40 to-slate-900/40 backdrop-blur-xl rounded-3xl p-10 border border-white/20 group-hover:border-teal-400/50 transition-all hover:scale-[1.02]",
                            children: [m.jsxs("div", {
                                className: "relative inline-flex mb-8",
                                children: [m.jsx("div", {
                                    className: "absolute inset-0 bg-gradient-to-br from-teal-400 to-emerald-500 rounded-2xl blur-md opacity-50"
                                }), m.jsx("div", {
                                    className: "relative bg-gradient-to-br from-teal-500 to-emerald-600 p-4 rounded-2xl",
                                    children: m.jsx(Zl, {
                                        className: "w-8 h-8 text-white",
                                        strokeWidth: 2.5
                                    })
                                })]
                            }), m.jsx("h3", {
                                className: "text-3xl font-black text-white mb-5 bg-gradient-to-r from-teal-400 to-emerald-400 bg-clip-text text-transparent",
                                children: "Learn From Me"
                            }), m.jsx("p", {
                                className: "text-gray-300 mb-8 leading-relaxed text-lg",
                                children: "Master AI tools and techniques through personalized training. For companies, teams, individuals, or youth  tailored to your skill level and goals."
                            }), m.jsx("div", {
                                className: "space-y-4 mb-10",
                                children: [{
                                    icon: l1,
                                    text: "Corporate AI training & workshops"
                                }, {
                                    icon: Ud,
                                    text: "1-on-1 coaching & mentorship"
                                }, {
                                    icon: Su,
                                    text: "Youth education in app building & animation"
                                }, {
                                    icon: ev,
                                    text: "Team upskilling programs"
                                }].map( (B, D) => m.jsxs("div", {
                                    className: "flex items-center gap-4 group/item",
                                    children: [m.jsxs("div", {
                                        className: "relative",
                                        children: [m.jsx("div", {
                                            className: "absolute inset-0 bg-teal-400 rounded-lg blur-sm opacity-0 group-hover/item:opacity-50 transition-opacity"
                                        }), m.jsx("div", {
                                            className: "relative bg-white/5 p-2 rounded-lg border border-white/10 group-hover/item:border-teal-400/50 transition-colors",
                                            children: m.jsx(B.icon, {
                                                className: "w-5 h-5 text-teal-400"
                                            })
                                        })]
                                    }), m.jsx("span", {
                                        className: "text-gray-200 font-medium",
                                        children: B.text
                                    })]
                                }, D))
                            }), m.jsx("div", {
                                className: "flex justify-center",
                                children: m.jsxs("button", {
                                    onClick: () => i(!0),
                                    className: "relative overflow-hidden bg-gradient-to-r from-teal-500 to-emerald-600 text-white font-bold text-base shadow-lg shadow-teal-500/30 hover:shadow-xl hover:shadow-teal-500/50 transition-all group/btn button-hover-lift w-56 h-16 flex items-center justify-center",
                                    style: {
                                        borderRadius: "100px"
                                    },
                                    children: [m.jsxs("div", {
                                        className: "flex items-center justify-center gap-2 px-6 text-center",
                                        children: [m.jsx("span", {
                                            className: "relative z-10 leading-tight",
                                            children: "Book a Session"
                                        }), m.jsx(Zl, {
                                            className: "w-5 h-5 group-hover/btn:rotate-12 transition-transform relative z-10"
                                        })]
                                    }), m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-r from-teal-400 to-emerald-500 opacity-0 group-hover/btn:opacity-100 transition-opacity"
                                    })]
                                })
                            })]
                        })]
                    })]
                })]
            })
        }), m.jsx("section", {
            id: "capabilities",
            className: "relative py-24 px-6 overflow-visible",
            children: m.jsxs("div", {
                className: "max-w-7xl mx-auto relative z-10",
                children: [m.jsxs("div", {
                    className: "text-center mb-20 overflow-visible",
                    children: [m.jsxs("div", {
                        className: "inline-flex items-center gap-2 bg-blue-500/10 border border-blue-400/30 px-4 py-2 rounded-full mb-4",
                        children: [m.jsx(Od, {
                            className: "w-4 h-4 text-blue-400"
                        }), m.jsx("span", {
                            className: "text-sm font-medium text-blue-300",
                            children: "Full Stack Expertise"
                        })]
                    }), m.jsx("h2", {
                        className: "text-5xl md:text-6xl font-black bg-gradient-to-r from-white to-gray-300 bg-clip-text text-transparent mb-5 pb-2",
                        children: "Wide-Ranging Capabilities"
                    }), m.jsx("p", {
                        className: "text-xl text-gray-300",
                        children: "Traditional expertise meets AI innovation"
                    })]
                }), m.jsx("div", {
                    className: "grid md:grid-cols-2 lg:grid-cols-4 gap-6",
                    style: {
                        perspective: "1200px"
                    },
                    children: [{
                        icon: Yl,
                        title: "App Development",
                        desc: "Custom web & mobile applications with AI integration",
                        gradient: "from-cyan-500 to-blue-600"
                    }, {
                        icon: s1,
                        title: "AI Automation",
                        desc: "Streamline workflows & reduce overhead w/ intelligent automation",
                        gradient: "from-blue-500 to-violet-600"
                    }, {
                        icon: sa,
                        title: "Video Production",
                        desc: "Shooting, editing, sound design, and AI-enhanced video content",
                        gradient: "from-violet-500 to-purple-600"
                    }, {
                        icon: kd,
                        title: "Animation & Design",
                        desc: "Adobe Creative Suite mastery, 3D design, and motion graphics",
                        gradient: "from-purple-500 to-pink-600"
                    }].map( (B, D) => m.jsxs("div", {
                        className: "group relative card-3d",
                        children: [m.jsx("div", {
                            className: `absolute inset-0 bg-gradient-to-br ${B.gradient} opacity-0 group-hover:opacity-20 rounded-2xl blur-xl transition-all`
                        }), m.jsxs("div", {
                            className: "relative bg-white/5 backdrop-blur-sm rounded-2xl p-8 border border-white/10 group-hover:border-white/30 transition-all",
                            children: [m.jsxs("div", {
                                className: "relative inline-flex mb-6",
                                children: [m.jsx("div", {
                                    className: `absolute inset-0 bg-gradient-to-br ${B.gradient} rounded-xl blur-md opacity-50`
                                }), m.jsx("div", {
                                    className: `relative bg-gradient-to-br ${B.gradient} p-3 rounded-xl`,
                                    children: m.jsx(B.icon, {
                                        className: "w-7 h-7 text-white",
                                        strokeWidth: 2.5
                                    })
                                })]
                            }), m.jsx("h3", {
                                className: "text-xl font-bold text-white mb-3",
                                children: B.title
                            }), m.jsx("p", {
                                className: "text-gray-300 text-sm leading-relaxed",
                                children: B.desc
                            })]
                        })]
                    }, D))
                })]
            })
        }), m.jsx("section", {
            id: "portfolio",
            className: "relative py-32 px-6 bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950",
            children: m.jsxs("div", {
                className: "max-w-7xl mx-auto relative z-10",
                children: [m.jsxs("div", {
                    className: "text-center mb-24",
                    children: [m.jsxs("div", {
                        className: "inline-flex items-center gap-2 bg-gradient-to-r from-purple-500/10 to-violet-500/10 border border-purple-400/30 px-5 py-2.5 rounded-full mb-6",
                        children: [m.jsx(ev, {
                            className: "w-5 h-5 text-purple-400"
                        }), m.jsx("span", {
                            className: "text-sm font-semibold text-purple-300",
                            children: "Featured Work"
                        })]
                    }), m.jsx("h2", {
                        className: "text-6xl md:text-7xl font-black bg-gradient-to-r from-white via-purple-200 to-violet-300 bg-clip-text text-transparent mb-6",
                        children: "Work That Speaks"
                    }), m.jsxs("p", {
                        className: "text-2xl text-gray-400 max-w-3xl mx-auto",
                        children: ["From ", m.jsx("span", {
                            className: "text-cyan-400",
                            children: "video game design"
                        }), " to ", m.jsx("span", {
                            className: "text-purple-400",
                            children: "global brands"
                        }), ", decades of creative innovation now powered by AI"]
                    })]
                }), m.jsxs("div", {
                    className: "space-y-20",
                    style: {
                        perspective: "1500px"
                    },
                    children: [m.jsxs("div", {
                        className: "group relative card-3d-subtle",
                        children: [m.jsx("div", {
                            className: "absolute inset-0 bg-gradient-to-br from-violet-500/20 to-purple-600/20 rounded-3xl blur-3xl group-hover:blur-[80px] transition-all duration-500"
                        }), m.jsx("div", {
                            className: "relative bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-xl rounded-3xl overflow-hidden border border-white/10 group-hover:border-violet-400/50 transition-all",
                            children: m.jsxs("div", {
                                className: "grid lg:grid-cols-2 gap-0",
                                children: [m.jsxs("div", {
                                    className: "p-12 flex flex-col justify-center order-2 lg:order-1",
                                    children: [m.jsxs("div", {
                                        className: "inline-flex items-center gap-2 bg-violet-500/10 border border-violet-400/30 px-4 py-2 rounded-full mb-6 w-fit",
                                        children: [m.jsx(Yl, {
                                            className: "w-4 h-4 text-violet-400"
                                        }), m.jsx("span", {
                                            className: "text-xs font-bold text-violet-300",
                                            children: "APP DEVELOPMENT"
                                        })]
                                    }), m.jsx("h3", {
                                        className: "text-4xl font-black text-white mb-4 bg-gradient-to-r from-violet-400 to-purple-400 bg-clip-text text-transparent",
                                        children: "Making an App: Design. Code. Storyboard. Develop."
                                    }), m.jsx("p", {
                                        className: "text-lg text-gray-300 mb-6 leading-relaxed",
                                        children: "I just wrapped a project that blends everything I lovecreativity, AI automation, and storytelling. Built with Claude Code, Adobe After Effects, Illustrator/XD, Udio, and ElevenLabs voice modeling, it shows how design, storytelling, and AI can work in harmony. Thanks to modern AI-powered tools, full-stack web applications with intelligent automation and responsive design can now be built in weeksor even daysinstead of months or years, making custom apps accessible for nearly any budget."
                                    }), m.jsxs("div", {
                                        className: "flex flex-wrap gap-3",
                                        children: [m.jsx("span", {
                                            className: "px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-gray-300",
                                            children: "Claude Code"
                                        }), m.jsx("span", {
                                            className: "px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-gray-300",
                                            children: "After Effects"
                                        }), m.jsx("span", {
                                            className: "px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-gray-300",
                                            children: "Illustrator/XD"
                                        }), m.jsx("span", {
                                            className: "px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-gray-300",
                                            children: "Udio"
                                        }), m.jsx("span", {
                                            className: "px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-gray-300",
                                            children: "ElevenLabs"
                                        })]
                                    })]
                                }), m.jsx("div", {
                                    className: "relative h-96 lg:h-auto bg-slate-900 overflow-hidden order-1 lg:order-2",
                                    children: m.jsx("div", {
                                        style: {
                                            padding: "56.25% 0 0 0",
                                            position: "relative"
                                        },
                                        children: m.jsx("iframe", {
                                            src: "https://player.vimeo.com/video/1127354530?title=0&byline=0&portrait=0&badge=0&autopause=0&player_id=0&app_id=58479",
                                            frameBorder: "0",
                                            allow: "autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share",
                                            referrerPolicy: "strict-origin-when-cross-origin",
                                            style: {
                                                position: "absolute",
                                                top: 0,
                                                left: 0,
                                                width: "100%",
                                                height: "100%"
                                            },
                                            title: "Making an App: Design. Code. Storyboard. Develop"
                                        })
                                    })
                                })]
                            })
                        })]
                    }), m.jsxs("div", {
                        className: "group relative card-3d-subtle",
                        children: [m.jsx("div", {
                            className: "absolute inset-0 bg-gradient-to-br from-cyan-500/20 to-blue-600/20 rounded-3xl blur-3xl group-hover:blur-[80px] transition-all duration-500"
                        }), m.jsx("div", {
                            className: "relative bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-xl rounded-3xl overflow-hidden border border-white/10 group-hover:border-cyan-400/50 transition-all",
                            children: m.jsxs("div", {
                                className: "grid lg:grid-cols-2 gap-0",
                                children: [m.jsx("div", {
                                    className: "relative h-96 lg:h-auto bg-slate-900 overflow-hidden",
                                    children: m.jsx("div", {
                                        style: {
                                            padding: "56.25% 0 0 0",
                                            position: "relative"
                                        },
                                        children: m.jsx("iframe", {
                                            src: "https://player.vimeo.com/video/1080359548?badge=0&autopause=0&player_id=0&app_id=58479",
                                            style: {
                                                position: "absolute",
                                                top: 0,
                                                left: 0,
                                                width: "100%",
                                                height: "100%"
                                            },
                                            frameBorder: "0",
                                            allow: "autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share",
                                            allowFullScreen: !0,
                                            referrerPolicy: "strict-origin-when-cross-origin",
                                            title: "Static to Agentic AI - A Journey Through the Evolution of AI"
                                        })
                                    })
                                }), m.jsxs("div", {
                                    className: "p-12 flex flex-col justify-center",
                                    children: [m.jsxs("div", {
                                        className: "inline-flex items-center gap-2 bg-cyan-500/10 border border-cyan-400/30 px-4 py-2 rounded-full mb-6 w-fit",
                                        children: [m.jsx(sa, {
                                            className: "w-4 h-4 text-cyan-400"
                                        }), m.jsx("span", {
                                            className: "text-xs font-bold text-cyan-300",
                                            children: "AI-ENHANCED VIDEO"
                                        })]
                                    }), m.jsx("h3", {
                                        className: "text-4xl font-black text-white mb-4 bg-gradient-to-r from-cyan-400 to-blue-400 bg-clip-text text-transparent",
                                        children: "AI-Driven Video"
                                    }), m.jsxs("p", {
                                        className: "text-lg text-gray-300 mb-6 leading-relaxed",
                                        children: ["For ", m.jsx("span", {
                                            className: "text-cyan-400 font-semibold",
                                            children: "NTT DATA"
                                        }), ", I co-directed a cinematic short film that reimagines a slide deck as a live demonstration of AI's evolutionfrom static concepts to dynamic systems. Using tools like Runway, Kling, and ElevenLabs, we transformed a single visual into an AI-powered narrative, shaped by deep collaboration with Raleigh Murch, whose creative direction and enterprise AI expertise pushed the project further. A storytelling experiment in using AI to show what AI can do."]
                                    }), m.jsxs("div", {
                                        className: "flex flex-wrap gap-3",
                                        children: [m.jsx("span", {
                                            className: "px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-gray-300",
                                            children: "Kling AI"
                                        }), m.jsx("span", {
                                            className: "px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-gray-300",
                                            children: "Runway"
                                        }), m.jsx("span", {
                                            className: "px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-gray-300",
                                            children: "ElevenLabs"
                                        }), m.jsx("span", {
                                            className: "px-4 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-gray-300",
                                            children: "After Effects"
                                        })]
                                    })]
                                })]
                            })
                        })]
                    }), m.jsxs("div", {
                        className: "grid md:grid-cols-2 gap-8",
                        style: {
                            perspective: "1200px"
                        },
                        children: [m.jsxs("div", {
                            className: "group relative card-3d",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 bg-gradient-to-br from-amber-500/20 to-orange-600/20 rounded-3xl blur-2xl group-hover:blur-3xl transition-all duration-500"
                            }), m.jsxs("div", {
                                className: "relative bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-xl rounded-3xl overflow-hidden border border-white/10 group-hover:border-amber-400/50 transition-all h-full",
                                children: [m.jsxs("div", {
                                    className: "relative h-64 bg-gradient-to-br from-slate-800 to-slate-900 overflow-hidden",
                                    children: [m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-br from-cyan-900/30 to-blue-900/30"
                                    }), m.jsx("div", {
                                        ref: b,
                                        className: "absolute inset-0 flex items-end justify-center -mb-64",
                                        children: m.jsx("img", {
                                            src: "/lighthouse-isometric-1.png",
                                            alt: "Motion Graphics & 3D Work",
                                            className: "w-[140%] h-[140%] object-contain transition-transform duration-300 ease-out",
                                            style: {
                                                transform: `scale(${u})`
                                            }
                                        })
                                    }), m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-t from-slate-900/60 via-transparent to-transparent"
                                    })]
                                }), m.jsxs("div", {
                                    className: "p-8",
                                    children: [m.jsxs("div", {
                                        className: "inline-flex items-center gap-2 bg-cyan-500/10 border border-cyan-400/30 px-3 py-1.5 rounded-full mb-4 w-fit",
                                        children: [m.jsx(kd, {
                                            className: "w-3.5 h-3.5 text-cyan-400"
                                        }), m.jsx("span", {
                                            className: "text-xs font-bold text-cyan-300",
                                            children: "ANIMATION & DESIGN"
                                        })]
                                    }), m.jsx("h3", {
                                        className: "text-2xl font-black text-white mb-3 bg-gradient-to-r from-cyan-400 to-blue-400 bg-clip-text text-transparent",
                                        children: "Motion Graphics & 3D"
                                    }), m.jsx("p", {
                                        className: "text-gray-300 mb-4 leading-relaxed",
                                        children: "Adobe Creative Suite mastery combined with AI tools. Animation, motion graphics, 3D design, and brand storytelling."
                                    }), m.jsxs("div", {
                                        className: "flex flex-wrap gap-2 mb-6",
                                        children: [m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "Illustrator"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "After Effects"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "Cinema 4D"
                                        })]
                                    }), m.jsxs("a", {
                                        href: "https://danmeyersdesign.myportfolio.com/",
                                        target: "_blank",
                                        rel: "noopener noreferrer",
                                        className: "group/link inline-flex items-center gap-2 text-amber-400 hover:text-amber-300 font-semibold transition-colors text-sm",
                                        children: ["View Details", m.jsx(tr, {
                                            className: "w-4 h-4 group-hover/link:translate-x-1 transition-transform"
                                        })]
                                    })]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "group relative card-3d",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 bg-gradient-to-br from-violet-500/20 to-purple-600/20 rounded-3xl blur-2xl group-hover:blur-3xl transition-all duration-500"
                            }), m.jsxs("div", {
                                className: "relative bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-xl rounded-3xl overflow-hidden border border-white/10 group-hover:border-violet-400/50 transition-all h-full",
                                children: [m.jsxs("div", {
                                    className: "relative h-64 bg-gradient-to-br from-slate-800 to-slate-900 overflow-hidden",
                                    children: [m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-br from-violet-500/20 to-purple-600/20"
                                    }), m.jsx("div", {
                                        ref: L,
                                        className: "absolute inset-0 flex items-end justify-center -mb-64",
                                        children: m.jsx("img", {
                                            src: "/n8n-workflow-example-2.png",
                                            alt: "AI Automation Workflow Example",
                                            className: "w-[140%] h-[140%] object-contain transition-transform duration-300 ease-out",
                                            style: {
                                                transform: `scale(${h})`
                                            }
                                        })
                                    }), m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-t from-slate-900/60 via-transparent to-transparent"
                                    })]
                                }), m.jsxs("div", {
                                    className: "p-8",
                                    children: [m.jsxs("div", {
                                        className: "inline-flex items-center gap-2 bg-violet-500/10 border border-violet-400/30 px-3 py-1.5 rounded-full mb-4 w-fit",
                                        children: [m.jsx(Yl, {
                                            className: "w-3.5 h-3.5 text-violet-400"
                                        }), m.jsx("span", {
                                            className: "text-xs font-bold text-violet-300",
                                            children: "WORKFLOW AUTOMATION"
                                        })]
                                    }), m.jsx("h3", {
                                        className: "text-2xl font-black text-white mb-3 bg-gradient-to-r from-violet-400 to-purple-400 bg-clip-text text-transparent",
                                        children: "AI Automations"
                                    }), m.jsx("p", {
                                        className: "text-gray-300 mb-4 leading-relaxed",
                                        children: "Intelligent workflow automation that connects your tools and streamlines operations. From simple task automation to complex multi-step processes, I build systems that handle repetitive work, integrate APIs, and orchestrate AI agents to transform how your business operatessaving time, reducing errors, and scaling effortlessly."
                                    }), m.jsxs("div", {
                                        className: "flex flex-wrap gap-2 mb-6",
                                        children: [m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "n8n"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "Make"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "Zapier"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "Claude Code"
                                        })]
                                    }), m.jsxs("a", {
                                        href: "https://danmeyersdesign.myportfolio.com/",
                                        target: "_blank",
                                        rel: "noopener noreferrer",
                                        className: "group/link inline-flex items-center gap-2 text-violet-400 hover:text-violet-300 font-semibold transition-colors text-sm",
                                        children: ["View Details", m.jsx(tr, {
                                            className: "w-4 h-4 group-hover/link:translate-x-1 transition-transform"
                                        })]
                                    })]
                                })]
                            })]
                        })]
                    }), m.jsxs("div", {
                        className: "grid md:grid-cols-2 gap-8",
                        style: {
                            perspective: "1200px"
                        },
                        children: [m.jsxs("div", {
                            className: "group relative card-3d",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 bg-gradient-to-br from-pink-500/20 to-rose-600/20 rounded-3xl blur-2xl group-hover:blur-3xl transition-all duration-500"
                            }), m.jsxs("div", {
                                className: "relative bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-xl rounded-3xl overflow-hidden border border-white/10 group-hover:border-pink-400/50 transition-all h-full",
                                children: [m.jsxs("div", {
                                    className: "relative h-64 bg-gradient-to-br from-slate-800 to-slate-900 overflow-hidden",
                                    children: [m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-br from-pink-500/20 to-rose-600/20"
                                    }), m.jsx("div", {
                                        ref: F,
                                        className: "absolute inset-0 flex items-end justify-center -mb-64",
                                        children: m.jsx("img", {
                                            src: "/social-media-for-website.png",
                                            alt: "Social Media Portfolio",
                                            className: "w-[140%] h-[140%] object-contain transition-transform duration-300 ease-out",
                                            style: {
                                                transform: `scale(${v})`
                                            }
                                        })
                                    }), m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-t from-slate-900/60 via-transparent to-transparent"
                                    })]
                                }), m.jsxs("div", {
                                    className: "p-8",
                                    children: [m.jsxs("div", {
                                        className: "inline-flex items-center gap-2 bg-pink-500/10 border border-pink-400/30 px-3 py-1.5 rounded-full mb-4 w-fit",
                                        children: [m.jsx(sa, {
                                            className: "w-3.5 h-3.5 text-pink-400"
                                        }), m.jsx("span", {
                                            className: "text-xs font-bold text-pink-300",
                                            children: "SOCIAL CONTENT"
                                        })]
                                    }), m.jsx("h3", {
                                        className: "text-2xl font-black text-white mb-3 bg-gradient-to-r from-pink-400 to-rose-400 bg-clip-text text-transparent",
                                        children: "Social Media"
                                    }), m.jsxs("p", {
                                        className: "text-gray-300 mb-4 leading-relaxed",
                                        children: ["Storytelling reels and short-form videos for Instagram, YouTube, TikTok, and LinkedIn that entertain, educate, and inspire. My latest client, Mount Hood Brewing Co., saw a ", m.jsx("span", {
                                            className: "text-pink-400 font-semibold",
                                            children: "1326% increase in engagement"
                                        }), " after I took over their social contentproving that when you deliver genuine value instead of just selling, audiences respond."]
                                    }), m.jsxs("div", {
                                        className: "flex flex-wrap gap-2 mb-6",
                                        children: [m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "Instagram"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "TikTok"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "YouTube"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "LinkedIn"
                                        })]
                                    }), m.jsxs("a", {
                                        href: "https://danmeyersdesign.myportfolio.com/",
                                        target: "_blank",
                                        rel: "noopener noreferrer",
                                        className: "group/link inline-flex items-center gap-2 text-pink-400 hover:text-pink-300 font-semibold transition-colors text-sm",
                                        children: ["View Details", m.jsx(tr, {
                                            className: "w-4 h-4 group-hover/link:translate-x-1 transition-transform"
                                        })]
                                    })]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "group relative card-3d",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 bg-gradient-to-br from-teal-500/20 to-emerald-600/20 rounded-3xl blur-2xl group-hover:blur-3xl transition-all duration-500"
                            }), m.jsxs("div", {
                                className: "relative bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-xl rounded-3xl overflow-hidden border border-white/10 group-hover:border-teal-400/50 transition-all h-full",
                                children: [m.jsxs("div", {
                                    className: "relative h-64 bg-gradient-to-br from-slate-800 to-slate-900 overflow-hidden",
                                    children: [m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-br from-teal-500/10 to-emerald-600/10"
                                    }), m.jsx("div", {
                                        ref: H,
                                        className: "absolute inset-0 flex items-end justify-center -mb-64",
                                        children: m.jsx("img", {
                                            src: "/brands-for-content-strategy-website.png",
                                            alt: "Content Strategy Portfolio",
                                            className: "w-[140%] h-[140%] object-contain transition-transform duration-300 ease-out",
                                            style: {
                                                transform: `scale(${g})`
                                            }
                                        })
                                    }), m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-t from-slate-900/60 via-transparent to-transparent"
                                    })]
                                }), m.jsxs("div", {
                                    className: "p-8",
                                    children: [m.jsxs("div", {
                                        className: "inline-flex items-center gap-2 bg-teal-500/10 border border-teal-400/30 px-3 py-1.5 rounded-full mb-4 w-fit",
                                        children: [m.jsx(iv, {
                                            className: "w-3.5 h-3.5 text-teal-400"
                                        }), m.jsx("span", {
                                            className: "text-xs font-bold text-teal-300",
                                            children: "STRATEGY & MANAGEMENT"
                                        })]
                                    }), m.jsx("h3", {
                                        className: "text-2xl font-black text-white mb-3 bg-gradient-to-r from-teal-400 to-emerald-400 bg-clip-text text-transparent",
                                        children: "Content Strategy"
                                    }), m.jsx("p", {
                                        className: "text-gray-300 mb-4 leading-relaxed",
                                        children: "Comprehensive brand management, content strategy, and marketing campaigns that drive results. From Fortune 500 companies to emerging startups, I develop cohesive brand identities, strategic messaging frameworks, and omnichannel content strategies that align business objectives with audience needs and market opportunities."
                                    }), m.jsxs("div", {
                                        className: "flex flex-wrap gap-2 mb-6",
                                        children: [m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "Brand Identity"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "Content Strategy"
                                        }), m.jsx("span", {
                                            className: "px-3 py-1 bg-white/5 border border-white/10 rounded-lg text-xs text-gray-400",
                                            children: "Campaigns"
                                        })]
                                    }), m.jsxs("a", {
                                        href: "https://danmeyersdesign.myportfolio.com/",
                                        target: "_blank",
                                        rel: "noopener noreferrer",
                                        className: "group/link inline-flex items-center gap-2 text-teal-400 hover:text-teal-300 font-semibold transition-colors text-sm",
                                        children: ["View Details", m.jsx(tr, {
                                            className: "w-4 h-4 group-hover/link:translate-x-1 transition-transform"
                                        })]
                                    })]
                                })]
                            })]
                        })]
                    }), m.jsxs("div", {
                        className: "grid md:grid-cols-3 gap-6",
                        style: {
                            perspective: "1200px"
                        },
                        children: [m.jsxs("div", {
                            className: "group relative card-3d",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 bg-gradient-to-br from-violet-500 to-purple-600 opacity-0 group-hover:opacity-20 rounded-2xl blur-xl transition-all"
                            }), m.jsxs("div", {
                                className: "relative bg-white/5 backdrop-blur-sm rounded-2xl overflow-hidden border border-white/10 group-hover:border-violet-400/50 transition-all",
                                children: [m.jsx("div", {
                                    className: "relative bg-gradient-to-br from-slate-800 to-slate-900",
                                    style: {
                                        padding: "56.25% 0 0 0"
                                    },
                                    children: m.jsx("iframe", {
                                        src: "https://player.vimeo.com/video/1094203077?title=0&byline=0&portrait=0&badge=0&autopause=0&player_id=0&app_id=58479",
                                        frameBorder: "0",
                                        allow: "autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share",
                                        style: {
                                            position: "absolute",
                                            top: 0,
                                            left: 0,
                                            width: "100%",
                                            height: "100%"
                                        },
                                        title: "A Little Too Real"
                                    })
                                }), m.jsxs("div", {
                                    className: "p-6",
                                    children: [m.jsxs("div", {
                                        className: "inline-flex items-center gap-2 bg-violet-500/10 border border-violet-400/30 px-3 py-1.5 rounded-full mb-3 w-fit",
                                        children: [m.jsx(Su, {
                                            className: "w-3.5 h-3.5 text-violet-400"
                                        }), m.jsx("span", {
                                            className: "text-xs font-bold text-violet-300",
                                            children: "AI SHORT"
                                        })]
                                    }), m.jsx("h4", {
                                        className: "text-lg font-bold text-white mb-2",
                                        children: "AI Short"
                                    }), m.jsx("p", {
                                        className: "text-gray-200 text-sm leading-relaxed",
                                        children: "This cinematic AI short, created with VEO 3, Kling 2.1, Hedra, and Eleven Labs (final editing in Premiere Pro), explores jungle suspense and AI storytelling. This personal project was done right when VEO 3 dropped, as an exercise to explore the new tool."
                                    })]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "group relative card-3d",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 bg-gradient-to-br from-rose-500 to-red-600 opacity-0 group-hover:opacity-20 rounded-2xl blur-xl transition-all"
                            }), m.jsxs("div", {
                                className: "relative bg-white/5 backdrop-blur-sm rounded-2xl overflow-hidden border border-white/10 group-hover:border-rose-400/50 transition-all",
                                children: [m.jsx("div", {
                                    className: "relative bg-gradient-to-br from-slate-800 to-slate-900",
                                    style: {
                                        padding: "56.25% 0 0 0"
                                    },
                                    children: m.jsx("iframe", {
                                        src: "https://player.vimeo.com/video/1119569228?title=0&byline=0&portrait=0&badge=0&autopause=0&player_id=0&app_id=58479",
                                        frameBorder: "0",
                                        allow: "autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share",
                                        referrerPolicy: "strict-origin-when-cross-origin",
                                        style: {
                                            position: "absolute",
                                            top: 0,
                                            left: 0,
                                            width: "100%",
                                            height: "100%"
                                        },
                                        title: "Our Name is Dare 21"
                                    })
                                }), m.jsxs("div", {
                                    className: "p-6",
                                    children: [m.jsxs("div", {
                                        className: "inline-flex items-center gap-2 bg-rose-500/10 border border-rose-400/30 px-3 py-1.5 rounded-full mb-3 w-fit",
                                        children: [m.jsx(sa, {
                                            className: "w-3.5 h-3.5 text-rose-400"
                                        }), m.jsx("span", {
                                            className: "text-xs font-bold text-rose-300",
                                            children: "BOOK PROMO"
                                        })]
                                    }), m.jsx("h4", {
                                        className: "text-lg font-bold text-white mb-2",
                                        children: "Book Promo"
                                    }), m.jsx("p", {
                                        className: "text-gray-200 text-sm leading-relaxed",
                                        children: "I'm excited to share the official book trailer for Our Name Is Dare by author Kev Coleman. I crafted it using chiaroscuro portraiture, protest archive footage, and original sound design to reflect the novel's tense, poetic tone. The result is a cinematic glimpse into a crumbling world, echoing more Dostoevsky than a standard thriller."
                                    })]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "group relative card-3d",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 bg-gradient-to-br from-amber-500 to-orange-600 opacity-0 group-hover:opacity-20 rounded-2xl blur-xl transition-all"
                            }), m.jsxs("div", {
                                className: "relative bg-white/5 backdrop-blur-sm rounded-2xl overflow-hidden border border-white/10 group-hover:border-amber-400/50 transition-all",
                                children: [m.jsx("div", {
                                    className: "relative bg-gradient-to-br from-slate-800 to-slate-900",
                                    style: {
                                        padding: "56.25% 0 0 0"
                                    },
                                    children: m.jsx("iframe", {
                                        src: "https://player.vimeo.com/video/941437250?title=0&byline=0&portrait=0&badge=0&autopause=0&player_id=0&app_id=58479",
                                        frameBorder: "0",
                                        allow: "autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share",
                                        style: {
                                            position: "absolute",
                                            top: 0,
                                            left: 0,
                                            width: "100%",
                                            height: "100%"
                                        },
                                        title: "Atomic Highway"
                                    })
                                }), m.jsxs("div", {
                                    className: "p-6",
                                    children: [m.jsxs("div", {
                                        className: "inline-flex items-center gap-2 bg-amber-500/10 border border-amber-400/30 px-3 py-1.5 rounded-full mb-3 w-fit",
                                        children: [m.jsx(Od, {
                                            className: "w-3.5 h-3.5 text-amber-400"
                                        }), m.jsx("span", {
                                            className: "text-xs font-bold text-amber-300",
                                            children: "INTERACTIVE VIDEO"
                                        })]
                                    }), m.jsx("h4", {
                                        className: "text-lg font-bold text-white mb-2",
                                        children: "Interactive Video"
                                    }), m.jsx("p", {
                                        className: "text-gray-200 text-sm leading-relaxed",
                                        children: "Exploring the fusion of AI art and app design, I built a doomsday escape room prototype using Justinmind, set in a decaying diner in the New Mexico desert. The visuals were created with Dreamstudio.ai, inspired by a recent trip and the history of Los Alamos. The interactive portion unfolds inside the diner itself."
                                    })]
                                })]
                            })]
                        })]
                    })]
                }), m.jsxs("div", {
                    className: "mt-20 text-center",
                    children: [m.jsxs("div", {
                        className: "relative inline-block group",
                        children: [m.jsx("div", {
                            className: "absolute inset-0 bg-gradient-to-r from-purple-500 to-violet-600 rounded-2xl blur-2xl opacity-60 group-hover:opacity-100 transition-opacity"
                        }), m.jsxs("a", {
                            href: "https://danmeyersdesign.myportfolio.com/",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            className: "relative inline-flex items-center gap-3 bg-gradient-to-r from-purple-500/30 to-violet-600/30 backdrop-blur-xl border-2 border-purple-400/40 px-10 py-5 rounded-2xl font-bold text-xl text-white shadow-2xl hover:scale-105 hover:border-purple-300/60 transition-all",
                            children: ["View Complete Portfolio", m.jsx(tr, {
                                className: "w-6 h-6 group-hover:translate-x-2 transition-transform"
                            })]
                        })]
                    }), m.jsx("p", {
                        className: "mt-6 text-gray-400",
                        children: "Explore 20+ years of creative innovation"
                    })]
                })]
            })
        }), !1, m.jsx("section", {
            className: "relative py-24 px-6",
            children: m.jsxs("div", {
                className: "max-w-7xl mx-auto relative z-10",
                children: [m.jsxs("div", {
                    className: "text-center mb-20",
                    children: [m.jsxs("div", {
                        className: "inline-flex items-center gap-2 bg-teal-500/10 border border-teal-400/30 px-4 py-2 rounded-full mb-4",
                        children: [m.jsx(Ud, {
                            className: "w-4 h-4 text-teal-400"
                        }), m.jsx("span", {
                            className: "text-sm font-medium text-teal-300",
                            children: "Diverse Clientele"
                        })]
                    }), m.jsx("h2", {
                        className: "text-5xl md:text-6xl font-black bg-gradient-to-r from-white to-gray-300 bg-clip-text text-transparent mb-5",
                        children: "Who I Serve"
                    }), m.jsx("p", {
                        className: "text-xl text-gray-300",
                        children: "From Fortune 500s to aspiring young creators"
                    })]
                }), m.jsx("div", {
                    className: "grid md:grid-cols-3 gap-10",
                    style: {
                        perspective: "1200px"
                    },
                    children: [{
                        icon: tv,
                        title: "Companies",
                        desc: "Help your team catch up with AI, deploy efficiency solutions, and stay competitive. Corporate training or done-for-you implementation.",
                        gradient: "from-cyan-500 to-blue-600"
                    }, {
                        icon: Ud,
                        title: "Individuals",
                        desc: "Build your AI skills, create your own apps, or hire me to bring your ideas to life. Personalized coaching at your pace.",
                        gradient: "from-teal-500 to-emerald-600"
                    }, {
                        icon: Zl,
                        title: "Young Creators",
                        desc: "Teach kids and teens to build apps, create animations, and explore technology in any direction they're passionate about.",
                        gradient: "from-violet-500 to-purple-600"
                    }].map( (B, D) => m.jsxs("div", {
                        className: "group text-center card-3d-subtle",
                        children: [m.jsxs("div", {
                            className: "relative inline-flex mb-6",
                            children: [m.jsx("div", {
                                className: `absolute inset-0 bg-gradient-to-br ${B.gradient} rounded-3xl blur-xl opacity-50 group-hover:opacity-100 transition-opacity`
                            }), m.jsx("div", {
                                className: `relative bg-gradient-to-br ${B.gradient} p-5 rounded-3xl`,
                                children: m.jsx(B.icon, {
                                    className: "w-10 h-10 text-white",
                                    strokeWidth: 2.5
                                })
                            })]
                        }), m.jsx("h3", {
                            className: "text-2xl font-bold text-white mb-4",
                            children: B.title
                        }), m.jsx("p", {
                            className: "text-gray-300 leading-relaxed",
                            children: B.desc
                        })]
                    }, D))
                })]
            })
        }), m.jsx("section", {
            id: "about",
            className: "relative py-24 px-6",
            children: m.jsxs("div", {
                className: "max-w-5xl mx-auto relative z-10",
                children: [m.jsx("div", {
                    className: "text-center mb-16",
                    children: m.jsx("h2", {
                        className: "text-5xl md:text-6xl font-black bg-gradient-to-r from-white to-gray-300 bg-clip-text text-transparent mb-5",
                        children: "Deep Roots, Forward Vision"
                    })
                }), m.jsxs("div", {
                    className: "relative group card-3d-subtle",
                    style: {
                        perspective: "1200px"
                    },
                    children: [m.jsx("div", {
                        className: "absolute inset-0 bg-gradient-to-br from-cyan-500/20 via-blue-500/20 to-teal-500/20 rounded-3xl blur-2xl"
                    }), m.jsxs("div", {
                        className: "relative bg-white/10 backdrop-blur-xl rounded-3xl p-12 md:p-16 border border-white/20 overflow-hidden",
                        children: [m.jsxs("div", {
                            className: "flex flex-col lg:flex-row gap-8 lg:items-start items-center",
                            children: [m.jsxs("div", {
                                className: "space-y-6 text-lg text-gray-300 leading-relaxed flex-1",
                                children: [m.jsxs("p", {
                                    children: ["I bring together ", m.jsx("span", {
                                        className: "text-cyan-400 font-semibold",
                                        children: "decades of traditional media expertise"
                                    }), "  Adobe Creative Suite, video production, sound design, 3D work  with ", m.jsx("span", {
                                        className: "text-blue-400 font-semibold",
                                        children: "cutting-edge AI capabilities"
                                    }), ". From early video game design to patented sports products to global marketing campaigns, I've built a career at the intersection of creativity and technology."]
                                }), m.jsxs("p", {
                                    children: ["Today, AI has transformed what's possible. I help people and organizations ", m.jsx("span", {
                                        className: "text-teal-400 font-semibold",
                                        children: "navigate this shift without overwhelm"
                                    }), ", whether that means building custom solutions, teaching new skills, or providing strategic consultation."]
                                }), m.jsxs("p", {
                                    children: ["Solo consultant with team access when deeper expertise is needed. ", m.jsx("span", {
                                        className: "text-white font-semibold",
                                        children: "Flexible, practical, and always focused on real-world results."
                                    })]
                                })]
                            }), m.jsx("div", {
                                className: "lg:w-80 flex-shrink-0",
                                children: m.jsxs("div", {
                                    className: "relative group/img",
                                    children: [m.jsx("div", {
                                        className: "absolute inset-0 bg-gradient-to-br from-cyan-400/30 to-blue-600/30 rounded-2xl blur-xl group-hover/img:blur-2xl transition-all"
                                    }), m.jsx("img", {
                                        src: "/about-image-of-dan.png",
                                        alt: "Dan Meyers",
                                        className: "relative rounded-2xl border border-white/20 shadow-2xl group-hover/img:scale-105 transition-transform duration-500"
                                    })]
                                })
                            })]
                        }), m.jsxs("div", {
                            className: "mt-10 flex flex-wrap gap-5 justify-center",
                            children: [m.jsx("a", {
                                href: "https://www.linkedin.com/in/dan-meyers-content-strategist",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                className: "group/link relative overflow-hidden bg-white/5 backdrop-blur-sm border border-white/20 px-6 py-3 rounded-xl font-semibold hover:bg-white/10 transition-all hover:scale-105",
                                children: m.jsxs("span", {
                                    className: "flex items-center gap-2 text-white",
                                    children: ["View LinkedIn Profile", m.jsx(tr, {
                                        className: "w-4 h-4 group-hover/link:translate-x-1 transition-transform"
                                    })]
                                })
                            }), m.jsxs("a", {
                                href: "https://danmeyersdesign.myportfolio.com/",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                className: "group/link relative overflow-hidden bg-gradient-to-r from-cyan-500 to-blue-600 px-6 py-3 rounded-xl font-semibold shadow-lg shadow-cyan-500/30 hover:shadow-xl hover:shadow-cyan-500/50 transition-all hover:scale-105",
                                children: [m.jsxs("span", {
                                    className: "relative z-10 flex items-center gap-2 text-white",
                                    children: ["Portfolio Gallery", m.jsx(tr, {
                                        className: "w-4 h-4 group-hover/link:translate-x-1 transition-transform"
                                    })]
                                }), m.jsx("div", {
                                    className: "absolute inset-0 bg-gradient-to-r from-cyan-400 to-blue-500 opacity-0 group-hover/link:opacity-100 transition-opacity"
                                })]
                            })]
                        })]
                    })]
                })]
            })
        }), m.jsx("section", {
            className: "relative py-32 px-6",
            children: m.jsx("div", {
                className: "max-w-5xl mx-auto text-center relative z-10",
                style: {
                    perspective: "1200px"
                },
                children: m.jsxs("div", {
                    className: "relative group card-3d-subtle",
                    children: [m.jsx("div", {
                        className: "absolute inset-0 bg-gradient-to-r from-cyan-500 via-blue-500 to-teal-500 rounded-3xl blur-2xl opacity-50 group-hover:opacity-70 transition-opacity"
                    }), m.jsxs("div", {
                        className: "relative bg-white/15 backdrop-blur-xl rounded-3xl p-16 border border-white/30",
                        children: [m.jsx("h2", {
                            className: "text-5xl md:text-6xl font-black text-white mb-6",
                            children: "Ready to Get Started?"
                        }), m.jsx("p", {
                            className: "text-2xl mb-10 text-white/90",
                            children: "Let's discuss how I can help you build, learn, or transform with AI."
                        }), m.jsx("button", {
                            onClick: () => i(!0),
                            className: "group relative overflow-hidden bg-white/20 backdrop-blur-xl border-2 border-white/40 text-white px-12 py-5 rounded-2xl font-bold text-xl shadow-2xl hover:scale-105 hover:bg-white/30 hover:border-white/60 hover:shadow-[0_0_40px_rgba(255,255,255,0.3)] transition-all button-hover-lift",
                            children: m.jsxs("span", {
                                className: "relative z-10 flex items-center justify-center gap-3",
                                children: ["Schedule a Consultation", m.jsx(nv, {
                                    className: "w-6 h-6 group-hover:translate-y-[-2px] transition-transform"
                                })]
                            })
                        })]
                    })]
                })
            })
        }), m.jsx("footer", {
            className: "relative border-t border-white/10 py-12 px-6",
            children: m.jsx("div", {
                className: "max-w-7xl mx-auto relative z-10",
                children: m.jsxs("div", {
                    className: "flex flex-col md:flex-row justify-between items-center gap-6",
                    children: [m.jsxs("div", {
                        className: "flex items-center gap-3 cursor-pointer group",
                        onMouseEnter: q,
                        onClick: q,
                        children: [m.jsxs("div", {
                            className: "relative",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 bg-cyan-400/0 group-hover:bg-cyan-400/50 blur-2xl transition-all duration-500 rounded-full"
                            }), m.jsx(Rs.img, {
                                src: "/lighthouse-logo-3.png",
                                alt: "Lighthouse AI",
                                className: "w-16 h-16 object-contain relative z-10 group-hover:drop-shadow-[0_0_20px_rgba(34,211,238,0.8)] transition-all duration-500",
                                whileHover: {
                                    rotate: [0, -5, 5, -5, 5, 0],
                                    scale: 1.1
                                },
                                transition: {
                                    duration: .5
                                }
                            })]
                        }), m.jsx("span", {
                            className: "text-xl font-bold bg-gradient-to-r from-cyan-400 via-blue-400 to-teal-400 bg-clip-text text-transparent",
                            children: "Lighthouse AI"
                        })]
                    }), m.jsx("div", {
                        className: "text-center md:text-right",
                        children: m.jsx("p", {
                            className: "text-sm text-gray-400",
                            children: " 2025 Lighthouse AI. Navigate AI without overwhelm."
                        })
                    })]
                })
            })
        }), m.jsx(nD, {
            isOpen: t,
            onClose: () => e(!1)
        }), m.jsx(rD, {
            isOpen: n,
            onClose: () => i(!1)
        })]
    })
}
HS(document.getElementById("root")).render(m.jsx(oe.StrictMode, {
    children: m.jsx(SO, {})
}));
